/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of10

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func decodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	return &BsnInterface{}
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	return &BsnVport{
		Type: _type,
	}
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 56", decoder.Length())
	}
	bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	bsnvportl2gre.PortNo.Decode(decoder)
	bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	return &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	return &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	Match        Match
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Actions      []IAction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 88 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 88", decoder.Length())
	}
	flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(flowstatsentry.Length), 2+0)
	flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	if err := flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	flowstatsentry.DurationSec = uint32(decoder.ReadUint32())
	flowstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	flowstatsentry.Priority = uint16(decoder.ReadUint16())
	flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	flowstatsentry.PacketCount = uint64(decoder.ReadUint64())
	flowstatsentry.ByteCount = uint64(decoder.ReadUint64())

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		flowstatsentry.Actions = append(flowstatsentry.Actions, item)
	}
	return flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	return &FlowStatsEntry{}
}

type MatchV1 struct {
	Wildcards WcBmap
	InPort    PortNo
	EthSrc    net.HardwareAddr
	EthDst    net.HardwareAddr
	VlanVid   uint16
	VlanPcp   uint8
	EthType   uint16
	IpDscp    uint8
	IpProto   uint8
	Ipv4Src   net.IP
	Ipv4Dst   net.IP
	TcpSrc    uint16
	TcpDst    uint16
}

func (self *MatchV1) Serialize(encoder *goloxi.Encoder) error {
	self.Wildcards.Serialize(encoder)
	self.InPort.Serialize(encoder)
	encoder.Write(self.EthSrc)
	encoder.Write(self.EthDst)
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.PutUint8(uint8(self.VlanPcp))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.EthType))
	encoder.PutUint8(uint8(self.IpDscp))
	encoder.PutUint8(uint8(self.IpProto))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.Ipv4Src.To4())
	encoder.Write(self.Ipv4Dst.To4())
	encoder.PutUint16(uint16(self.TcpSrc))
	encoder.PutUint16(uint16(self.TcpDst))

	return nil
}
func (self *MatchV1) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 40 {
		return fmt.Errorf("MatchV1 packet too short: %d < 40", decoder.Length())
	}

	self.Wildcards.Decode(decoder)
	self.InPort.Decode(decoder)
	self.EthSrc = net.HardwareAddr(decoder.Read(6))
	self.EthDst = net.HardwareAddr(decoder.Read(6))
	self.VlanVid = uint16(decoder.ReadUint16())
	self.VlanPcp = uint8(decoder.ReadByte())
	decoder.Skip(1)
	self.EthType = uint16(decoder.ReadUint16())
	self.IpDscp = uint8(decoder.ReadByte())
	self.IpProto = uint8(decoder.ReadByte())
	decoder.Skip(2)
	self.Ipv4Src = net.IP(decoder.Read(4))
	self.Ipv4Dst = net.IP(decoder.Read(4))
	self.TcpSrc = uint16(decoder.ReadUint16())
	self.TcpDst = uint16(decoder.ReadUint16())

	return nil
}

func NewMatchV1() *MatchV1 {
	return &MatchV1{}
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	return &NiciraMatch{}
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowstats.Length), 2+0)
	niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	niciraflowstats.Priority = uint16(decoder.ReadUint16())
	niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := niciraflowstats.Match.Decode(decoder.SliceDecoder(int(niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowstats.Actions = append(niciraflowstats.Actions, item)
	}
	return niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	return &NiciraFlowStats{}
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func decodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowupdateevent.Length), 2+0)
	niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch niciraflowupdateevent.Event {
	case 0:
		return decodeNiciraFlowUpdateFullAdd(niciraflowupdateevent, decoder)
	case 1:
		return decodeNiciraFlowUpdateFullDeleted(niciraflowupdateevent, decoder)
	case 2:
		return decodeNiciraFlowUpdateFullModified(niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	return &NiciraFlowUpdateEvent{
		Event: _event,
	}
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulladd.Actions = append(niciraflowupdatefulladd.Actions, item)
	}
	return niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	return &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulldeleted.Actions = append(niciraflowupdatefulldeleted.Actions, item)
	}
	return niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	return &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefullmodified.Actions = append(niciraflowupdatefullmodified.Actions, item)
	}
	return niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	return &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
}

type PacketQueue struct {
	QueueId    uint32
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	packetqueue := &PacketQueue{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 8", decoder.Length())
	}
	packetqueue.QueueId = uint32(decoder.ReadUint32())
	packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(packetqueue.Len), 2+4)
	decoder.Skip(2)

	for decoder.Length() >= 8 {
		item, err := decodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		packetqueue.Properties = append(packetqueue.Properties, item)
	}
	return packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	return &PacketQueue{}
}

type PortDesc struct {
	PortNo     PortNo
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Curr       PortFeatures
	Advertised PortFeatures
	Supported  PortFeatures
	Peer       PortFeatures
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(self.HwAddr)
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 48 {
		return fmt.Errorf("PortDesc packet too short: %d < 48", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())
	self.Curr = PortFeatures(decoder.ReadUint32())
	self.Advertised = PortFeatures(decoder.ReadUint32())
	self.Supported = PortFeatures(decoder.ReadUint32())
	self.Peer = PortFeatures(decoder.ReadUint32())

	return nil
}

func NewPortDesc() *PortDesc {
	return &PortDesc{}
}

type PortStatsEntry struct {
	PortNo     PortNo
	RxPackets  uint64
	TxPackets  uint64
	RxBytes    uint64
	TxBytes    uint64
	RxDropped  uint64
	TxDropped  uint64
	RxErrors   uint64
	TxErrors   uint64
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	return nil
}

func decodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 104 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 104", decoder.Length())
	}
	portstatsentry.PortNo.Decode(decoder)
	decoder.Skip(6)
	portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	portstatsentry.TxErrors = uint64(decoder.ReadUint64())
	portstatsentry.RxFrameErr = uint64(decoder.ReadUint64())
	portstatsentry.RxOverErr = uint64(decoder.ReadUint64())
	portstatsentry.RxCrcErr = uint64(decoder.ReadUint64())
	portstatsentry.Collisions = uint64(decoder.ReadUint64())
	return portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	return &PortStatsEntry{}
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	queueprop.Type = uint16(decoder.ReadUint16())
	queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queueprop.Len), 2+2)

	switch queueprop.Type {
	case 1:
		return decodeQueuePropMinRate(queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	return &QueueProp{
		Type: _type,
	}
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	return &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
}

type QueueStatsEntry struct {
	PortNo    PortNo
	QueueId   uint32
	TxBytes   uint64
	TxPackets uint64
	TxErrors  uint64
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))

	return nil
}

func decodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 32", decoder.Length())
	}
	queuestatsentry.PortNo.Decode(decoder)
	decoder.Skip(2)
	queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	return queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	return &QueueStatsEntry{}
}

type TableStatsEntry struct {
	TableId      uint8
	Name         string
	Wildcards    WcBmap
	MaxEntries   uint32
	ActiveCount  uint32
	LookupCount  uint64
	MatchedCount uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write([]byte(self.Name))
	self.Wildcards.Serialize(encoder)
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func decodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 64", decoder.Length())
	}
	tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	tablestatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	tablestatsentry.Wildcards.Decode(decoder)
	tablestatsentry.MaxEntries = uint32(decoder.ReadUint32())
	tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	return &TableStatsEntry{}
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	return &EdPropHeader{
		PropClass: _prop_class,
	}
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func decodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	edpropnsh.Type = uint8(decoder.ReadByte())
	edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(edpropnsh.Len), 1+3)

	switch edpropnsh.Type {
	case 1:
		return decodeEdPropNshMdType(edpropnsh, decoder)
	case 2:
		return decodeEdPropNshTlv(edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	return &EdPropNsh{
		Type:         _type,
		EdPropHeader: NewEdPropHeader(4),
	}
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	return &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	return &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
}
