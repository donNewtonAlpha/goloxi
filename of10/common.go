/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of10

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func DecodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	_bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	_bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	_bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	_bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	_bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return _bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	obj := &BsnInterface{}
	return obj
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	obj := &BsnVport{}
	obj.Type = _type
	return obj
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	_bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 56", decoder.Length())
	}
	_bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	_bsnvportl2gre.PortNo.Decode(decoder)
	_bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	_bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	_bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	_bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	_bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	_bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	obj := &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
	return obj
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	_bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	_bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	_bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	obj := &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
	return obj
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	Match        Match
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Actions      []IAction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	_flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 88 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 88", decoder.Length())
	}
	_flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_flowstatsentry.Length), 2+0)
	_flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	if err := _flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	_flowstatsentry.DurationSec = uint32(decoder.ReadUint32())
	_flowstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	_flowstatsentry.Priority = uint16(decoder.ReadUint16())
	_flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	_flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	_flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	_flowstatsentry.PacketCount = uint64(decoder.ReadUint64())
	_flowstatsentry.ByteCount = uint64(decoder.ReadUint64())

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_flowstatsentry.Actions = append(_flowstatsentry.Actions, item)
	}
	return _flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	obj := &FlowStatsEntry{}
	return obj
}

type MatchV1 struct {
	Wildcards WcBmap
	InPort    PortNo
	EthSrc    net.HardwareAddr
	EthDst    net.HardwareAddr
	VlanVid   uint16
	VlanPcp   uint8
	EthType   uint16
	IpDscp    uint8
	IpProto   uint8
	Ipv4Src   net.IP
	Ipv4Dst   net.IP
	TcpSrc    uint16
	TcpDst    uint16
}

func (self *MatchV1) Serialize(encoder *goloxi.Encoder) error {
	self.Wildcards.Serialize(encoder)
	self.InPort.Serialize(encoder)
	encoder.Write(self.EthSrc)
	encoder.Write(self.EthDst)
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.PutUint8(uint8(self.VlanPcp))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.EthType))
	encoder.PutUint8(uint8(self.IpDscp))
	encoder.PutUint8(uint8(self.IpProto))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.Ipv4Src.To4())
	encoder.Write(self.Ipv4Dst.To4())
	encoder.PutUint16(uint16(self.TcpSrc))
	encoder.PutUint16(uint16(self.TcpDst))

	return nil
}
func (self *MatchV1) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 40 {
		return fmt.Errorf("MatchV1 packet too short: %d < 40", decoder.Length())
	}

	self.Wildcards.Decode(decoder)
	self.InPort.Decode(decoder)
	self.EthSrc = net.HardwareAddr(decoder.Read(6))
	self.EthDst = net.HardwareAddr(decoder.Read(6))
	self.VlanVid = uint16(decoder.ReadUint16())
	self.VlanPcp = uint8(decoder.ReadByte())
	decoder.Skip(1)
	self.EthType = uint16(decoder.ReadUint16())
	self.IpDscp = uint8(decoder.ReadByte())
	self.IpProto = uint8(decoder.ReadByte())
	decoder.Skip(2)
	self.Ipv4Src = net.IP(decoder.Read(4))
	self.Ipv4Dst = net.IP(decoder.Read(4))
	self.TcpSrc = uint16(decoder.ReadUint16())
	self.TcpDst = uint16(decoder.ReadUint16())

	return nil
}

func NewMatchV1() *MatchV1 {
	obj := &MatchV1{}
	return obj
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := DecodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	obj := &NiciraMatch{}
	return obj
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	_niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	_niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowstats.Length), 2+0)
	_niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	_niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	_niciraflowstats.Priority = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	_niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	_niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	_niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	_niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := _niciraflowstats.Match.Decode(decoder.SliceDecoder(int(_niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowstats.Actions = append(_niciraflowstats.Actions, item)
	}
	return _niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	obj := &NiciraFlowStats{}
	return obj
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func DecodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	_niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	_niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowupdateevent.Length), 2+0)
	_niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch _niciraflowupdateevent.Event {
	case 0:
		return DecodeNiciraFlowUpdateFullAdd(_niciraflowupdateevent, decoder)
	case 1:
		return DecodeNiciraFlowUpdateFullDeleted(_niciraflowupdateevent, decoder)
	case 2:
		return DecodeNiciraFlowUpdateFullModified(_niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", _niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	obj := &NiciraFlowUpdateEvent{}
	obj.Event = _event
	return obj
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	_niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulladd.Actions = append(_niciraflowupdatefulladd.Actions, item)
	}
	return _niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	obj := &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
	return obj
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	_niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulldeleted.Actions = append(_niciraflowupdatefulldeleted.Actions, item)
	}
	return _niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	obj := &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
	return obj
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	_niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefullmodified.Actions = append(_niciraflowupdatefullmodified.Actions, item)
	}
	return _niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	obj := &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
	return obj
}

type PacketQueue struct {
	QueueId    uint32
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	_packetqueue := &PacketQueue{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 8", decoder.Length())
	}
	_packetqueue.QueueId = uint32(decoder.ReadUint32())
	_packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_packetqueue.Len), 2+4)
	decoder.Skip(2)

	for decoder.Length() >= 8 {
		item, err := DecodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		_packetqueue.Properties = append(_packetqueue.Properties, item)
	}
	return _packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	obj := &PacketQueue{}
	return obj
}

type PortDesc struct {
	PortNo     PortNo
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Curr       PortFeatures
	Advertised PortFeatures
	Supported  PortFeatures
	Peer       PortFeatures
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(self.HwAddr)
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 48 {
		return fmt.Errorf("PortDesc packet too short: %d < 48", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())
	self.Curr = PortFeatures(decoder.ReadUint32())
	self.Advertised = PortFeatures(decoder.ReadUint32())
	self.Supported = PortFeatures(decoder.ReadUint32())
	self.Peer = PortFeatures(decoder.ReadUint32())

	return nil
}

func NewPortDesc() *PortDesc {
	obj := &PortDesc{}
	return obj
}

type PortStatsEntry struct {
	PortNo     PortNo
	RxPackets  uint64
	TxPackets  uint64
	RxBytes    uint64
	TxBytes    uint64
	RxDropped  uint64
	TxDropped  uint64
	RxErrors   uint64
	TxErrors   uint64
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	return nil
}

func DecodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	_portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 104 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 104", decoder.Length())
	}
	_portstatsentry.PortNo.Decode(decoder)
	decoder.Skip(6)
	_portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	_portstatsentry.TxErrors = uint64(decoder.ReadUint64())
	_portstatsentry.RxFrameErr = uint64(decoder.ReadUint64())
	_portstatsentry.RxOverErr = uint64(decoder.ReadUint64())
	_portstatsentry.RxCrcErr = uint64(decoder.ReadUint64())
	_portstatsentry.Collisions = uint64(decoder.ReadUint64())
	return _portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	obj := &PortStatsEntry{}
	return obj
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func DecodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	_queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	_queueprop.Type = uint16(decoder.ReadUint16())
	_queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queueprop.Len), 2+2)

	switch _queueprop.Type {
	case 1:
		return DecodeQueuePropMinRate(_queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", _queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	obj := &QueueProp{}
	obj.Type = _type
	return obj
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	_queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return _queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	obj := &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
	return obj
}

type QueueStatsEntry struct {
	PortNo    PortNo
	QueueId   uint32
	TxBytes   uint64
	TxPackets uint64
	TxErrors  uint64
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))

	return nil
}

func DecodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	_queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 32", decoder.Length())
	}
	_queuestatsentry.PortNo.Decode(decoder)
	decoder.Skip(2)
	_queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	_queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	_queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	_queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	return _queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	obj := &QueueStatsEntry{}
	return obj
}

type TableStatsEntry struct {
	TableId      uint8
	Name         string
	Wildcards    WcBmap
	MaxEntries   uint32
	ActiveCount  uint32
	LookupCount  uint64
	MatchedCount uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write([]byte(self.Name))
	self.Wildcards.Serialize(encoder)
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func DecodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	_tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 64", decoder.Length())
	}
	_tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	_tablestatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	_tablestatsentry.Wildcards.Decode(decoder)
	_tablestatsentry.MaxEntries = uint32(decoder.ReadUint32())
	_tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	_tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	_tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return _tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	obj := &TableStatsEntry{}
	return obj
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	obj := &EdPropHeader{}
	obj.PropClass = _prop_class
	return obj
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func DecodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	_edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	_edpropnsh.Type = uint8(decoder.ReadByte())
	_edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(_edpropnsh.Len), 1+3)

	switch _edpropnsh.Type {
	case 1:
		return DecodeEdPropNshMdType(_edpropnsh, decoder)
	case 2:
		return DecodeEdPropNshTlv(_edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", _edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	obj := &EdPropNsh{
		EdPropHeader: NewEdPropHeader(4),
	}
	obj.Type = _type
	return obj
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	_edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	_edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return _edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	obj := &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
	return obj
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	_edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	_edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	_edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	_edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return _edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	obj := &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
	return obj
}
