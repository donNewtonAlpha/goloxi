/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of10

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type Header struct {
	Version uint8
	Type    uint8
	Length  uint16
	Xid     uint32
}

type IHeader interface {
	goloxi.Serializable
	GetVersion() uint8
	GetType() uint8
	GetLength() uint16
	GetXid() uint32
}

func (self *Header) GetVersion() uint8 {
	return self.Version
}

func (self *Header) GetType() uint8 {
	return self.Type
}

func (self *Header) GetLength() uint16 {
	return self.Length
}

func (self *Header) GetXid() uint32 {
	return self.Xid
}

func (self *Header) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(1))
	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint32(uint32(self.Xid))

	return nil
}
func (self *Header) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 8 {
		return fmt.Errorf("Header packet too short: %d < 8", decoder.Length())
	}

	self.Version = uint8(decoder.ReadByte())
	// if self.Version != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", self.Version)
	// }
	self.Type = uint8(decoder.ReadByte())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)
	self.Xid = uint32(decoder.ReadUint32())

	return nil
}
func decodeHeader(decoder *goloxi.Decoder) (IHeader, error) {
	header := &Header{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Header packet too short: %d < 8", decoder.Length())
	}
	header.Version = uint8(decoder.ReadByte())
	// if header.Version != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", header.Version)
	// }
	header.Type = uint8(decoder.ReadByte())
	header.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(header.Length), 2+2)
	header.Xid = uint32(decoder.ReadUint32())

	switch header.Type {
	case 0:
		return decodeHello(header, decoder)
	case 1:
		return decodeErrorMsg(header, decoder)
	case 2:
		return decodeEchoRequest(header, decoder)
	case 3:
		return decodeEchoReply(header, decoder)
	case 4:
		return decodeExperimenter(header, decoder)
	case 5:
		return decodeFeaturesRequest(header, decoder)
	case 6:
		return decodeFeaturesReply(header, decoder)
	case 7:
		return decodeGetConfigRequest(header, decoder)
	case 8:
		return decodeGetConfigReply(header, decoder)
	case 9:
		return decodeSetConfig(header, decoder)
	case 10:
		return decodePacketIn(header, decoder)
	case 11:
		return decodeFlowRemoved(header, decoder)
	case 12:
		return decodePortStatus(header, decoder)
	case 13:
		return decodePacketOut(header, decoder)
	case 14:
		return decodeFlowMod(header, decoder)
	case 15:
		return decodePortMod(header, decoder)
	case 16:
		return decodeStatsRequest(header, decoder)
	case 17:
		return decodeStatsReply(header, decoder)
	case 18:
		return decodeBarrierRequest(header, decoder)
	case 19:
		return decodeBarrierReply(header, decoder)
	case 20:
		return decodeQueueGetConfigRequest(header, decoder)
	case 21:
		return decodeQueueGetConfigReply(header, decoder)
	case 22:
		return decodeTableMod(header, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Header'", header.Type)
	}
}

func NewHeader(_type uint8) *Header {
	return &Header{
		Type: _type,
	}
}

type StatsReply struct {
	*Header
	StatsType uint16
	Flags     StatsReplyFlags
}

type IStatsReply interface {
	IHeader
	GetStatsType() uint16
	GetFlags() StatsReplyFlags
}

func (self *StatsReply) GetStatsType() uint16 {
	return self.StatsType
}

func (self *StatsReply) GetFlags() StatsReplyFlags {
	return self.Flags
}

func (self *StatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.StatsType))
	encoder.PutUint16(uint16(self.Flags))

	return nil
}

func decodeStatsReply(parent *Header, decoder *goloxi.Decoder) (IStatsReply, error) {
	statsreply := &StatsReply{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("StatsReply packet too short: %d < 4", decoder.Length())
	}
	statsreply.StatsType = uint16(decoder.ReadUint16())
	statsreply.Flags = StatsReplyFlags(decoder.ReadUint16())

	switch statsreply.StatsType {
	case 0:
		return decodeDescStatsReply(statsreply, decoder)
	case 1:
		return decodeFlowStatsReply(statsreply, decoder)
	case 2:
		return decodeAggregateStatsReply(statsreply, decoder)
	case 3:
		return decodeTableStatsReply(statsreply, decoder)
	case 4:
		return decodePortStatsReply(statsreply, decoder)
	case 5:
		return decodeQueueStatsReply(statsreply, decoder)
	case 65535:
		return decodeExperimenterStatsReply(statsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'StatsReply'", statsreply.StatsType)
	}
}

func NewStatsReply(_stats_type uint16) *StatsReply {
	return &StatsReply{
		StatsType: _stats_type,
		Header:    NewHeader(17),
	}
}

type AggregateStatsReply struct {
	*StatsReply
	PacketCount uint64
	ByteCount   uint64
	FlowCount   uint32
}

func (self *AggregateStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	encoder.PutUint32(uint32(self.FlowCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAggregateStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*AggregateStatsReply, error) {
	aggregatestatsreply := &AggregateStatsReply{StatsReply: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("AggregateStatsReply packet too short: %d < 24", decoder.Length())
	}
	aggregatestatsreply.PacketCount = uint64(decoder.ReadUint64())
	aggregatestatsreply.ByteCount = uint64(decoder.ReadUint64())
	aggregatestatsreply.FlowCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return aggregatestatsreply, nil
}

func NewAggregateStatsReply() *AggregateStatsReply {
	return &AggregateStatsReply{
		StatsReply: NewStatsReply(2),
	}
}

type StatsRequest struct {
	*Header
	StatsType uint16
	Flags     StatsRequestFlags
}

type IStatsRequest interface {
	IHeader
	GetStatsType() uint16
	GetFlags() StatsRequestFlags
}

func (self *StatsRequest) GetStatsType() uint16 {
	return self.StatsType
}

func (self *StatsRequest) GetFlags() StatsRequestFlags {
	return self.Flags
}

func (self *StatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.StatsType))
	encoder.PutUint16(uint16(self.Flags))

	return nil
}

func decodeStatsRequest(parent *Header, decoder *goloxi.Decoder) (IStatsRequest, error) {
	statsrequest := &StatsRequest{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("StatsRequest packet too short: %d < 4", decoder.Length())
	}
	statsrequest.StatsType = uint16(decoder.ReadUint16())
	statsrequest.Flags = StatsRequestFlags(decoder.ReadUint16())

	switch statsrequest.StatsType {
	case 0:
		return decodeDescStatsRequest(statsrequest, decoder)
	case 1:
		return decodeFlowStatsRequest(statsrequest, decoder)
	case 2:
		return decodeAggregateStatsRequest(statsrequest, decoder)
	case 3:
		return decodeTableStatsRequest(statsrequest, decoder)
	case 4:
		return decodePortStatsRequest(statsrequest, decoder)
	case 5:
		return decodeQueueStatsRequest(statsrequest, decoder)
	case 65535:
		return decodeExperimenterStatsRequest(statsrequest, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'StatsRequest'", statsrequest.StatsType)
	}
}

func NewStatsRequest(_stats_type uint16) *StatsRequest {
	return &StatsRequest{
		StatsType: _stats_type,
		Header:    NewHeader(16),
	}
}

type AggregateStatsRequest struct {
	*StatsRequest
	Match   Match
	TableId uint8
	OutPort PortNo
}

func (self *AggregateStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	self.OutPort.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAggregateStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*AggregateStatsRequest, error) {
	aggregatestatsrequest := &AggregateStatsRequest{StatsRequest: parent}
	if decoder.Length() < 44 {
		return nil, fmt.Errorf("AggregateStatsRequest packet too short: %d < 44", decoder.Length())
	}
	if err := aggregatestatsrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	aggregatestatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	aggregatestatsrequest.OutPort.Decode(decoder)
	return aggregatestatsrequest, nil
}

func NewAggregateStatsRequest() *AggregateStatsRequest {
	return &AggregateStatsRequest{
		StatsRequest: NewStatsRequest(2),
	}
}

type ErrorMsg struct {
	*Header
	ErrType uint16
}

type IErrorMsg interface {
	IHeader
	GetErrType() uint16
}

func (self *ErrorMsg) GetErrType() uint16 {
	return self.ErrType
}

func (self *ErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.ErrType))

	return nil
}

func decodeErrorMsg(parent *Header, decoder *goloxi.Decoder) (IErrorMsg, error) {
	errormsg := &ErrorMsg{Header: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("ErrorMsg packet too short: %d < 2", decoder.Length())
	}
	errormsg.ErrType = uint16(decoder.ReadUint16())

	switch errormsg.ErrType {
	case 0:
		return decodeHelloFailedErrorMsg(errormsg, decoder)
	case 1:
		return decodeBadRequestErrorMsg(errormsg, decoder)
	case 2:
		return decodeBadActionErrorMsg(errormsg, decoder)
	case 3:
		return decodeFlowModFailedErrorMsg(errormsg, decoder)
	case 4:
		return decodePortModFailedErrorMsg(errormsg, decoder)
	case 5:
		return decodeQueueOpFailedErrorMsg(errormsg, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ErrorMsg'", errormsg.ErrType)
	}
}

func NewErrorMsg(_err_type uint16) *ErrorMsg {
	return &ErrorMsg{
		ErrType: _err_type,
		Header:  NewHeader(1),
	}
}

type BadActionErrorMsg struct {
	*ErrorMsg
	Code BadActionCode
	Data []byte
}

func (self *BadActionErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadActionErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadActionErrorMsg, error) {
	badactionerrormsg := &BadActionErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadActionErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badactionerrormsg.Code = BadActionCode(decoder.ReadUint16())
	badactionerrormsg.Data = decoder.Read(decoder.Length())
	return badactionerrormsg, nil
}

func NewBadActionErrorMsg() *BadActionErrorMsg {
	return &BadActionErrorMsg{
		ErrorMsg: NewErrorMsg(2),
	}
}

type BadRequestErrorMsg struct {
	*ErrorMsg
	Code BadRequestCode
	Data []byte
}

func (self *BadRequestErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadRequestErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadRequestErrorMsg, error) {
	badrequesterrormsg := &BadRequestErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadRequestErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badrequesterrormsg.Code = BadRequestCode(decoder.ReadUint16())
	badrequesterrormsg.Data = decoder.Read(decoder.Length())
	return badrequesterrormsg, nil
}

func NewBadRequestErrorMsg() *BadRequestErrorMsg {
	return &BadRequestErrorMsg{
		ErrorMsg: NewErrorMsg(1),
	}
}

type BarrierReply struct {
	*Header
}

func (self *BarrierReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBarrierReply(parent *Header, decoder *goloxi.Decoder) (*BarrierReply, error) {
	barrierreply := &BarrierReply{Header: parent}
	return barrierreply, nil
}

func NewBarrierReply() *BarrierReply {
	return &BarrierReply{
		Header: NewHeader(19),
	}
}

type BarrierRequest struct {
	*Header
}

func (self *BarrierRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBarrierRequest(parent *Header, decoder *goloxi.Decoder) (*BarrierRequest, error) {
	barrierrequest := &BarrierRequest{Header: parent}
	return barrierrequest, nil
}

func NewBarrierRequest() *BarrierRequest {
	return &BarrierRequest{
		Header: NewHeader(18),
	}
}

type Experimenter struct {
	*Header
	Experimenter uint32
}

type IExperimenter interface {
	IHeader
	GetExperimenter() uint32
}

func (self *Experimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *Experimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeExperimenter(parent *Header, decoder *goloxi.Decoder) (IExperimenter, error) {
	experimenter := &Experimenter{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Experimenter packet too short: %d < 4", decoder.Length())
	}
	experimenter.Experimenter = uint32(decoder.ReadUint32())

	switch experimenter.Experimenter {
	case 8992:
		return decodeNiciraHeader(experimenter, decoder)
	case 6035143:
		return decodeBsnHeader(experimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Experimenter'", experimenter.Experimenter)
	}
}

func NewExperimenter(_experimenter uint32) *Experimenter {
	return &Experimenter{
		Experimenter: _experimenter,
		Header:       NewHeader(4),
	}
}

type BsnHeader struct {
	*Experimenter
	Subtype uint32
}

type IBsnHeader interface {
	IExperimenter
	GetSubtype() uint32
}

func (self *BsnHeader) GetSubtype() uint32 {
	return self.Subtype
}

func (self *BsnHeader) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Experimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeBsnHeader(parent *Experimenter, decoder *goloxi.Decoder) (IBsnHeader, error) {
	bsnheader := &BsnHeader{Experimenter: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnHeader packet too short: %d < 4", decoder.Length())
	}
	bsnheader.Subtype = uint32(decoder.ReadUint32())

	switch bsnheader.Subtype {
	case 0:
		return decodeBsnSetIpMask(bsnheader, decoder)
	case 1:
		return decodeBsnGetIpMaskRequest(bsnheader, decoder)
	case 2:
		return decodeBsnGetIpMaskReply(bsnheader, decoder)
	case 3:
		return decodeBsnSetMirroring(bsnheader, decoder)
	case 4:
		return decodeBsnGetMirroringRequest(bsnheader, decoder)
	case 5:
		return decodeBsnGetMirroringReply(bsnheader, decoder)
	case 6:
		return decodeBsnShellCommand(bsnheader, decoder)
	case 7:
		return decodeBsnShellOutput(bsnheader, decoder)
	case 8:
		return decodeBsnShellStatus(bsnheader, decoder)
	case 9:
		return decodeBsnGetInterfacesRequest(bsnheader, decoder)
	case 10:
		return decodeBsnGetInterfacesReply(bsnheader, decoder)
	case 11:
		return decodeBsnSetPktinSuppressionRequest(bsnheader, decoder)
	case 12:
		return decodeBsnSetL2TableRequest(bsnheader, decoder)
	case 13:
		return decodeBsnGetL2TableRequest(bsnheader, decoder)
	case 14:
		return decodeBsnGetL2TableReply(bsnheader, decoder)
	case 15:
		return decodeBsnVirtualPortCreateRequest(bsnheader, decoder)
	case 16:
		return decodeBsnVirtualPortCreateReply(bsnheader, decoder)
	case 17:
		return decodeBsnVirtualPortRemoveRequest(bsnheader, decoder)
	case 18:
		return decodeBsnBwEnableSetRequest(bsnheader, decoder)
	case 19:
		return decodeBsnBwEnableGetRequest(bsnheader, decoder)
	case 20:
		return decodeBsnBwEnableGetReply(bsnheader, decoder)
	case 21:
		return decodeBsnBwClearDataRequest(bsnheader, decoder)
	case 22:
		return decodeBsnBwClearDataReply(bsnheader, decoder)
	case 23:
		return decodeBsnBwEnableSetReply(bsnheader, decoder)
	case 24:
		return decodeBsnSetL2TableReply(bsnheader, decoder)
	case 25:
		return decodeBsnSetPktinSuppressionReply(bsnheader, decoder)
	case 26:
		return decodeBsnVirtualPortRemoveReply(bsnheader, decoder)
	case 27:
		return decodeBsnHybridGetRequest(bsnheader, decoder)
	case 28:
		return decodeBsnHybridGetReply(bsnheader, decoder)
	case 31:
		return decodeBsnPduTxRequest(bsnheader, decoder)
	case 32:
		return decodeBsnPduTxReply(bsnheader, decoder)
	case 33:
		return decodeBsnPduRxRequest(bsnheader, decoder)
	case 34:
		return decodeBsnPduRxReply(bsnheader, decoder)
	case 35:
		return decodeBsnPduRxTimeout(bsnheader, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnHeader'", bsnheader.Subtype)
	}
}

func NewBsnHeader(_subtype uint32) *BsnHeader {
	return &BsnHeader{
		Subtype:      _subtype,
		Experimenter: NewExperimenter(6035143),
	}
}

type BsnBwClearDataReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnBwClearDataReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwClearDataReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwClearDataReply, error) {
	bsnbwcleardatareply := &BsnBwClearDataReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwClearDataReply packet too short: %d < 4", decoder.Length())
	}
	bsnbwcleardatareply.Status = uint32(decoder.ReadUint32())
	return bsnbwcleardatareply, nil
}

func NewBsnBwClearDataReply() *BsnBwClearDataReply {
	return &BsnBwClearDataReply{
		BsnHeader: NewBsnHeader(22),
	}
}

type BsnBwClearDataRequest struct {
	*BsnHeader
}

func (self *BsnBwClearDataRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwClearDataRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwClearDataRequest, error) {
	bsnbwcleardatarequest := &BsnBwClearDataRequest{BsnHeader: parent}
	return bsnbwcleardatarequest, nil
}

func NewBsnBwClearDataRequest() *BsnBwClearDataRequest {
	return &BsnBwClearDataRequest{
		BsnHeader: NewBsnHeader(21),
	}
}

type BsnBwEnableGetReply struct {
	*BsnHeader
	Enabled uint32
}

func (self *BsnBwEnableGetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enabled))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableGetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableGetReply, error) {
	bsnbwenablegetreply := &BsnBwEnableGetReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwEnableGetReply packet too short: %d < 4", decoder.Length())
	}
	bsnbwenablegetreply.Enabled = uint32(decoder.ReadUint32())
	return bsnbwenablegetreply, nil
}

func NewBsnBwEnableGetReply() *BsnBwEnableGetReply {
	return &BsnBwEnableGetReply{
		BsnHeader: NewBsnHeader(20),
	}
}

type BsnBwEnableGetRequest struct {
	*BsnHeader
}

func (self *BsnBwEnableGetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableGetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableGetRequest, error) {
	bsnbwenablegetrequest := &BsnBwEnableGetRequest{BsnHeader: parent}
	return bsnbwenablegetrequest, nil
}

func NewBsnBwEnableGetRequest() *BsnBwEnableGetRequest {
	return &BsnBwEnableGetRequest{
		BsnHeader: NewBsnHeader(19),
	}
}

type BsnBwEnableSetReply struct {
	*BsnHeader
	Enable uint32
	Status uint32
}

func (self *BsnBwEnableSetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))
	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableSetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableSetReply, error) {
	bsnbwenablesetreply := &BsnBwEnableSetReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnBwEnableSetReply packet too short: %d < 8", decoder.Length())
	}
	bsnbwenablesetreply.Enable = uint32(decoder.ReadUint32())
	bsnbwenablesetreply.Status = uint32(decoder.ReadUint32())
	return bsnbwenablesetreply, nil
}

func NewBsnBwEnableSetReply() *BsnBwEnableSetReply {
	return &BsnBwEnableSetReply{
		BsnHeader: NewBsnHeader(23),
	}
}

type BsnBwEnableSetRequest struct {
	*BsnHeader
	Enable uint32
}

func (self *BsnBwEnableSetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableSetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableSetRequest, error) {
	bsnbwenablesetrequest := &BsnBwEnableSetRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwEnableSetRequest packet too short: %d < 4", decoder.Length())
	}
	bsnbwenablesetrequest.Enable = uint32(decoder.ReadUint32())
	return bsnbwenablesetrequest, nil
}

func NewBsnBwEnableSetRequest() *BsnBwEnableSetRequest {
	return &BsnBwEnableSetRequest{
		BsnHeader: NewBsnHeader(18),
	}
}

type BsnGetInterfacesReply struct {
	*BsnHeader
	Interfaces []*BsnInterface
}

func (self *BsnGetInterfacesReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Interfaces {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetInterfacesReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetInterfacesReply, error) {
	bsngetinterfacesreply := &BsnGetInterfacesReply{BsnHeader: parent}

	for decoder.Length() >= 32 {
		item, err := decodeBsnInterface(decoder)
		if err != nil {
			return nil, err
		}
		bsngetinterfacesreply.Interfaces = append(bsngetinterfacesreply.Interfaces, item)
	}
	return bsngetinterfacesreply, nil
}

func NewBsnGetInterfacesReply() *BsnGetInterfacesReply {
	return &BsnGetInterfacesReply{
		BsnHeader: NewBsnHeader(10),
	}
}

type BsnGetInterfacesRequest struct {
	*BsnHeader
}

func (self *BsnGetInterfacesRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetInterfacesRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetInterfacesRequest, error) {
	bsngetinterfacesrequest := &BsnGetInterfacesRequest{BsnHeader: parent}
	return bsngetinterfacesrequest, nil
}

func NewBsnGetInterfacesRequest() *BsnGetInterfacesRequest {
	return &BsnGetInterfacesRequest{
		BsnHeader: NewBsnHeader(9),
	}
}

type BsnGetIpMaskReply struct {
	*BsnHeader
	Index uint8
	Mask  uint32
}

func (self *BsnGetIpMaskReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Index))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetIpMaskReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetIpMaskReply, error) {
	bsngetipmaskreply := &BsnGetIpMaskReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnGetIpMaskReply packet too short: %d < 8", decoder.Length())
	}
	bsngetipmaskreply.Index = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsngetipmaskreply.Mask = uint32(decoder.ReadUint32())
	return bsngetipmaskreply, nil
}

func NewBsnGetIpMaskReply() *BsnGetIpMaskReply {
	return &BsnGetIpMaskReply{
		BsnHeader: NewBsnHeader(2),
	}
}

type BsnGetIpMaskRequest struct {
	*BsnHeader
	Index uint8
}

func (self *BsnGetIpMaskRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Index))
	encoder.Write(bytes.Repeat([]byte{0}, 7))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetIpMaskRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetIpMaskRequest, error) {
	bsngetipmaskrequest := &BsnGetIpMaskRequest{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnGetIpMaskRequest packet too short: %d < 8", decoder.Length())
	}
	bsngetipmaskrequest.Index = uint8(decoder.ReadByte())
	decoder.Skip(7)
	return bsngetipmaskrequest, nil
}

func NewBsnGetIpMaskRequest() *BsnGetIpMaskRequest {
	return &BsnGetIpMaskRequest{
		BsnHeader: NewBsnHeader(1),
	}
}

type BsnGetL2TableReply struct {
	*BsnHeader
	L2TableEnable   uint8
	L2TablePriority uint16
}

func (self *BsnGetL2TableReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.L2TableEnable))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.L2TablePriority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetL2TableReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetL2TableReply, error) {
	bsngetl2tablereply := &BsnGetL2TableReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnGetL2TableReply packet too short: %d < 8", decoder.Length())
	}
	bsngetl2tablereply.L2TableEnable = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsngetl2tablereply.L2TablePriority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	return bsngetl2tablereply, nil
}

func NewBsnGetL2TableReply() *BsnGetL2TableReply {
	return &BsnGetL2TableReply{
		BsnHeader: NewBsnHeader(14),
	}
}

type BsnGetL2TableRequest struct {
	*BsnHeader
}

func (self *BsnGetL2TableRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetL2TableRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetL2TableRequest, error) {
	bsngetl2tablerequest := &BsnGetL2TableRequest{BsnHeader: parent}
	return bsngetl2tablerequest, nil
}

func NewBsnGetL2TableRequest() *BsnGetL2TableRequest {
	return &BsnGetL2TableRequest{
		BsnHeader: NewBsnHeader(13),
	}
}

type BsnGetMirroringReply struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnGetMirroringReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetMirroringReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetMirroringReply, error) {
	bsngetmirroringreply := &BsnGetMirroringReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGetMirroringReply packet too short: %d < 4", decoder.Length())
	}
	bsngetmirroringreply.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsngetmirroringreply, nil
}

func NewBsnGetMirroringReply() *BsnGetMirroringReply {
	return &BsnGetMirroringReply{
		BsnHeader: NewBsnHeader(5),
	}
}

type BsnGetMirroringRequest struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnGetMirroringRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetMirroringRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetMirroringRequest, error) {
	bsngetmirroringrequest := &BsnGetMirroringRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGetMirroringRequest packet too short: %d < 4", decoder.Length())
	}
	bsngetmirroringrequest.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsngetmirroringrequest, nil
}

func NewBsnGetMirroringRequest() *BsnGetMirroringRequest {
	return &BsnGetMirroringRequest{
		BsnHeader: NewBsnHeader(4),
	}
}

type BsnHybridGetReply struct {
	*BsnHeader
	HybridEnable  uint8
	HybridVersion uint16
}

func (self *BsnHybridGetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.HybridEnable))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.HybridVersion))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnHybridGetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnHybridGetReply, error) {
	bsnhybridgetreply := &BsnHybridGetReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnHybridGetReply packet too short: %d < 8", decoder.Length())
	}
	bsnhybridgetreply.HybridEnable = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnhybridgetreply.HybridVersion = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	return bsnhybridgetreply, nil
}

func NewBsnHybridGetReply() *BsnHybridGetReply {
	return &BsnHybridGetReply{
		BsnHeader: NewBsnHeader(28),
	}
}

type BsnHybridGetRequest struct {
	*BsnHeader
}

func (self *BsnHybridGetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnHybridGetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnHybridGetRequest, error) {
	bsnhybridgetrequest := &BsnHybridGetRequest{BsnHeader: parent}
	return bsnhybridgetrequest, nil
}

func NewBsnHybridGetRequest() *BsnHybridGetRequest {
	return &BsnHybridGetRequest{
		BsnHeader: NewBsnHeader(27),
	}
}

type BsnPduRxReply struct {
	*BsnHeader
	Status  uint32
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduRxReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxReply, error) {
	bsnpdurxreply := &BsnPduRxReply{BsnHeader: parent}
	if decoder.Length() < 7 {
		return nil, fmt.Errorf("BsnPduRxReply packet too short: %d < 7", decoder.Length())
	}
	bsnpdurxreply.Status = uint32(decoder.ReadUint32())
	bsnpdurxreply.PortNo.Decode(decoder)
	bsnpdurxreply.SlotNum = uint8(decoder.ReadByte())
	return bsnpdurxreply, nil
}

func NewBsnPduRxReply() *BsnPduRxReply {
	return &BsnPduRxReply{
		BsnHeader: NewBsnHeader(34),
	}
}

type BsnPduRxRequest struct {
	*BsnHeader
	TimeoutMs uint32
	PortNo    PortNo
	SlotNum   uint8
	Data      []byte
}

func (self *BsnPduRxRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.TimeoutMs))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxRequest, error) {
	bsnpdurxrequest := &BsnPduRxRequest{BsnHeader: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("BsnPduRxRequest packet too short: %d < 10", decoder.Length())
	}
	bsnpdurxrequest.TimeoutMs = uint32(decoder.ReadUint32())
	bsnpdurxrequest.PortNo.Decode(decoder)
	bsnpdurxrequest.SlotNum = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnpdurxrequest.Data = decoder.Read(decoder.Length())
	return bsnpdurxrequest, nil
}

func NewBsnPduRxRequest() *BsnPduRxRequest {
	return &BsnPduRxRequest{
		BsnHeader: NewBsnHeader(33),
	}
}

type BsnPduRxTimeout struct {
	*BsnHeader
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduRxTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxTimeout(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxTimeout, error) {
	bsnpdurxtimeout := &BsnPduRxTimeout{BsnHeader: parent}
	if decoder.Length() < 3 {
		return nil, fmt.Errorf("BsnPduRxTimeout packet too short: %d < 3", decoder.Length())
	}
	bsnpdurxtimeout.PortNo.Decode(decoder)
	bsnpdurxtimeout.SlotNum = uint8(decoder.ReadByte())
	return bsnpdurxtimeout, nil
}

func NewBsnPduRxTimeout() *BsnPduRxTimeout {
	return &BsnPduRxTimeout{
		BsnHeader: NewBsnHeader(35),
	}
}

type BsnPduTxReply struct {
	*BsnHeader
	Status  uint32
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduTxReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduTxReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduTxReply, error) {
	bsnpdutxreply := &BsnPduTxReply{BsnHeader: parent}
	if decoder.Length() < 7 {
		return nil, fmt.Errorf("BsnPduTxReply packet too short: %d < 7", decoder.Length())
	}
	bsnpdutxreply.Status = uint32(decoder.ReadUint32())
	bsnpdutxreply.PortNo.Decode(decoder)
	bsnpdutxreply.SlotNum = uint8(decoder.ReadByte())
	return bsnpdutxreply, nil
}

func NewBsnPduTxReply() *BsnPduTxReply {
	return &BsnPduTxReply{
		BsnHeader: NewBsnHeader(32),
	}
}

type BsnPduTxRequest struct {
	*BsnHeader
	TxIntervalMs uint32
	PortNo       PortNo
	SlotNum      uint8
	Data         []byte
}

func (self *BsnPduTxRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.TxIntervalMs))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduTxRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduTxRequest, error) {
	bsnpdutxrequest := &BsnPduTxRequest{BsnHeader: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("BsnPduTxRequest packet too short: %d < 10", decoder.Length())
	}
	bsnpdutxrequest.TxIntervalMs = uint32(decoder.ReadUint32())
	bsnpdutxrequest.PortNo.Decode(decoder)
	bsnpdutxrequest.SlotNum = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnpdutxrequest.Data = decoder.Read(decoder.Length())
	return bsnpdutxrequest, nil
}

func NewBsnPduTxRequest() *BsnPduTxRequest {
	return &BsnPduTxRequest{
		BsnHeader: NewBsnHeader(31),
	}
}

type BsnSetIpMask struct {
	*BsnHeader
	Index uint8
	Mask  uint32
}

func (self *BsnSetIpMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Index))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetIpMask(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetIpMask, error) {
	bsnsetipmask := &BsnSetIpMask{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnSetIpMask packet too short: %d < 8", decoder.Length())
	}
	bsnsetipmask.Index = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnsetipmask.Mask = uint32(decoder.ReadUint32())
	return bsnsetipmask, nil
}

func NewBsnSetIpMask() *BsnSetIpMask {
	return &BsnSetIpMask{
		BsnHeader: NewBsnHeader(0),
	}
}

type BsnSetL2TableReply struct {
	*BsnHeader
	L2TableEnable   uint8
	L2TablePriority uint16
	Status          uint32
}

func (self *BsnSetL2TableReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.L2TableEnable))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.L2TablePriority))
	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetL2TableReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetL2TableReply, error) {
	bsnsetl2tablereply := &BsnSetL2TableReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnSetL2TableReply packet too short: %d < 8", decoder.Length())
	}
	bsnsetl2tablereply.L2TableEnable = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnsetl2tablereply.L2TablePriority = uint16(decoder.ReadUint16())
	bsnsetl2tablereply.Status = uint32(decoder.ReadUint32())
	return bsnsetl2tablereply, nil
}

func NewBsnSetL2TableReply() *BsnSetL2TableReply {
	return &BsnSetL2TableReply{
		BsnHeader: NewBsnHeader(24),
	}
}

type BsnSetL2TableRequest struct {
	*BsnHeader
	L2TableEnable   uint8
	L2TablePriority uint16
}

func (self *BsnSetL2TableRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.L2TableEnable))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.L2TablePriority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetL2TableRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetL2TableRequest, error) {
	bsnsetl2tablerequest := &BsnSetL2TableRequest{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnSetL2TableRequest packet too short: %d < 8", decoder.Length())
	}
	bsnsetl2tablerequest.L2TableEnable = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnsetl2tablerequest.L2TablePriority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	return bsnsetl2tablerequest, nil
}

func NewBsnSetL2TableRequest() *BsnSetL2TableRequest {
	return &BsnSetL2TableRequest{
		BsnHeader: NewBsnHeader(12),
	}
}

type BsnSetMirroring struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnSetMirroring) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetMirroring(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetMirroring, error) {
	bsnsetmirroring := &BsnSetMirroring{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetMirroring packet too short: %d < 4", decoder.Length())
	}
	bsnsetmirroring.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsnsetmirroring, nil
}

func NewBsnSetMirroring() *BsnSetMirroring {
	return &BsnSetMirroring{
		BsnHeader: NewBsnHeader(3),
	}
}

type BsnSetPktinSuppressionReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnSetPktinSuppressionReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetPktinSuppressionReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetPktinSuppressionReply, error) {
	bsnsetpktinsuppressionreply := &BsnSetPktinSuppressionReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetPktinSuppressionReply packet too short: %d < 4", decoder.Length())
	}
	bsnsetpktinsuppressionreply.Status = uint32(decoder.ReadUint32())
	return bsnsetpktinsuppressionreply, nil
}

func NewBsnSetPktinSuppressionReply() *BsnSetPktinSuppressionReply {
	return &BsnSetPktinSuppressionReply{
		BsnHeader: NewBsnHeader(25),
	}
}

type BsnSetPktinSuppressionRequest struct {
	*BsnHeader
	Enabled     uint8
	IdleTimeout uint16
	HardTimeout uint16
	Priority    uint16
	Cookie      uint64
}

func (self *BsnSetPktinSuppressionRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Enabled))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint64(uint64(self.Cookie))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetPktinSuppressionRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetPktinSuppressionRequest, error) {
	bsnsetpktinsuppressionrequest := &BsnSetPktinSuppressionRequest{BsnHeader: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnSetPktinSuppressionRequest packet too short: %d < 16", decoder.Length())
	}
	bsnsetpktinsuppressionrequest.Enabled = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnsetpktinsuppressionrequest.IdleTimeout = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.HardTimeout = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.Priority = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.Cookie = uint64(decoder.ReadUint64())
	return bsnsetpktinsuppressionrequest, nil
}

func NewBsnSetPktinSuppressionRequest() *BsnSetPktinSuppressionRequest {
	return &BsnSetPktinSuppressionRequest{
		BsnHeader: NewBsnHeader(11),
	}
}

type BsnShellCommand struct {
	*BsnHeader
	Service uint32
	Data    []byte
}

func (self *BsnShellCommand) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Service))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnShellCommand(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnShellCommand, error) {
	bsnshellcommand := &BsnShellCommand{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnShellCommand packet too short: %d < 4", decoder.Length())
	}
	bsnshellcommand.Service = uint32(decoder.ReadUint32())
	bsnshellcommand.Data = decoder.Read(decoder.Length())
	return bsnshellcommand, nil
}

func NewBsnShellCommand() *BsnShellCommand {
	return &BsnShellCommand{
		BsnHeader: NewBsnHeader(6),
	}
}

type BsnShellOutput struct {
	*BsnHeader
	Data []byte
}

func (self *BsnShellOutput) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnShellOutput(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnShellOutput, error) {
	bsnshelloutput := &BsnShellOutput{BsnHeader: parent}
	bsnshelloutput.Data = decoder.Read(decoder.Length())
	return bsnshelloutput, nil
}

func NewBsnShellOutput() *BsnShellOutput {
	return &BsnShellOutput{
		BsnHeader: NewBsnHeader(7),
	}
}

type BsnShellStatus struct {
	*BsnHeader
	Status uint32
}

func (self *BsnShellStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnShellStatus(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnShellStatus, error) {
	bsnshellstatus := &BsnShellStatus{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnShellStatus packet too short: %d < 4", decoder.Length())
	}
	bsnshellstatus.Status = uint32(decoder.ReadUint32())
	return bsnshellstatus, nil
}

func NewBsnShellStatus() *BsnShellStatus {
	return &BsnShellStatus{
		BsnHeader: NewBsnHeader(8),
	}
}

type ExperimenterStatsReply struct {
	*StatsReply
	Experimenter uint32
}

type IExperimenterStatsReply interface {
	IStatsReply
	GetExperimenter() uint32
}

func (self *ExperimenterStatsReply) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ExperimenterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeExperimenterStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (IExperimenterStatsReply, error) {
	experimenterstatsreply := &ExperimenterStatsReply{StatsReply: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("ExperimenterStatsReply packet too short: %d < 4", decoder.Length())
	}
	experimenterstatsreply.Experimenter = uint32(decoder.ReadUint32())

	switch experimenterstatsreply.Experimenter {
	case 8992:
		return decodeNiciraStatsReply(experimenterstatsreply, decoder)
	case 6035143:
		return decodeBsnStatsReply(experimenterstatsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ExperimenterStatsReply'", experimenterstatsreply.Experimenter)
	}
}

func NewExperimenterStatsReply(_experimenter uint32) *ExperimenterStatsReply {
	return &ExperimenterStatsReply{
		Experimenter: _experimenter,
		StatsReply:   NewStatsReply(65535),
	}
}

type BsnStatsReply struct {
	*ExperimenterStatsReply
	Subtype uint32
}

type IBsnStatsReply interface {
	IExperimenterStatsReply
	GetSubtype() uint32
}

func (self *BsnStatsReply) GetSubtype() uint32 {
	return self.Subtype
}

func (self *BsnStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeBsnStatsReply(parent *ExperimenterStatsReply, decoder *goloxi.Decoder) (IBsnStatsReply, error) {
	bsnstatsreply := &BsnStatsReply{ExperimenterStatsReply: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnStatsReply packet too short: %d < 4", decoder.Length())
	}
	decoder.Skip(4)
	bsnstatsreply.Subtype = uint32(decoder.ReadUint32())
	return bsnstatsreply, nil
}

func NewBsnStatsReply(_subtype uint32) *BsnStatsReply {
	return &BsnStatsReply{
		Subtype:                _subtype,
		ExperimenterStatsReply: NewExperimenterStatsReply(6035143),
	}
}

type ExperimenterStatsRequest struct {
	*StatsRequest
	Experimenter uint32
}

type IExperimenterStatsRequest interface {
	IStatsRequest
	GetExperimenter() uint32
}

func (self *ExperimenterStatsRequest) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ExperimenterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeExperimenterStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (IExperimenterStatsRequest, error) {
	experimenterstatsrequest := &ExperimenterStatsRequest{StatsRequest: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("ExperimenterStatsRequest packet too short: %d < 4", decoder.Length())
	}
	experimenterstatsrequest.Experimenter = uint32(decoder.ReadUint32())

	switch experimenterstatsrequest.Experimenter {
	case 8992:
		return decodeNiciraFlowStatsRequest(experimenterstatsrequest, decoder)
	case 6035143:
		return decodeBsnStatsRequest(experimenterstatsrequest, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ExperimenterStatsRequest'", experimenterstatsrequest.Experimenter)
	}
}

func NewExperimenterStatsRequest(_experimenter uint32) *ExperimenterStatsRequest {
	return &ExperimenterStatsRequest{
		Experimenter: _experimenter,
		StatsRequest: NewStatsRequest(65535),
	}
}

type BsnStatsRequest struct {
	*ExperimenterStatsRequest
	Subtype uint32
}

type IBsnStatsRequest interface {
	IExperimenterStatsRequest
	GetSubtype() uint32
}

func (self *BsnStatsRequest) GetSubtype() uint32 {
	return self.Subtype
}

func (self *BsnStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeBsnStatsRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (IBsnStatsRequest, error) {
	bsnstatsrequest := &BsnStatsRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnStatsRequest packet too short: %d < 4", decoder.Length())
	}
	decoder.Skip(4)
	bsnstatsrequest.Subtype = uint32(decoder.ReadUint32())
	return bsnstatsrequest, nil
}

func NewBsnStatsRequest(_subtype uint32) *BsnStatsRequest {
	return &BsnStatsRequest{
		Subtype:                  _subtype,
		ExperimenterStatsRequest: NewExperimenterStatsRequest(6035143),
	}
}

type BsnVirtualPortCreateReply struct {
	*BsnHeader
	Status  uint32
	VportNo uint32
}

func (self *BsnVirtualPortCreateReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	encoder.PutUint32(uint32(self.VportNo))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortCreateReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortCreateReply, error) {
	bsnvirtualportcreatereply := &BsnVirtualPortCreateReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVirtualPortCreateReply packet too short: %d < 8", decoder.Length())
	}
	bsnvirtualportcreatereply.Status = uint32(decoder.ReadUint32())
	bsnvirtualportcreatereply.VportNo = uint32(decoder.ReadUint32())
	return bsnvirtualportcreatereply, nil
}

func NewBsnVirtualPortCreateReply() *BsnVirtualPortCreateReply {
	return &BsnVirtualPortCreateReply{
		BsnHeader: NewBsnHeader(16),
	}
}

type BsnVirtualPortCreateRequest struct {
	*BsnHeader
	Vport BSNVport
}

func (self *BsnVirtualPortCreateRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Vport.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortCreateRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortCreateRequest, error) {
	bsnvirtualportcreaterequest := &BsnVirtualPortCreateRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortCreateRequest packet too short: %d < 4", decoder.Length())
	}
	if err := bsnvirtualportcreaterequest.Vport.Decode(decoder); err != nil {
		return nil, err
	}

	return bsnvirtualportcreaterequest, nil
}

func NewBsnVirtualPortCreateRequest() *BsnVirtualPortCreateRequest {
	return &BsnVirtualPortCreateRequest{
		BsnHeader: NewBsnHeader(15),
	}
}

type BsnVirtualPortRemoveReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnVirtualPortRemoveReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortRemoveReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortRemoveReply, error) {
	bsnvirtualportremovereply := &BsnVirtualPortRemoveReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortRemoveReply packet too short: %d < 4", decoder.Length())
	}
	bsnvirtualportremovereply.Status = uint32(decoder.ReadUint32())
	return bsnvirtualportremovereply, nil
}

func NewBsnVirtualPortRemoveReply() *BsnVirtualPortRemoveReply {
	return &BsnVirtualPortRemoveReply{
		BsnHeader: NewBsnHeader(26),
	}
}

type BsnVirtualPortRemoveRequest struct {
	*BsnHeader
	VportNo uint32
}

func (self *BsnVirtualPortRemoveRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.VportNo))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortRemoveRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortRemoveRequest, error) {
	bsnvirtualportremoverequest := &BsnVirtualPortRemoveRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortRemoveRequest packet too short: %d < 4", decoder.Length())
	}
	bsnvirtualportremoverequest.VportNo = uint32(decoder.ReadUint32())
	return bsnvirtualportremoverequest, nil
}

func NewBsnVirtualPortRemoveRequest() *BsnVirtualPortRemoveRequest {
	return &BsnVirtualPortRemoveRequest{
		BsnHeader: NewBsnHeader(17),
	}
}

type DescStatsReply struct {
	*StatsReply
	MfrDesc   string
	HwDesc    string
	SwDesc    string
	SerialNum string
	DpDesc    string
}

func (self *DescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.MfrDesc))
	encoder.Write([]byte(self.HwDesc))
	encoder.Write([]byte(self.SwDesc))
	encoder.Write([]byte(self.SerialNum))
	encoder.Write([]byte(self.DpDesc))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*DescStatsReply, error) {
	descstatsreply := &DescStatsReply{StatsReply: parent}
	if decoder.Length() < 1056 {
		return nil, fmt.Errorf("DescStatsReply packet too short: %d < 1056", decoder.Length())
	}
	descstatsreply.MfrDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.HwDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.SwDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.SerialNum = string(bytes.Trim(decoder.Read(32), "\x00"))
	descstatsreply.DpDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	return descstatsreply, nil
}

func NewDescStatsReply() *DescStatsReply {
	return &DescStatsReply{
		StatsReply: NewStatsReply(0),
	}
}

type DescStatsRequest struct {
	*StatsRequest
}

func (self *DescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*DescStatsRequest, error) {
	descstatsrequest := &DescStatsRequest{StatsRequest: parent}
	return descstatsrequest, nil
}

func NewDescStatsRequest() *DescStatsRequest {
	return &DescStatsRequest{
		StatsRequest: NewStatsRequest(0),
	}
}

type EchoReply struct {
	*Header
	Data []byte
}

func (self *EchoReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeEchoReply(parent *Header, decoder *goloxi.Decoder) (*EchoReply, error) {
	echoreply := &EchoReply{Header: parent}
	echoreply.Data = decoder.Read(decoder.Length())
	return echoreply, nil
}

func NewEchoReply() *EchoReply {
	return &EchoReply{
		Header: NewHeader(3),
	}
}

type EchoRequest struct {
	*Header
	Data []byte
}

func (self *EchoRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeEchoRequest(parent *Header, decoder *goloxi.Decoder) (*EchoRequest, error) {
	echorequest := &EchoRequest{Header: parent}
	echorequest.Data = decoder.Read(decoder.Length())
	return echorequest, nil
}

func NewEchoRequest() *EchoRequest {
	return &EchoRequest{
		Header: NewHeader(2),
	}
}

type FeaturesReply struct {
	*Header
	DatapathId   uint64
	NBuffers     uint32
	NTables      uint8
	Capabilities Capabilities
	Actions      uint32
	Ports        []*PortDesc
}

func (self *FeaturesReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.DatapathId))
	encoder.PutUint32(uint32(self.NBuffers))
	encoder.PutUint8(uint8(self.NTables))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint32(uint32(self.Actions))
	for _, obj := range self.Ports {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFeaturesReply(parent *Header, decoder *goloxi.Decoder) (*FeaturesReply, error) {
	featuresreply := &FeaturesReply{Header: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("FeaturesReply packet too short: %d < 24", decoder.Length())
	}
	featuresreply.DatapathId = uint64(decoder.ReadUint64())
	featuresreply.NBuffers = uint32(decoder.ReadUint32())
	featuresreply.NTables = uint8(decoder.ReadByte())
	decoder.Skip(3)
	featuresreply.Capabilities = Capabilities(decoder.ReadUint32())
	featuresreply.Actions = uint32(decoder.ReadUint32())

	for decoder.Length() >= 48 {
		item := &PortDesc{}
		if err := item.Decode(decoder); err != nil {
			return nil, err
		}
		featuresreply.Ports = append(featuresreply.Ports, item)
	}
	return featuresreply, nil
}

func NewFeaturesReply() *FeaturesReply {
	return &FeaturesReply{
		Header: NewHeader(6),
	}
}

type FeaturesRequest struct {
	*Header
}

func (self *FeaturesRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFeaturesRequest(parent *Header, decoder *goloxi.Decoder) (*FeaturesRequest, error) {
	featuresrequest := &FeaturesRequest{Header: parent}
	return featuresrequest, nil
}

func NewFeaturesRequest() *FeaturesRequest {
	return &FeaturesRequest{
		Header: NewHeader(5),
	}
}

type FlowMod struct {
	*Header
	Match       Match
	Cookie      uint64
	Command     FmCmd
	IdleTimeout uint16
	HardTimeout uint16
	Priority    uint16
	BufferId    uint32
	OutPort     PortNo
	Flags       FlowModFlags
	Actions     []IAction
}

type IFlowMod interface {
	IHeader
	GetMatch() Match
	GetCookie() uint64
	GetCommand() FmCmd
	GetIdleTimeout() uint16
	GetHardTimeout() uint16
	GetPriority() uint16
	GetBufferId() uint32
	GetOutPort() PortNo
	GetFlags() FlowModFlags
	GetActions() []IAction
}

func (self *FlowMod) GetMatch() Match {
	return self.Match
}

func (self *FlowMod) GetCookie() uint64 {
	return self.Cookie
}

func (self *FlowMod) GetCommand() FmCmd {
	return self.Command
}

func (self *FlowMod) GetIdleTimeout() uint16 {
	return self.IdleTimeout
}

func (self *FlowMod) GetHardTimeout() uint16 {
	return self.HardTimeout
}

func (self *FlowMod) GetPriority() uint16 {
	return self.Priority
}

func (self *FlowMod) GetBufferId() uint32 {
	return self.BufferId
}

func (self *FlowMod) GetOutPort() PortNo {
	return self.OutPort
}

func (self *FlowMod) GetFlags() FlowModFlags {
	return self.Flags
}

func (self *FlowMod) GetActions() []IAction {
	return self.Actions
}

func (self *FlowMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Cookie))
	self.Command.Serialize(encoder)
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint32(uint32(self.BufferId))
	self.OutPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.Flags))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}

func decodeFlowMod(parent *Header, decoder *goloxi.Decoder) (IFlowMod, error) {
	flowmod := &FlowMod{Header: parent}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("FlowMod packet too short: %d < 64", decoder.Length())
	}
	if err := flowmod.Match.Decode(decoder); err != nil {
		return nil, err
	}

	flowmod.Cookie = uint64(decoder.ReadUint64())
	flowmod.Command.Decode(decoder)
	flowmod.IdleTimeout = uint16(decoder.ReadUint16())
	flowmod.HardTimeout = uint16(decoder.ReadUint16())
	flowmod.Priority = uint16(decoder.ReadUint16())
	flowmod.BufferId = uint32(decoder.ReadUint32())
	flowmod.OutPort.Decode(decoder)
	flowmod.Flags = FlowModFlags(decoder.ReadUint16())

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		flowmod.Actions = append(flowmod.Actions, item)
	}

	switch flowmod.Command {
	case 0:
		return decodeFlowAdd(flowmod, decoder)
	case 1:
		return decodeFlowModify(flowmod, decoder)
	case 2:
		return decodeFlowModifyStrict(flowmod, decoder)
	case 3:
		return decodeFlowDelete(flowmod, decoder)
	case 4:
		return decodeFlowDeleteStrict(flowmod, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'FlowMod'", flowmod.Command)
	}
}

func NewFlowMod(__command FmCmd) *FlowMod {
	return &FlowMod{
		Command: __command,
		Header:  NewHeader(14),
	}
}

type FlowAdd struct {
	*FlowMod
}

func (self *FlowAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowAdd(parent *FlowMod, decoder *goloxi.Decoder) (*FlowAdd, error) {
	flowadd := &FlowAdd{FlowMod: parent}
	return flowadd, nil
}

func NewFlowAdd() *FlowAdd {
	return &FlowAdd{
		FlowMod: NewFlowMod(0),
	}
}

type FlowDelete struct {
	*FlowMod
}

func (self *FlowDelete) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowDelete(parent *FlowMod, decoder *goloxi.Decoder) (*FlowDelete, error) {
	flowdelete := &FlowDelete{FlowMod: parent}
	return flowdelete, nil
}

func NewFlowDelete() *FlowDelete {
	return &FlowDelete{
		FlowMod: NewFlowMod(3),
	}
}

type FlowDeleteStrict struct {
	*FlowMod
}

func (self *FlowDeleteStrict) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowDeleteStrict(parent *FlowMod, decoder *goloxi.Decoder) (*FlowDeleteStrict, error) {
	flowdeletestrict := &FlowDeleteStrict{FlowMod: parent}
	return flowdeletestrict, nil
}

func NewFlowDeleteStrict() *FlowDeleteStrict {
	return &FlowDeleteStrict{
		FlowMod: NewFlowMod(4),
	}
}

type FlowModFailedErrorMsg struct {
	*ErrorMsg
	Code FlowModFailedCode
	Data []byte
}

func (self *FlowModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*FlowModFailedErrorMsg, error) {
	flowmodfailederrormsg := &FlowModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("FlowModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	flowmodfailederrormsg.Code = FlowModFailedCode(decoder.ReadUint16())
	flowmodfailederrormsg.Data = decoder.Read(decoder.Length())
	return flowmodfailederrormsg, nil
}

func NewFlowModFailedErrorMsg() *FlowModFailedErrorMsg {
	return &FlowModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(3),
	}
}

type FlowModify struct {
	*FlowMod
}

func (self *FlowModify) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModify(parent *FlowMod, decoder *goloxi.Decoder) (*FlowModify, error) {
	flowmodify := &FlowModify{FlowMod: parent}
	return flowmodify, nil
}

func NewFlowModify() *FlowModify {
	return &FlowModify{
		FlowMod: NewFlowMod(1),
	}
}

type FlowModifyStrict struct {
	*FlowMod
}

func (self *FlowModifyStrict) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModifyStrict(parent *FlowMod, decoder *goloxi.Decoder) (*FlowModifyStrict, error) {
	flowmodifystrict := &FlowModifyStrict{FlowMod: parent}
	return flowmodifystrict, nil
}

func NewFlowModifyStrict() *FlowModifyStrict {
	return &FlowModifyStrict{
		FlowMod: NewFlowMod(2),
	}
}

type FlowRemoved struct {
	*Header
	Match        Match
	Cookie       uint64
	Priority     uint16
	Reason       FlowRemovedReason
	DurationSec  uint32
	DurationNsec uint32
	IdleTimeout  uint16
	PacketCount  uint64
	ByteCount    uint64
}

func (self *FlowRemoved) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowRemoved(parent *Header, decoder *goloxi.Decoder) (*FlowRemoved, error) {
	flowremoved := &FlowRemoved{Header: parent}
	if decoder.Length() < 80 {
		return nil, fmt.Errorf("FlowRemoved packet too short: %d < 80", decoder.Length())
	}
	if err := flowremoved.Match.Decode(decoder); err != nil {
		return nil, err
	}

	flowremoved.Cookie = uint64(decoder.ReadUint64())
	flowremoved.Priority = uint16(decoder.ReadUint16())
	flowremoved.Reason = FlowRemovedReason(decoder.ReadByte())
	decoder.Skip(1)
	flowremoved.DurationSec = uint32(decoder.ReadUint32())
	flowremoved.DurationNsec = uint32(decoder.ReadUint32())
	flowremoved.IdleTimeout = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	flowremoved.PacketCount = uint64(decoder.ReadUint64())
	flowremoved.ByteCount = uint64(decoder.ReadUint64())
	return flowremoved, nil
}

func NewFlowRemoved() *FlowRemoved {
	return &FlowRemoved{
		Header: NewHeader(11),
	}
}

type FlowStatsReply struct {
	*StatsReply
	Entries []*FlowStatsEntry
}

func (self *FlowStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*FlowStatsReply, error) {
	flowstatsreply := &FlowStatsReply{StatsReply: parent}

	for decoder.Length() >= 88 {
		item, err := decodeFlowStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		flowstatsreply.Entries = append(flowstatsreply.Entries, item)
	}
	return flowstatsreply, nil
}

func NewFlowStatsReply() *FlowStatsReply {
	return &FlowStatsReply{
		StatsReply: NewStatsReply(1),
	}
}

type FlowStatsRequest struct {
	*StatsRequest
	Match   Match
	TableId uint8
	OutPort PortNo
}

func (self *FlowStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	self.OutPort.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*FlowStatsRequest, error) {
	flowstatsrequest := &FlowStatsRequest{StatsRequest: parent}
	if decoder.Length() < 44 {
		return nil, fmt.Errorf("FlowStatsRequest packet too short: %d < 44", decoder.Length())
	}
	if err := flowstatsrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	flowstatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	flowstatsrequest.OutPort.Decode(decoder)
	return flowstatsrequest, nil
}

func NewFlowStatsRequest() *FlowStatsRequest {
	return &FlowStatsRequest{
		StatsRequest: NewStatsRequest(1),
	}
}

type GetConfigReply struct {
	*Header
	Flags       ConfigFlags
	MissSendLen uint16
}

func (self *GetConfigReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.MissSendLen))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGetConfigReply(parent *Header, decoder *goloxi.Decoder) (*GetConfigReply, error) {
	getconfigreply := &GetConfigReply{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GetConfigReply packet too short: %d < 4", decoder.Length())
	}
	getconfigreply.Flags = ConfigFlags(decoder.ReadUint16())
	getconfigreply.MissSendLen = uint16(decoder.ReadUint16())
	return getconfigreply, nil
}

func NewGetConfigReply() *GetConfigReply {
	return &GetConfigReply{
		Header: NewHeader(8),
	}
}

type GetConfigRequest struct {
	*Header
}

func (self *GetConfigRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGetConfigRequest(parent *Header, decoder *goloxi.Decoder) (*GetConfigRequest, error) {
	getconfigrequest := &GetConfigRequest{Header: parent}
	return getconfigrequest, nil
}

func NewGetConfigRequest() *GetConfigRequest {
	return &GetConfigRequest{
		Header: NewHeader(7),
	}
}

type Hello struct {
	*Header
}

func (self *Hello) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeHello(parent *Header, decoder *goloxi.Decoder) (*Hello, error) {
	hello := &Hello{Header: parent}
	return hello, nil
}

func NewHello() *Hello {
	return &Hello{
		Header: NewHeader(0),
	}
}

type HelloFailedErrorMsg struct {
	*ErrorMsg
	Code HelloFailedCode
	Data []byte
}

func (self *HelloFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeHelloFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*HelloFailedErrorMsg, error) {
	hellofailederrormsg := &HelloFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("HelloFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	hellofailederrormsg.Code = HelloFailedCode(decoder.ReadUint16())
	hellofailederrormsg.Data = decoder.Read(decoder.Length())
	return hellofailederrormsg, nil
}

func NewHelloFailedErrorMsg() *HelloFailedErrorMsg {
	return &HelloFailedErrorMsg{
		ErrorMsg: NewErrorMsg(0),
	}
}

type NiciraHeader struct {
	*Experimenter
	Subtype uint32
}

type INiciraHeader interface {
	IExperimenter
	GetSubtype() uint32
}

func (self *NiciraHeader) GetSubtype() uint32 {
	return self.Subtype
}

func (self *NiciraHeader) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Experimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeNiciraHeader(parent *Experimenter, decoder *goloxi.Decoder) (INiciraHeader, error) {
	niciraheader := &NiciraHeader{Experimenter: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraHeader packet too short: %d < 4", decoder.Length())
	}
	niciraheader.Subtype = uint32(decoder.ReadUint32())

	switch niciraheader.Subtype {
	case 10:
		return decodeNiciraControllerRoleRequest(niciraheader, decoder)
	case 11:
		return decodeNiciraControllerRoleReply(niciraheader, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraHeader'", niciraheader.Subtype)
	}
}

func NewNiciraHeader(_subtype uint32) *NiciraHeader {
	return &NiciraHeader{
		Subtype:      _subtype,
		Experimenter: NewExperimenter(8992),
	}
}

type NiciraControllerRoleReply struct {
	*NiciraHeader
	Role NiciraControllerRole
}

func (self *NiciraControllerRoleReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraControllerRoleReply(parent *NiciraHeader, decoder *goloxi.Decoder) (*NiciraControllerRoleReply, error) {
	niciracontrollerrolereply := &NiciraControllerRoleReply{NiciraHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraControllerRoleReply packet too short: %d < 4", decoder.Length())
	}
	niciracontrollerrolereply.Role = NiciraControllerRole(decoder.ReadUint32())
	return niciracontrollerrolereply, nil
}

func NewNiciraControllerRoleReply() *NiciraControllerRoleReply {
	return &NiciraControllerRoleReply{
		NiciraHeader: NewNiciraHeader(11),
	}
}

type NiciraControllerRoleRequest struct {
	*NiciraHeader
	Role NiciraControllerRole
}

func (self *NiciraControllerRoleRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraControllerRoleRequest(parent *NiciraHeader, decoder *goloxi.Decoder) (*NiciraControllerRoleRequest, error) {
	niciracontrollerrolerequest := &NiciraControllerRoleRequest{NiciraHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraControllerRoleRequest packet too short: %d < 4", decoder.Length())
	}
	niciracontrollerrolerequest.Role = NiciraControllerRole(decoder.ReadUint32())
	return niciracontrollerrolerequest, nil
}

func NewNiciraControllerRoleRequest() *NiciraControllerRoleRequest {
	return &NiciraControllerRoleRequest{
		NiciraHeader: NewNiciraHeader(10),
	}
}

type NiciraStatsReply struct {
	*ExperimenterStatsReply
	Subtype uint32
}

type INiciraStatsReply interface {
	IExperimenterStatsReply
	GetSubtype() uint32
}

func (self *NiciraStatsReply) GetSubtype() uint32 {
	return self.Subtype
}

func (self *NiciraStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeNiciraStatsReply(parent *ExperimenterStatsReply, decoder *goloxi.Decoder) (INiciraStatsReply, error) {
	nicirastatsreply := &NiciraStatsReply{ExperimenterStatsReply: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraStatsReply packet too short: %d < 4", decoder.Length())
	}
	nicirastatsreply.Subtype = uint32(decoder.ReadUint32())

	switch nicirastatsreply.Subtype {
	case 0:
		return decodeNiciraFlowStatsReply(nicirastatsreply, decoder)
	case 2:
		return decodeNiciraFlowMonitorReply(nicirastatsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraStatsReply'", nicirastatsreply.Subtype)
	}
}

func NewNiciraStatsReply(_subtype uint32) *NiciraStatsReply {
	return &NiciraStatsReply{
		Subtype:                _subtype,
		ExperimenterStatsReply: NewExperimenterStatsReply(8992),
	}
}

type NiciraFlowMonitorReply struct {
	*NiciraStatsReply
	Updates []INiciraFlowUpdateEvent
}

func (self *NiciraFlowMonitorReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Updates {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowMonitorReply(parent *NiciraStatsReply, decoder *goloxi.Decoder) (*NiciraFlowMonitorReply, error) {
	niciraflowmonitorreply := &NiciraFlowMonitorReply{NiciraStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 4 {
		item, err := decodeNiciraFlowUpdateEvent(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowmonitorreply.Updates = append(niciraflowmonitorreply.Updates, item)
	}
	return niciraflowmonitorreply, nil
}

func NewNiciraFlowMonitorReply() *NiciraFlowMonitorReply {
	return &NiciraFlowMonitorReply{
		NiciraStatsReply: NewNiciraStatsReply(2),
	}
}

type NiciraFlowMonitorRequest struct {
	*ExperimenterStatsRequest
	Subtype      uint32
	MonitorId    uint32
	MonitorFlags NxFlowMonitorFlags
	OutPort      PortNo
	MatchLen     uint16
	TableId      uint8
	Match        NiciraMatch
}

func (self *NiciraFlowMonitorRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.MonitorId))
	encoder.PutUint16(uint16(self.MonitorFlags))
	self.OutPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 5))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowMonitorRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (*NiciraFlowMonitorRequest, error) {
	niciraflowmonitorrequest := &NiciraFlowMonitorRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("NiciraFlowMonitorRequest packet too short: %d < 24", decoder.Length())
	}
	niciraflowmonitorrequest.Subtype = uint32(decoder.ReadUint32())
	// if niciraflowmonitorrequest.Subtype != 0 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '0'.", niciraflowmonitorrequest.Subtype)
	// }
	decoder.Skip(4)
	niciraflowmonitorrequest.MonitorId = uint32(decoder.ReadUint32())
	niciraflowmonitorrequest.MonitorFlags = NxFlowMonitorFlags(decoder.ReadUint16())
	niciraflowmonitorrequest.OutPort.Decode(decoder)
	niciraflowmonitorrequest.MatchLen = uint16(decoder.ReadUint16())
	niciraflowmonitorrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(5)
	if err := niciraflowmonitorrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return niciraflowmonitorrequest, nil
}

func NewNiciraFlowMonitorRequest() *NiciraFlowMonitorRequest {
	return &NiciraFlowMonitorRequest{
		ExperimenterStatsRequest: NewExperimenterStatsRequest(8992),
	}
}

type NiciraFlowStatsReply struct {
	*NiciraStatsReply
	Stats []*NiciraFlowStats
}

func (self *NiciraFlowStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Stats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStatsReply(parent *NiciraStatsReply, decoder *goloxi.Decoder) (*NiciraFlowStatsReply, error) {
	niciraflowstatsreply := &NiciraFlowStatsReply{NiciraStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 48 {
		item, err := decodeNiciraFlowStats(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowstatsreply.Stats = append(niciraflowstatsreply.Stats, item)
	}
	return niciraflowstatsreply, nil
}

func NewNiciraFlowStatsReply() *NiciraFlowStatsReply {
	return &NiciraFlowStatsReply{
		NiciraStatsReply: NewNiciraStatsReply(0),
	}
}

type NiciraFlowStatsRequest struct {
	*ExperimenterStatsRequest
	Subtype  uint32
	OutPort  PortNo
	MatchLen uint16
	TableId  uint8
}

func (self *NiciraFlowStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.OutPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStatsRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (*NiciraFlowStatsRequest, error) {
	niciraflowstatsrequest := &NiciraFlowStatsRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("NiciraFlowStatsRequest packet too short: %d < 16", decoder.Length())
	}
	niciraflowstatsrequest.Subtype = uint32(decoder.ReadUint32())
	// if niciraflowstatsrequest.Subtype != 0 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '0'.", niciraflowstatsrequest.Subtype)
	// }
	decoder.Skip(4)
	niciraflowstatsrequest.OutPort.Decode(decoder)
	niciraflowstatsrequest.MatchLen = uint16(decoder.ReadUint16())
	niciraflowstatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return niciraflowstatsrequest, nil
}

func NewNiciraFlowStatsRequest() *NiciraFlowStatsRequest {
	return &NiciraFlowStatsRequest{
		ExperimenterStatsRequest: NewExperimenterStatsRequest(8992),
	}
}

type PacketIn struct {
	*Header
	BufferId uint32
	TotalLen uint16
	InPort   PortNo
	Reason   uint8
	Data     []byte
}

func (self *PacketIn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BufferId))
	encoder.PutUint16(uint16(self.TotalLen))
	self.InPort.Serialize(encoder)
	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketIn(parent *Header, decoder *goloxi.Decoder) (*PacketIn, error) {
	packetin := &PacketIn{Header: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("PacketIn packet too short: %d < 10", decoder.Length())
	}
	packetin.BufferId = uint32(decoder.ReadUint32())
	packetin.TotalLen = uint16(decoder.ReadUint16())
	packetin.InPort.Decode(decoder)
	packetin.Reason = uint8(decoder.ReadByte())
	decoder.Skip(1)
	packetin.Data = decoder.Read(decoder.Length())
	return packetin, nil
}

func NewPacketIn() *PacketIn {
	return &PacketIn{
		Header: NewHeader(10),
	}
}

type PacketOut struct {
	*Header
	BufferId   uint32
	InPort     PortNo
	ActionsLen uint16
	Actions    []IAction
	Data       []byte
}

func (self *PacketOut) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BufferId))
	self.InPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActionsLen))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketOut(parent *Header, decoder *goloxi.Decoder) (*PacketOut, error) {
	packetout := &PacketOut{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PacketOut packet too short: %d < 8", decoder.Length())
	}
	packetout.BufferId = uint32(decoder.ReadUint32())
	packetout.InPort.Decode(decoder)
	packetout.ActionsLen = uint16(decoder.ReadUint16())

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		packetout.Actions = append(packetout.Actions, item)
	}
	packetout.Data = decoder.Read(decoder.Length())
	return packetout, nil
}

func NewPacketOut() *PacketOut {
	return &PacketOut{
		Header: NewHeader(13),
	}
}

type PortMod struct {
	*Header
	PortNo    PortNo
	HwAddr    net.HardwareAddr
	Config    PortConfig
	Mask      PortConfig
	Advertise uint32
}

func (self *PortMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.Write(self.HwAddr)
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.Mask))
	encoder.PutUint32(uint32(self.Advertise))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortMod(parent *Header, decoder *goloxi.Decoder) (*PortMod, error) {
	portmod := &PortMod{Header: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortMod packet too short: %d < 24", decoder.Length())
	}
	portmod.PortNo.Decode(decoder)
	portmod.HwAddr = net.HardwareAddr(decoder.Read(6))
	portmod.Config = PortConfig(decoder.ReadUint32())
	portmod.Mask = PortConfig(decoder.ReadUint32())
	portmod.Advertise = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return portmod, nil
}

func NewPortMod() *PortMod {
	return &PortMod{
		Header: NewHeader(15),
	}
}

type PortModFailedErrorMsg struct {
	*ErrorMsg
	Code PortModFailedCode
	Data []byte
}

func (self *PortModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*PortModFailedErrorMsg, error) {
	portmodfailederrormsg := &PortModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("PortModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	portmodfailederrormsg.Code = PortModFailedCode(decoder.ReadUint16())
	portmodfailederrormsg.Data = decoder.Read(decoder.Length())
	return portmodfailederrormsg, nil
}

func NewPortModFailedErrorMsg() *PortModFailedErrorMsg {
	return &PortModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(4),
	}
}

type PortStatsReply struct {
	*StatsReply
	Entries []*PortStatsEntry
}

func (self *PortStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*PortStatsReply, error) {
	portstatsreply := &PortStatsReply{StatsReply: parent}

	for decoder.Length() >= 104 {
		item, err := decodePortStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		portstatsreply.Entries = append(portstatsreply.Entries, item)
	}
	return portstatsreply, nil
}

func NewPortStatsReply() *PortStatsReply {
	return &PortStatsReply{
		StatsReply: NewStatsReply(4),
	}
}

type PortStatsRequest struct {
	*StatsRequest
	PortNo PortNo
}

func (self *PortStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*PortStatsRequest, error) {
	portstatsrequest := &PortStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortStatsRequest packet too short: %d < 8", decoder.Length())
	}
	portstatsrequest.PortNo.Decode(decoder)
	decoder.Skip(6)
	return portstatsrequest, nil
}

func NewPortStatsRequest() *PortStatsRequest {
	return &PortStatsRequest{
		StatsRequest: NewStatsRequest(4),
	}
}

type PortStatus struct {
	*Header
	Reason PortReason
	Desc   PortDesc
}

func (self *PortStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 7))
	if err := self.Desc.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatus(parent *Header, decoder *goloxi.Decoder) (*PortStatus, error) {
	portstatus := &PortStatus{Header: parent}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("PortStatus packet too short: %d < 56", decoder.Length())
	}
	portstatus.Reason = PortReason(decoder.ReadByte())
	decoder.Skip(7)
	if err := portstatus.Desc.Decode(decoder); err != nil {
		return nil, err
	}

	return portstatus, nil
}

func NewPortStatus() *PortStatus {
	return &PortStatus{
		Header: NewHeader(12),
	}
}

type QueueGetConfigReply struct {
	*Header
	Port   PortNo
	Queues []*PacketQueue
}

func (self *QueueGetConfigReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	self.Port.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Queues {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueGetConfigReply(parent *Header, decoder *goloxi.Decoder) (*QueueGetConfigReply, error) {
	queuegetconfigreply := &QueueGetConfigReply{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueGetConfigReply packet too short: %d < 8", decoder.Length())
	}
	queuegetconfigreply.Port.Decode(decoder)
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := decodePacketQueue(decoder)
		if err != nil {
			return nil, err
		}
		queuegetconfigreply.Queues = append(queuegetconfigreply.Queues, item)
	}
	return queuegetconfigreply, nil
}

func NewQueueGetConfigReply() *QueueGetConfigReply {
	return &QueueGetConfigReply{
		Header: NewHeader(21),
	}
}

type QueueGetConfigRequest struct {
	*Header
	Port PortNo
}

func (self *QueueGetConfigRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	self.Port.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueGetConfigRequest(parent *Header, decoder *goloxi.Decoder) (*QueueGetConfigRequest, error) {
	queuegetconfigrequest := &QueueGetConfigRequest{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueGetConfigRequest packet too short: %d < 4", decoder.Length())
	}
	queuegetconfigrequest.Port.Decode(decoder)
	decoder.Skip(2)
	return queuegetconfigrequest, nil
}

func NewQueueGetConfigRequest() *QueueGetConfigRequest {
	return &QueueGetConfigRequest{
		Header: NewHeader(20),
	}
}

type QueueOpFailedErrorMsg struct {
	*ErrorMsg
	Code QueueOpFailedCode
	Data []byte
}

func (self *QueueOpFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueOpFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*QueueOpFailedErrorMsg, error) {
	queueopfailederrormsg := &QueueOpFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("QueueOpFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	queueopfailederrormsg.Code = QueueOpFailedCode(decoder.ReadUint16())
	queueopfailederrormsg.Data = decoder.Read(decoder.Length())
	return queueopfailederrormsg, nil
}

func NewQueueOpFailedErrorMsg() *QueueOpFailedErrorMsg {
	return &QueueOpFailedErrorMsg{
		ErrorMsg: NewErrorMsg(5),
	}
}

type QueueStatsReply struct {
	*StatsReply
	Entries []*QueueStatsEntry
}

func (self *QueueStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*QueueStatsReply, error) {
	queuestatsreply := &QueueStatsReply{StatsReply: parent}

	for decoder.Length() >= 32 {
		item, err := decodeQueueStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		queuestatsreply.Entries = append(queuestatsreply.Entries, item)
	}
	return queuestatsreply, nil
}

func NewQueueStatsReply() *QueueStatsReply {
	return &QueueStatsReply{
		StatsReply: NewStatsReply(5),
	}
}

type QueueStatsRequest struct {
	*StatsRequest
	PortNo  PortNo
	QueueId uint32
}

func (self *QueueStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.QueueId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*QueueStatsRequest, error) {
	queuestatsrequest := &QueueStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueStatsRequest packet too short: %d < 8", decoder.Length())
	}
	queuestatsrequest.PortNo.Decode(decoder)
	decoder.Skip(2)
	queuestatsrequest.QueueId = uint32(decoder.ReadUint32())
	return queuestatsrequest, nil
}

func NewQueueStatsRequest() *QueueStatsRequest {
	return &QueueStatsRequest{
		StatsRequest: NewStatsRequest(5),
	}
}

type SetConfig struct {
	*Header
	Flags       ConfigFlags
	MissSendLen uint16
}

func (self *SetConfig) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.MissSendLen))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeSetConfig(parent *Header, decoder *goloxi.Decoder) (*SetConfig, error) {
	setconfig := &SetConfig{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("SetConfig packet too short: %d < 4", decoder.Length())
	}
	setconfig.Flags = ConfigFlags(decoder.ReadUint16())
	setconfig.MissSendLen = uint16(decoder.ReadUint16())
	return setconfig, nil
}

func NewSetConfig() *SetConfig {
	return &SetConfig{
		Header: NewHeader(9),
	}
}

type TableMod struct {
	*Header
	TableId uint8
	Config  uint32
}

func (self *TableMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.Config))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableMod(parent *Header, decoder *goloxi.Decoder) (*TableMod, error) {
	tablemod := &TableMod{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableMod packet too short: %d < 8", decoder.Length())
	}
	tablemod.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	tablemod.Config = uint32(decoder.ReadUint32())
	return tablemod, nil
}

func NewTableMod() *TableMod {
	return &TableMod{
		Header: NewHeader(22),
	}
}

type TableStatsReply struct {
	*StatsReply
	Entries []*TableStatsEntry
}

func (self *TableStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*TableStatsReply, error) {
	tablestatsreply := &TableStatsReply{StatsReply: parent}

	for decoder.Length() >= 64 {
		item, err := decodeTableStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		tablestatsreply.Entries = append(tablestatsreply.Entries, item)
	}
	return tablestatsreply, nil
}

func NewTableStatsReply() *TableStatsReply {
	return &TableStatsReply{
		StatsReply: NewStatsReply(3),
	}
}

type TableStatsRequest struct {
	*StatsRequest
}

func (self *TableStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*TableStatsRequest, error) {
	tablestatsrequest := &TableStatsRequest{StatsRequest: parent}
	return tablestatsrequest, nil
}

func NewTableStatsRequest() *TableStatsRequest {
	return &TableStatsRequest{
		StatsRequest: NewStatsRequest(3),
	}
}
