/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of14

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type AsyncConfigProp struct {
	Type   uint16
	Length uint16
}

type IAsyncConfigProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *AsyncConfigProp) GetType() uint16 {
	return self.Type
}

func (self *AsyncConfigProp) GetLength() uint16 {
	return self.Length
}

func (self *AsyncConfigProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeAsyncConfigProp(decoder *goloxi.Decoder) (IAsyncConfigProp, error) {
	_asyncconfigprop := &AsyncConfigProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigProp packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigprop.Type = uint16(decoder.ReadUint16())
	_asyncconfigprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_asyncconfigprop.Length), 2+2)

	switch _asyncconfigprop.Type {
	case 0:
		return DecodeAsyncConfigPropPacketInSlave(_asyncconfigprop, decoder)
	case 1:
		return DecodeAsyncConfigPropPacketInMaster(_asyncconfigprop, decoder)
	case 2:
		return DecodeAsyncConfigPropPortStatusSlave(_asyncconfigprop, decoder)
	case 3:
		return DecodeAsyncConfigPropPortStatusMaster(_asyncconfigprop, decoder)
	case 4:
		return DecodeAsyncConfigPropFlowRemovedSlave(_asyncconfigprop, decoder)
	case 5:
		return DecodeAsyncConfigPropFlowRemovedMaster(_asyncconfigprop, decoder)
	case 6:
		return DecodeAsyncConfigPropRoleStatusSlave(_asyncconfigprop, decoder)
	case 7:
		return DecodeAsyncConfigPropRoleStatusMaster(_asyncconfigprop, decoder)
	case 8:
		return DecodeAsyncConfigPropTableStatusSlave(_asyncconfigprop, decoder)
	case 9:
		return DecodeAsyncConfigPropTableStatusMaster(_asyncconfigprop, decoder)
	case 10:
		return DecodeAsyncConfigPropRequestforwardSlave(_asyncconfigprop, decoder)
	case 11:
		return DecodeAsyncConfigPropRequestforwardMaster(_asyncconfigprop, decoder)
	case 65534:
		return DecodeAsyncConfigPropExperimenterSlave(_asyncconfigprop, decoder)
	case 65535:
		return DecodeAsyncConfigPropExperimenterMaster(_asyncconfigprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'AsyncConfigProp'", _asyncconfigprop.Type)
	}
}

func NewAsyncConfigProp(_type uint16) *AsyncConfigProp {
	obj := &AsyncConfigProp{}
	obj.Type = _type
	return obj
}

type AsyncConfigPropExperimenterMaster struct {
	*AsyncConfigProp
}

func (self *AsyncConfigPropExperimenterMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropExperimenterMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropExperimenterMaster, error) {
	_asyncconfigpropexperimentermaster := &AsyncConfigPropExperimenterMaster{AsyncConfigProp: parent}
	return _asyncconfigpropexperimentermaster, nil
}

func NewAsyncConfigPropExperimenterMaster() *AsyncConfigPropExperimenterMaster {
	obj := &AsyncConfigPropExperimenterMaster{
		AsyncConfigProp: NewAsyncConfigProp(65535),
	}
	return obj
}

type AsyncConfigPropExperimenterSlave struct {
	*AsyncConfigProp
}

func (self *AsyncConfigPropExperimenterSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropExperimenterSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropExperimenterSlave, error) {
	_asyncconfigpropexperimenterslave := &AsyncConfigPropExperimenterSlave{AsyncConfigProp: parent}
	return _asyncconfigpropexperimenterslave, nil
}

func NewAsyncConfigPropExperimenterSlave() *AsyncConfigPropExperimenterSlave {
	obj := &AsyncConfigPropExperimenterSlave{
		AsyncConfigProp: NewAsyncConfigProp(65534),
	}
	return obj
}

type AsyncConfigPropFlowRemovedMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowRemovedMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropFlowRemovedMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowRemovedMaster, error) {
	_asyncconfigpropflowremovedmaster := &AsyncConfigPropFlowRemovedMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowRemovedMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigpropflowremovedmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigpropflowremovedmaster, nil
}

func NewAsyncConfigPropFlowRemovedMaster() *AsyncConfigPropFlowRemovedMaster {
	obj := &AsyncConfigPropFlowRemovedMaster{
		AsyncConfigProp: NewAsyncConfigProp(5),
	}
	return obj
}

type AsyncConfigPropFlowRemovedSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowRemovedSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropFlowRemovedSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowRemovedSlave, error) {
	_asyncconfigpropflowremovedslave := &AsyncConfigPropFlowRemovedSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowRemovedSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigpropflowremovedslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigpropflowremovedslave, nil
}

func NewAsyncConfigPropFlowRemovedSlave() *AsyncConfigPropFlowRemovedSlave {
	obj := &AsyncConfigPropFlowRemovedSlave{
		AsyncConfigProp: NewAsyncConfigProp(4),
	}
	return obj
}

type AsyncConfigPropPacketInMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPacketInMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropPacketInMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPacketInMaster, error) {
	_asyncconfigproppacketinmaster := &AsyncConfigPropPacketInMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPacketInMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproppacketinmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproppacketinmaster, nil
}

func NewAsyncConfigPropPacketInMaster() *AsyncConfigPropPacketInMaster {
	obj := &AsyncConfigPropPacketInMaster{
		AsyncConfigProp: NewAsyncConfigProp(1),
	}
	return obj
}

type AsyncConfigPropPacketInSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPacketInSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropPacketInSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPacketInSlave, error) {
	_asyncconfigproppacketinslave := &AsyncConfigPropPacketInSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPacketInSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproppacketinslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproppacketinslave, nil
}

func NewAsyncConfigPropPacketInSlave() *AsyncConfigPropPacketInSlave {
	obj := &AsyncConfigPropPacketInSlave{
		AsyncConfigProp: NewAsyncConfigProp(0),
	}
	return obj
}

type AsyncConfigPropPortStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPortStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropPortStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPortStatusMaster, error) {
	_asyncconfigpropportstatusmaster := &AsyncConfigPropPortStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPortStatusMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigpropportstatusmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigpropportstatusmaster, nil
}

func NewAsyncConfigPropPortStatusMaster() *AsyncConfigPropPortStatusMaster {
	obj := &AsyncConfigPropPortStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(3),
	}
	return obj
}

type AsyncConfigPropPortStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPortStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropPortStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPortStatusSlave, error) {
	_asyncconfigpropportstatusslave := &AsyncConfigPropPortStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPortStatusSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigpropportstatusslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigpropportstatusslave, nil
}

func NewAsyncConfigPropPortStatusSlave() *AsyncConfigPropPortStatusSlave {
	obj := &AsyncConfigPropPortStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(2),
	}
	return obj
}

type AsyncConfigPropRequestforwardMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRequestforwardMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropRequestforwardMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRequestforwardMaster, error) {
	_asyncconfigproprequestforwardmaster := &AsyncConfigPropRequestforwardMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRequestforwardMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproprequestforwardmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproprequestforwardmaster, nil
}

func NewAsyncConfigPropRequestforwardMaster() *AsyncConfigPropRequestforwardMaster {
	obj := &AsyncConfigPropRequestforwardMaster{
		AsyncConfigProp: NewAsyncConfigProp(11),
	}
	return obj
}

type AsyncConfigPropRequestforwardSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRequestforwardSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropRequestforwardSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRequestforwardSlave, error) {
	_asyncconfigproprequestforwardslave := &AsyncConfigPropRequestforwardSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRequestforwardSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproprequestforwardslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproprequestforwardslave, nil
}

func NewAsyncConfigPropRequestforwardSlave() *AsyncConfigPropRequestforwardSlave {
	obj := &AsyncConfigPropRequestforwardSlave{
		AsyncConfigProp: NewAsyncConfigProp(10),
	}
	return obj
}

type AsyncConfigPropRoleStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRoleStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropRoleStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRoleStatusMaster, error) {
	_asyncconfigproprolestatusmaster := &AsyncConfigPropRoleStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRoleStatusMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproprolestatusmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproprolestatusmaster, nil
}

func NewAsyncConfigPropRoleStatusMaster() *AsyncConfigPropRoleStatusMaster {
	obj := &AsyncConfigPropRoleStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(7),
	}
	return obj
}

type AsyncConfigPropRoleStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRoleStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropRoleStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRoleStatusSlave, error) {
	_asyncconfigproprolestatusslave := &AsyncConfigPropRoleStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRoleStatusSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproprolestatusslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproprolestatusslave, nil
}

func NewAsyncConfigPropRoleStatusSlave() *AsyncConfigPropRoleStatusSlave {
	obj := &AsyncConfigPropRoleStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(6),
	}
	return obj
}

type AsyncConfigPropTableStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropTableStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropTableStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropTableStatusMaster, error) {
	_asyncconfigproptablestatusmaster := &AsyncConfigPropTableStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropTableStatusMaster packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproptablestatusmaster.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproptablestatusmaster, nil
}

func NewAsyncConfigPropTableStatusMaster() *AsyncConfigPropTableStatusMaster {
	obj := &AsyncConfigPropTableStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(9),
	}
	return obj
}

type AsyncConfigPropTableStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropTableStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeAsyncConfigPropTableStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropTableStatusSlave, error) {
	_asyncconfigproptablestatusslave := &AsyncConfigPropTableStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropTableStatusSlave packet too short: %d < 4", decoder.Length())
	}
	_asyncconfigproptablestatusslave.Mask = uint32(decoder.ReadUint32())
	return _asyncconfigproptablestatusslave, nil
}

func NewAsyncConfigPropTableStatusSlave() *AsyncConfigPropTableStatusSlave {
	obj := &AsyncConfigPropTableStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(8),
	}
	return obj
}

type BsnControllerConnection struct {
	State       BsnControllerConnectionState
	AuxiliaryId uint8
	Role        ControllerRole
	Uri         string
}

func (self *BsnControllerConnection) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.State))
	encoder.PutUint8(uint8(self.AuxiliaryId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Role))
	encoder.Write([]byte(self.Uri))

	return nil
}

func DecodeBsnControllerConnection(decoder *goloxi.Decoder) (*BsnControllerConnection, error) {
	_bsncontrollerconnection := &BsnControllerConnection{}
	if decoder.Length() < 264 {
		return nil, fmt.Errorf("BsnControllerConnection packet too short: %d < 264", decoder.Length())
	}
	_bsncontrollerconnection.State = BsnControllerConnectionState(decoder.ReadByte())
	_bsncontrollerconnection.AuxiliaryId = uint8(decoder.ReadByte())
	decoder.Skip(2)
	_bsncontrollerconnection.Role = ControllerRole(decoder.ReadUint32())
	_bsncontrollerconnection.Uri = string(bytes.Trim(decoder.Read(256), "\x00"))
	return _bsncontrollerconnection, nil
}

func NewBsnControllerConnection() *BsnControllerConnection {
	obj := &BsnControllerConnection{}
	return obj
}

type BsnDebugCounterDescStatsEntry struct {
	CounterId   uint64
	Name        string
	Description string
}

func (self *BsnDebugCounterDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.CounterId))
	encoder.Write([]byte(self.Name))
	encoder.Write([]byte(self.Description))

	return nil
}

func DecodeBsnDebugCounterDescStatsEntry(decoder *goloxi.Decoder) (*BsnDebugCounterDescStatsEntry, error) {
	_bsndebugcounterdescstatsentry := &BsnDebugCounterDescStatsEntry{}
	if decoder.Length() < 328 {
		return nil, fmt.Errorf("BsnDebugCounterDescStatsEntry packet too short: %d < 328", decoder.Length())
	}
	_bsndebugcounterdescstatsentry.CounterId = uint64(decoder.ReadUint64())
	_bsndebugcounterdescstatsentry.Name = string(bytes.Trim(decoder.Read(64), "\x00"))
	_bsndebugcounterdescstatsentry.Description = string(bytes.Trim(decoder.Read(256), "\x00"))
	return _bsndebugcounterdescstatsentry, nil
}

func NewBsnDebugCounterDescStatsEntry() *BsnDebugCounterDescStatsEntry {
	obj := &BsnDebugCounterDescStatsEntry{}
	return obj
}

type BsnDebugCounterStatsEntry struct {
	CounterId uint64
	Value     uint64
}

func (self *BsnDebugCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.CounterId))
	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeBsnDebugCounterStatsEntry(decoder *goloxi.Decoder) (*BsnDebugCounterStatsEntry, error) {
	_bsndebugcounterstatsentry := &BsnDebugCounterStatsEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnDebugCounterStatsEntry packet too short: %d < 16", decoder.Length())
	}
	_bsndebugcounterstatsentry.CounterId = uint64(decoder.ReadUint64())
	_bsndebugcounterstatsentry.Value = uint64(decoder.ReadUint64())
	return _bsndebugcounterstatsentry, nil
}

func NewBsnDebugCounterStatsEntry() *BsnDebugCounterStatsEntry {
	obj := &BsnDebugCounterStatsEntry{}
	return obj
}

type BsnFlowChecksumBucketStatsEntry struct {
	Checksum uint64
}

func (self *BsnFlowChecksumBucketStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.Checksum))

	return nil
}

func DecodeBsnFlowChecksumBucketStatsEntry(decoder *goloxi.Decoder) (*BsnFlowChecksumBucketStatsEntry, error) {
	_bsnflowchecksumbucketstatsentry := &BsnFlowChecksumBucketStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnFlowChecksumBucketStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_bsnflowchecksumbucketstatsentry.Checksum = uint64(decoder.ReadUint64())
	return _bsnflowchecksumbucketstatsentry, nil
}

func NewBsnFlowChecksumBucketStatsEntry() *BsnFlowChecksumBucketStatsEntry {
	obj := &BsnFlowChecksumBucketStatsEntry{}
	return obj
}

type BsnGenericStatsEntry struct {
	Length uint16
	Tlvs   []IBsnTlv
}

func (self *BsnGenericStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.Tlvs {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnGenericStatsEntry(decoder *goloxi.Decoder) (*BsnGenericStatsEntry, error) {
	_bsngenericstatsentry := &BsnGenericStatsEntry{}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnGenericStatsEntry packet too short: %d < 2", decoder.Length())
	}
	_bsngenericstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsngenericstatsentry.Length), 2+0)

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsngenericstatsentry.Tlvs = append(_bsngenericstatsentry.Tlvs, item)
	}
	return _bsngenericstatsentry, nil
}

func NewBsnGenericStatsEntry() *BsnGenericStatsEntry {
	obj := &BsnGenericStatsEntry{}
	return obj
}

type BsnGentableBucketStatsEntry struct {
	Checksum Checksum128
}

func (self *BsnGentableBucketStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.Checksum.Serialize(encoder)

	return nil
}

func DecodeBsnGentableBucketStatsEntry(decoder *goloxi.Decoder) (*BsnGentableBucketStatsEntry, error) {
	_bsngentablebucketstatsentry := &BsnGentableBucketStatsEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnGentableBucketStatsEntry packet too short: %d < 16", decoder.Length())
	}
	_bsngentablebucketstatsentry.Checksum.Decode(decoder)
	return _bsngentablebucketstatsentry, nil
}

func NewBsnGentableBucketStatsEntry() *BsnGentableBucketStatsEntry {
	obj := &BsnGentableBucketStatsEntry{}
	return obj
}

type BsnGentableDescStatsEntry struct {
	Length      uint16
	TableId     uint16
	Name        string
	BucketsSize uint32
	MaxEntries  uint32
}

func (self *BsnGentableDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.BucketsSize))
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnGentableDescStatsEntry(decoder *goloxi.Decoder) (*BsnGentableDescStatsEntry, error) {
	_bsngentabledescstatsentry := &BsnGentableDescStatsEntry{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("BsnGentableDescStatsEntry packet too short: %d < 48", decoder.Length())
	}
	_bsngentabledescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsngentabledescstatsentry.Length), 2+0)
	_bsngentabledescstatsentry.TableId = uint16(decoder.ReadUint16())
	_bsngentabledescstatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	_bsngentabledescstatsentry.BucketsSize = uint32(decoder.ReadUint32())
	_bsngentabledescstatsentry.MaxEntries = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return _bsngentabledescstatsentry, nil
}

func NewBsnGentableDescStatsEntry() *BsnGentableDescStatsEntry {
	obj := &BsnGentableDescStatsEntry{}
	return obj
}

type BsnGentableEntryDescStatsEntry struct {
	Length    uint16
	KeyLength uint16
	Checksum  Checksum128
	Key       []IBsnTlv
	Value     []IBsnTlv
}

func (self *BsnGentableEntryDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.KeyLength))
	self.Checksum.Serialize(encoder)
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnGentableEntryDescStatsEntry(decoder *goloxi.Decoder) (*BsnGentableEntryDescStatsEntry, error) {
	_bsngentableentrydescstatsentry := &BsnGentableEntryDescStatsEntry{}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("BsnGentableEntryDescStatsEntry packet too short: %d < 20", decoder.Length())
	}
	_bsngentableentrydescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsngentableentrydescstatsentry.Length), 2+0)
	_bsngentableentrydescstatsentry.KeyLength = uint16(decoder.ReadUint16())
	_bsngentableentrydescstatsentry.Checksum.Decode(decoder)

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsngentableentrydescstatsentry.Key = append(_bsngentableentrydescstatsentry.Key, item)
	}

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsngentableentrydescstatsentry.Value = append(_bsngentableentrydescstatsentry.Value, item)
	}
	return _bsngentableentrydescstatsentry, nil
}

func NewBsnGentableEntryDescStatsEntry() *BsnGentableEntryDescStatsEntry {
	obj := &BsnGentableEntryDescStatsEntry{}
	return obj
}

type BsnGentableEntryStatsEntry struct {
	Length    uint16
	KeyLength uint16
	Key       []IBsnTlv
	Stats     []IBsnTlv
}

func (self *BsnGentableEntryStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.KeyLength))
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Stats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnGentableEntryStatsEntry(decoder *goloxi.Decoder) (*BsnGentableEntryStatsEntry, error) {
	_bsngentableentrystatsentry := &BsnGentableEntryStatsEntry{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGentableEntryStatsEntry packet too short: %d < 4", decoder.Length())
	}
	_bsngentableentrystatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsngentableentrystatsentry.Length), 2+0)
	_bsngentableentrystatsentry.KeyLength = uint16(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsngentableentrystatsentry.Key = append(_bsngentableentrystatsentry.Key, item)
	}

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsngentableentrystatsentry.Stats = append(_bsngentableentrystatsentry.Stats, item)
	}
	return _bsngentableentrystatsentry, nil
}

func NewBsnGentableEntryStatsEntry() *BsnGentableEntryStatsEntry {
	obj := &BsnGentableEntryStatsEntry{}
	return obj
}

type BsnGentableStatsEntry struct {
	TableId    uint16
	EntryCount uint32
	Checksum   Checksum128
}

func (self *BsnGentableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.EntryCount))
	self.Checksum.Serialize(encoder)

	return nil
}

func DecodeBsnGentableStatsEntry(decoder *goloxi.Decoder) (*BsnGentableStatsEntry, error) {
	_bsngentablestatsentry := &BsnGentableStatsEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnGentableStatsEntry packet too short: %d < 24", decoder.Length())
	}
	_bsngentablestatsentry.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	_bsngentablestatsentry.EntryCount = uint32(decoder.ReadUint32())
	_bsngentablestatsentry.Checksum.Decode(decoder)
	return _bsngentablestatsentry, nil
}

func NewBsnGentableStatsEntry() *BsnGentableStatsEntry {
	obj := &BsnGentableStatsEntry{}
	return obj
}

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func DecodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	_bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	_bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	_bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	_bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	_bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return _bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	obj := &BsnInterface{}
	return obj
}

type BsnLacpStatsEntry struct {
	PortNo              PortNo
	ActorSysPriority    uint16
	ActorSysMac         net.HardwareAddr
	ActorPortPriority   uint16
	ActorPortNum        uint16
	ActorKey            uint16
	ConvergenceStatus   uint8
	PartnerSysPriority  uint16
	PartnerSysMac       net.HardwareAddr
	PartnerPortPriority uint16
	PartnerPortNum      uint16
	PartnerKey          uint16
}

func (self *BsnLacpStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActorSysPriority))
	encoder.Write(self.ActorSysMac)
	encoder.PutUint16(uint16(self.ActorPortPriority))
	encoder.PutUint16(uint16(self.ActorPortNum))
	encoder.PutUint16(uint16(self.ActorKey))
	encoder.PutUint8(uint8(self.ConvergenceStatus))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.PartnerSysPriority))
	encoder.Write(self.PartnerSysMac)
	encoder.PutUint16(uint16(self.PartnerPortPriority))
	encoder.PutUint16(uint16(self.PartnerPortNum))
	encoder.PutUint16(uint16(self.PartnerKey))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	return nil
}

func DecodeBsnLacpStatsEntry(decoder *goloxi.Decoder) (*BsnLacpStatsEntry, error) {
	_bsnlacpstatsentry := &BsnLacpStatsEntry{}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnLacpStatsEntry packet too short: %d < 36", decoder.Length())
	}
	_bsnlacpstatsentry.PortNo.Decode(decoder)
	_bsnlacpstatsentry.ActorSysPriority = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.ActorSysMac = net.HardwareAddr(decoder.Read(6))
	_bsnlacpstatsentry.ActorPortPriority = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.ActorPortNum = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.ActorKey = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.ConvergenceStatus = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_bsnlacpstatsentry.PartnerSysPriority = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.PartnerSysMac = net.HardwareAddr(decoder.Read(6))
	_bsnlacpstatsentry.PartnerPortPriority = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.PartnerPortNum = uint16(decoder.ReadUint16())
	_bsnlacpstatsentry.PartnerKey = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return _bsnlacpstatsentry, nil
}

func NewBsnLacpStatsEntry() *BsnLacpStatsEntry {
	obj := &BsnLacpStatsEntry{}
	return obj
}

type BsnPortCounterStatsEntry struct {
	Length uint16
	PortNo PortNo
	Values []*Uint64
}

func (self *BsnPortCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.PortNo.Serialize(encoder)
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnPortCounterStatsEntry(decoder *goloxi.Decoder) (*BsnPortCounterStatsEntry, error) {
	_bsnportcounterstatsentry := &BsnPortCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnPortCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_bsnportcounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsnportcounterstatsentry.Length), 2+0)
	decoder.Skip(2)
	_bsnportcounterstatsentry.PortNo.Decode(decoder)

	for decoder.Length() >= 8 {
		item, err := DecodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		_bsnportcounterstatsentry.Values = append(_bsnportcounterstatsentry.Values, item)
	}
	return _bsnportcounterstatsentry, nil
}

func NewBsnPortCounterStatsEntry() *BsnPortCounterStatsEntry {
	obj := &BsnPortCounterStatsEntry{}
	return obj
}

type BsnSwitchPipelineStatsEntry struct {
	Pipeline string
}

func (self *BsnSwitchPipelineStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write([]byte(self.Pipeline))

	return nil
}

func DecodeBsnSwitchPipelineStatsEntry(decoder *goloxi.Decoder) (*BsnSwitchPipelineStatsEntry, error) {
	_bsnswitchpipelinestatsentry := &BsnSwitchPipelineStatsEntry{}
	if decoder.Length() < 256 {
		return nil, fmt.Errorf("BsnSwitchPipelineStatsEntry packet too short: %d < 256", decoder.Length())
	}
	_bsnswitchpipelinestatsentry.Pipeline = string(bytes.Trim(decoder.Read(256), "\x00"))
	return _bsnswitchpipelinestatsentry, nil
}

func NewBsnSwitchPipelineStatsEntry() *BsnSwitchPipelineStatsEntry {
	obj := &BsnSwitchPipelineStatsEntry{}
	return obj
}

type BsnTableChecksumStatsEntry struct {
	TableId  uint8
	Checksum uint64
}

func (self *BsnTableChecksumStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint64(uint64(self.Checksum))

	return nil
}

func DecodeBsnTableChecksumStatsEntry(decoder *goloxi.Decoder) (*BsnTableChecksumStatsEntry, error) {
	_bsntablechecksumstatsentry := &BsnTableChecksumStatsEntry{}
	if decoder.Length() < 9 {
		return nil, fmt.Errorf("BsnTableChecksumStatsEntry packet too short: %d < 9", decoder.Length())
	}
	_bsntablechecksumstatsentry.TableId = uint8(decoder.ReadByte())
	_bsntablechecksumstatsentry.Checksum = uint64(decoder.ReadUint64())
	return _bsntablechecksumstatsentry, nil
}

func NewBsnTableChecksumStatsEntry() *BsnTableChecksumStatsEntry {
	obj := &BsnTableChecksumStatsEntry{}
	return obj
}

type BsnTlv struct {
	Type   uint16
	Length uint16
}

type IBsnTlv interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnTlv) GetType() uint16 {
	return self.Type
}

func (self *BsnTlv) GetLength() uint16 {
	return self.Length
}

func (self *BsnTlv) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeBsnTlv(decoder *goloxi.Decoder) (IBsnTlv, error) {
	_bsntlv := &BsnTlv{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlv packet too short: %d < 4", decoder.Length())
	}
	_bsntlv.Type = uint16(decoder.ReadUint16())
	_bsntlv.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsntlv.Length), 2+2)

	switch _bsntlv.Type {
	case 0:
		return DecodeBsnTlvPort(_bsntlv, decoder)
	case 1:
		return DecodeBsnTlvMac(_bsntlv, decoder)
	case 2:
		return DecodeBsnTlvRxPackets(_bsntlv, decoder)
	case 3:
		return DecodeBsnTlvTxPackets(_bsntlv, decoder)
	case 4:
		return DecodeBsnTlvIpv4(_bsntlv, decoder)
	case 5:
		return DecodeBsnTlvIdleTime(_bsntlv, decoder)
	case 6:
		return DecodeBsnTlvVlanVid(_bsntlv, decoder)
	case 7:
		return DecodeBsnTlvIdleNotification(_bsntlv, decoder)
	case 8:
		return DecodeBsnTlvIdleTimeout(_bsntlv, decoder)
	case 9:
		return DecodeBsnTlvUnicastQueryTimeout(_bsntlv, decoder)
	case 10:
		return DecodeBsnTlvBroadcastQueryTimeout(_bsntlv, decoder)
	case 11:
		return DecodeBsnTlvRequestPackets(_bsntlv, decoder)
	case 12:
		return DecodeBsnTlvReplyPackets(_bsntlv, decoder)
	case 13:
		return DecodeBsnTlvMissPackets(_bsntlv, decoder)
	case 14:
		return DecodeBsnTlvCircuitId(_bsntlv, decoder)
	case 15:
		return DecodeBsnTlvUdfId(_bsntlv, decoder)
	case 16:
		return DecodeBsnTlvUdfAnchor(_bsntlv, decoder)
	case 17:
		return DecodeBsnTlvUdfOffset(_bsntlv, decoder)
	case 18:
		return DecodeBsnTlvUdfLength(_bsntlv, decoder)
	case 19:
		return DecodeBsnTlvVrf(_bsntlv, decoder)
	case 20:
		return DecodeBsnTlvQueueId(_bsntlv, decoder)
	case 21:
		return DecodeBsnTlvQueueWeight(_bsntlv, decoder)
	case 22:
		return DecodeBsnTlvCrcEnabled(_bsntlv, decoder)
	case 23:
		return DecodeBsnTlvExternalIp(_bsntlv, decoder)
	case 24:
		return DecodeBsnTlvExternalMac(_bsntlv, decoder)
	case 25:
		return DecodeBsnTlvExternalNetmask(_bsntlv, decoder)
	case 26:
		return DecodeBsnTlvExternalGatewayIp(_bsntlv, decoder)
	case 27:
		return DecodeBsnTlvInternalMac(_bsntlv, decoder)
	case 28:
		return DecodeBsnTlvInternalGatewayMac(_bsntlv, decoder)
	case 29:
		return DecodeBsnTlvExternalGatewayMac(_bsntlv, decoder)
	case 30:
		return DecodeBsnTlvSamplingRate(_bsntlv, decoder)
	case 31:
		return DecodeBsnTlvHeaderSize(_bsntlv, decoder)
	case 32:
		return DecodeBsnTlvEthSrc(_bsntlv, decoder)
	case 33:
		return DecodeBsnTlvEthDst(_bsntlv, decoder)
	case 34:
		return DecodeBsnTlvIpv4Src(_bsntlv, decoder)
	case 35:
		return DecodeBsnTlvIpv4Dst(_bsntlv, decoder)
	case 36:
		return DecodeBsnTlvUdpSrc(_bsntlv, decoder)
	case 37:
		return DecodeBsnTlvUdpDst(_bsntlv, decoder)
	case 38:
		return DecodeBsnTlvSubAgentId(_bsntlv, decoder)
	case 39:
		return DecodeBsnTlvTxBytes(_bsntlv, decoder)
	case 40:
		return DecodeBsnTlvActorSystemPriority(_bsntlv, decoder)
	case 41:
		return DecodeBsnTlvActorSystemMac(_bsntlv, decoder)
	case 42:
		return DecodeBsnTlvActorPortPriority(_bsntlv, decoder)
	case 43:
		return DecodeBsnTlvActorPortNum(_bsntlv, decoder)
	case 44:
		return DecodeBsnTlvActorKey(_bsntlv, decoder)
	case 45:
		return DecodeBsnTlvConvergenceStatus(_bsntlv, decoder)
	case 47:
		return DecodeBsnTlvPartnerSystemPriority(_bsntlv, decoder)
	case 48:
		return DecodeBsnTlvPartnerSystemMac(_bsntlv, decoder)
	case 49:
		return DecodeBsnTlvPartnerPortPriority(_bsntlv, decoder)
	case 50:
		return DecodeBsnTlvPartnerPortNum(_bsntlv, decoder)
	case 51:
		return DecodeBsnTlvPartnerKey(_bsntlv, decoder)
	case 52:
		return DecodeBsnTlvName(_bsntlv, decoder)
	case 53:
		return DecodeBsnTlvActorState(_bsntlv, decoder)
	case 54:
		return DecodeBsnTlvPartnerState(_bsntlv, decoder)
	case 55:
		return DecodeBsnTlvData(_bsntlv, decoder)
	case 56:
		return DecodeBsnTlvMacMask(_bsntlv, decoder)
	case 57:
		return DecodeBsnTlvPriority(_bsntlv, decoder)
	case 58:
		return DecodeBsnTlvInterval(_bsntlv, decoder)
	case 59:
		return DecodeBsnTlvReference(_bsntlv, decoder)
	case 60:
		return DecodeBsnTlvIpv4Netmask(_bsntlv, decoder)
	case 61:
		return DecodeBsnTlvMplsLabel(_bsntlv, decoder)
	case 62:
		return DecodeBsnTlvMplsControlWord(_bsntlv, decoder)
	case 63:
		return DecodeBsnTlvMplsSequenced(_bsntlv, decoder)
	case 64:
		return DecodeBsnTlvBucket(_bsntlv, decoder)
	case 65:
		return DecodeBsnTlvTcpSrc(_bsntlv, decoder)
	case 66:
		return DecodeBsnTlvTcpDst(_bsntlv, decoder)
	case 67:
		return DecodeBsnTlvIpProto(_bsntlv, decoder)
	case 68:
		return DecodeBsnTlvIcmpType(_bsntlv, decoder)
	case 69:
		return DecodeBsnTlvIcmpCode(_bsntlv, decoder)
	case 70:
		return DecodeBsnTlvIcmpId(_bsntlv, decoder)
	case 71:
		return DecodeBsnTlvRxBytes(_bsntlv, decoder)
	case 72:
		return DecodeBsnTlvVlanPcp(_bsntlv, decoder)
	case 73:
		return DecodeBsnTlvStripVlanOnEgress(_bsntlv, decoder)
	case 74:
		return DecodeBsnTlvSetLoopbackMode(_bsntlv, decoder)
	case 75:
		return DecodeBsnTlvStripMplsL2OnIngress(_bsntlv, decoder)
	case 76:
		return DecodeBsnTlvStripMplsL3OnIngress(_bsntlv, decoder)
	case 77:
		return DecodeBsnTlvVlanVidMask(_bsntlv, decoder)
	case 78:
		return DecodeBsnTlvIgmpSnooping(_bsntlv, decoder)
	case 79:
		return DecodeBsnTlvL2MulticastLookup(_bsntlv, decoder)
	case 80:
		return DecodeBsnTlvGenerationId(_bsntlv, decoder)
	case 81:
		return DecodeBsnTlvAnchor(_bsntlv, decoder)
	case 82:
		return DecodeBsnTlvOffset(_bsntlv, decoder)
	case 83:
		return DecodeBsnTlvNegate(_bsntlv, decoder)
	case 84:
		return DecodeBsnTlvIpv6(_bsntlv, decoder)
	case 85:
		return DecodeBsnTlvDecap(_bsntlv, decoder)
	case 86:
		return DecodeBsnTlvVni(_bsntlv, decoder)
	case 87:
		return DecodeBsnTlvMcgTypeVxlan(_bsntlv, decoder)
	case 88:
		return DecodeBsnTlvPortVxlanMode(_bsntlv, decoder)
	case 89:
		return DecodeBsnTlvRateUnit(_bsntlv, decoder)
	case 90:
		return DecodeBsnTlvBroadcastRate(_bsntlv, decoder)
	case 91:
		return DecodeBsnTlvKnownMulticastRate(_bsntlv, decoder)
	case 92:
		return DecodeBsnTlvUnknownMulticastRate(_bsntlv, decoder)
	case 93:
		return DecodeBsnTlvUnicastRate(_bsntlv, decoder)
	case 94:
		return DecodeBsnTlvNexthopTypeVxlan(_bsntlv, decoder)
	case 95:
		return DecodeBsnTlvMulticastInterfaceId(_bsntlv, decoder)
	case 96:
		return DecodeBsnTlvUsePacketState(_bsntlv, decoder)
	case 97:
		return DecodeBsnTlvStatus(_bsntlv, decoder)
	case 98:
		return DecodeBsnTlvVlanMacList(_bsntlv, decoder)
	case 99:
		return DecodeBsnTlvVfi(_bsntlv, decoder)
	case 100:
		return DecodeBsnTlvHashSeed(_bsntlv, decoder)
	case 101:
		return DecodeBsnTlvHashType(_bsntlv, decoder)
	case 102:
		return DecodeBsnTlvHashPacketType(_bsntlv, decoder)
	case 103:
		return DecodeBsnTlvHashPacketField(_bsntlv, decoder)
	case 104:
		return DecodeBsnTlvHashGtpHeaderMatch(_bsntlv, decoder)
	case 105:
		return DecodeBsnTlvHashGtpPortMatch(_bsntlv, decoder)
	case 106:
		return DecodeBsnTlvUntagged(_bsntlv, decoder)
	case 107:
		return DecodeBsnTlvVfpClassId(_bsntlv, decoder)
	case 108:
		return DecodeBsnTlvQosPriority(_bsntlv, decoder)
	case 109:
		return DecodeBsnTlvParentPort(_bsntlv, decoder)
	case 110:
		return DecodeBsnTlvLoopbackPort(_bsntlv, decoder)
	case 111:
		return DecodeBsnTlvVpnKey(_bsntlv, decoder)
	case 112:
		return DecodeBsnTlvDscp(_bsntlv, decoder)
	case 113:
		return DecodeBsnTlvTtl(_bsntlv, decoder)
	case 114:
		return DecodeBsnTlvNextHopMac(_bsntlv, decoder)
	case 115:
		return DecodeBsnTlvNextHopIpv4(_bsntlv, decoder)
	case 116:
		return DecodeBsnTlvRateLimit(_bsntlv, decoder)
	case 117:
		return DecodeBsnTlvVxlanEgressLag(_bsntlv, decoder)
	case 118:
		return DecodeBsnTlvCpuLag(_bsntlv, decoder)
	case 119:
		return DecodeBsnTlvUint64List(_bsntlv, decoder)
	case 120:
		return DecodeBsnTlvDisableSrcMacCheck(_bsntlv, decoder)
	case 121:
		return DecodeBsnTlvDrop(_bsntlv, decoder)
	case 122:
		return DecodeBsnTlvIpv6Prefix(_bsntlv, decoder)
	case 123:
		return DecodeBsnTlvNdpOffload(_bsntlv, decoder)
	case 124:
		return DecodeBsnTlvNdpStatic(_bsntlv, decoder)
	case 125:
		return DecodeBsnTlvIcmpv6Chksum(_bsntlv, decoder)
	case 126:
		return DecodeBsnTlvIpv6Src(_bsntlv, decoder)
	case 127:
		return DecodeBsnTlvIpv6Dst(_bsntlv, decoder)
	case 128:
		return DecodeBsnTlvPushVlanOnIngress(_bsntlv, decoder)
	case 129:
		return DecodeBsnTlvApplyPackets(_bsntlv, decoder)
	case 130:
		return DecodeBsnTlvApplyBytes(_bsntlv, decoder)
	case 131:
		return DecodeBsnTlvEthType(_bsntlv, decoder)
	case 132:
		return DecodeBsnTlvEcn(_bsntlv, decoder)
	case 133:
		return DecodeBsnTlvTcpFlags(_bsntlv, decoder)
	case 134:
		return DecodeBsnTlvL3InterfaceClassId(_bsntlv, decoder)
	case 135:
		return DecodeBsnTlvL3SrcClassId(_bsntlv, decoder)
	case 136:
		return DecodeBsnTlvL3DstClassId(_bsntlv, decoder)
	case 137:
		return DecodeBsnTlvEgressOnly(_bsntlv, decoder)
	case 138:
		return DecodeBsnTlvIngressPortGroupId(_bsntlv, decoder)
	case 139:
		return DecodeBsnTlvEgressPortGroupId(_bsntlv, decoder)
	case 140:
		return DecodeBsnTlvDataMask(_bsntlv, decoder)
	case 141:
		return DecodeBsnTlvPortUsage(_bsntlv, decoder)
	case 142:
		return DecodeBsnTlvTunnelCapability(_bsntlv, decoder)
	case 143:
		return DecodeBsnTlvEnhancedHashCapability(_bsntlv, decoder)
	case 144:
		return DecodeBsnTlvAutoNegotiation(_bsntlv, decoder)
	case 145:
		return DecodeBsnTlvHashAlgorithm(_bsntlv, decoder)
	case 146:
		return DecodeBsnTlvLoopbackMode(_bsntlv, decoder)
	case 147:
		return DecodeBsnTlvNoArpResponse(_bsntlv, decoder)
	case 148:
		return DecodeBsnTlvNoNsResponse(_bsntlv, decoder)
	case 149:
		return DecodeBsnTlvForwardErrorCorrection(_bsntlv, decoder)
	case 150:
		return DecodeBsnTlvOpticsAlwaysEnabled(_bsntlv, decoder)
	case 151:
		return DecodeBsnTlvForceLinkUp(_bsntlv, decoder)
	case 152:
		return DecodeBsnTlvRestServer(_bsntlv, decoder)
	case 153:
		return DecodeBsnTlvUriScheme(_bsntlv, decoder)
	case 154:
		return DecodeBsnTlvTimestamp(_bsntlv, decoder)
	case 155:
		return DecodeBsnTlvRecordPackets(_bsntlv, decoder)
	case 156:
		return DecodeBsnTlvPortSpeedGbps(_bsntlv, decoder)
	case 157:
		return DecodeBsnTlvOuterSrcMac(_bsntlv, decoder)
	case 158:
		return DecodeBsnTlvVirtual(_bsntlv, decoder)
	case 159:
		return DecodeBsnTlvPduaRxInstance(_bsntlv, decoder)
	case 160:
		return DecodeBsnTlvLagOptions(_bsntlv, decoder)
	case 161:
		return DecodeBsnTlvRoutingParam(_bsntlv, decoder)
	case 162:
		return DecodeBsnTlvPushVlanOnEgress(_bsntlv, decoder)
	case 163:
		return DecodeBsnTlvFlood(_bsntlv, decoder)
	case 164:
		return DecodeBsnTlvUpgrade(_bsntlv, decoder)
	case 165:
		return DecodeBsnTlvFabricPortRole(_bsntlv, decoder)
	case 166:
		return DecodeBsnTlvUserConfigured(_bsntlv, decoder)
	case 167:
		return DecodeBsnTlvUint32(_bsntlv, decoder)
	case 168:
		return DecodeBsnTlvL3(_bsntlv, decoder)
	case 169:
		return DecodeBsnTlvIpTunnelType(_bsntlv, decoder)
	case 170:
		return DecodeBsnTlvMulticastPacket(_bsntlv, decoder)
	case 171:
		return DecodeBsnTlvPimDr(_bsntlv, decoder)
	case 172:
		return DecodeBsnTlvPassive(_bsntlv, decoder)
	case 173:
		return DecodeBsnTlvIdentifier(_bsntlv, decoder)
	case 174:
		return DecodeBsnTlvMultiplier(_bsntlv, decoder)
	case 175:
		return DecodeBsnTlvEncap(_bsntlv, decoder)
	case 176:
		return DecodeBsnTlvBfdEndpoint(_bsntlv, decoder)
	case 177:
		return DecodeBsnTlvBfdState(_bsntlv, decoder)
	case 178:
		return DecodeBsnTlvLrAllEnabled(_bsntlv, decoder)
	case 179:
		return DecodeBsnTlvPortMode(_bsntlv, decoder)
	case 180:
		return DecodeBsnTlvUdfCapability(_bsntlv, decoder)
	case 181:
		return DecodeBsnTlvPimHelloFlood(_bsntlv, decoder)
	case 182:
		return DecodeBsnTlvFlowClassify(_bsntlv, decoder)
	case 183:
		return DecodeBsnTlvFlowIdentifier(_bsntlv, decoder)
	case 184:
		return DecodeBsnTlvFlowClassifier(_bsntlv, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnTlv'", _bsntlv.Type)
	}
}

func NewBsnTlv(_type uint16) *BsnTlv {
	obj := &BsnTlv{}
	obj.Type = _type
	return obj
}

type BsnTlvActorKey struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorKey, error) {
	_bsntlvactorkey := &BsnTlvActorKey{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorKey packet too short: %d < 2", decoder.Length())
	}
	_bsntlvactorkey.Value = uint16(decoder.ReadUint16())
	return _bsntlvactorkey, nil
}

func NewBsnTlvActorKey() *BsnTlvActorKey {
	obj := &BsnTlvActorKey{
		BsnTlv: NewBsnTlv(44),
	}
	return obj
}

type BsnTlvActorPortNum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorPortNum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorPortNum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorPortNum, error) {
	_bsntlvactorportnum := &BsnTlvActorPortNum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorPortNum packet too short: %d < 2", decoder.Length())
	}
	_bsntlvactorportnum.Value = uint16(decoder.ReadUint16())
	return _bsntlvactorportnum, nil
}

func NewBsnTlvActorPortNum() *BsnTlvActorPortNum {
	obj := &BsnTlvActorPortNum{
		BsnTlv: NewBsnTlv(43),
	}
	return obj
}

type BsnTlvActorPortPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorPortPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorPortPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorPortPriority, error) {
	_bsntlvactorportpriority := &BsnTlvActorPortPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorPortPriority packet too short: %d < 2", decoder.Length())
	}
	_bsntlvactorportpriority.Value = uint16(decoder.ReadUint16())
	return _bsntlvactorportpriority, nil
}

func NewBsnTlvActorPortPriority() *BsnTlvActorPortPriority {
	obj := &BsnTlvActorPortPriority{
		BsnTlv: NewBsnTlv(42),
	}
	return obj
}

type BsnTlvActorState struct {
	*BsnTlv
	Value BsnLacpState
}

func (self *BsnTlvActorState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorState, error) {
	_bsntlvactorstate := &BsnTlvActorState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvActorState packet too short: %d < 1", decoder.Length())
	}
	_bsntlvactorstate.Value = BsnLacpState(decoder.ReadByte())
	return _bsntlvactorstate, nil
}

func NewBsnTlvActorState() *BsnTlvActorState {
	obj := &BsnTlvActorState{
		BsnTlv: NewBsnTlv(53),
	}
	return obj
}

type BsnTlvActorSystemMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvActorSystemMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorSystemMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorSystemMac, error) {
	_bsntlvactorsystemmac := &BsnTlvActorSystemMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvActorSystemMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvactorsystemmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvactorsystemmac, nil
}

func NewBsnTlvActorSystemMac() *BsnTlvActorSystemMac {
	obj := &BsnTlvActorSystemMac{
		BsnTlv: NewBsnTlv(41),
	}
	return obj
}

type BsnTlvActorSystemPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorSystemPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvActorSystemPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorSystemPriority, error) {
	_bsntlvactorsystempriority := &BsnTlvActorSystemPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorSystemPriority packet too short: %d < 2", decoder.Length())
	}
	_bsntlvactorsystempriority.Value = uint16(decoder.ReadUint16())
	return _bsntlvactorsystempriority, nil
}

func NewBsnTlvActorSystemPriority() *BsnTlvActorSystemPriority {
	obj := &BsnTlvActorSystemPriority{
		BsnTlv: NewBsnTlv(40),
	}
	return obj
}

type BsnTlvAnchor struct {
	*BsnTlv
	Value BsnAnchor
}

func (self *BsnTlvAnchor) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvAnchor(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvAnchor, error) {
	_bsntlvanchor := &BsnTlvAnchor{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvAnchor packet too short: %d < 2", decoder.Length())
	}
	_bsntlvanchor.Value = BsnAnchor(decoder.ReadUint16())
	return _bsntlvanchor, nil
}

func NewBsnTlvAnchor() *BsnTlvAnchor {
	obj := &BsnTlvAnchor{
		BsnTlv: NewBsnTlv(81),
	}
	return obj
}

type BsnTlvApplyBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvApplyBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvApplyBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvApplyBytes, error) {
	_bsntlvapplybytes := &BsnTlvApplyBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvApplyBytes packet too short: %d < 8", decoder.Length())
	}
	_bsntlvapplybytes.Value = uint64(decoder.ReadUint64())
	return _bsntlvapplybytes, nil
}

func NewBsnTlvApplyBytes() *BsnTlvApplyBytes {
	obj := &BsnTlvApplyBytes{
		BsnTlv: NewBsnTlv(130),
	}
	return obj
}

type BsnTlvApplyPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvApplyPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvApplyPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvApplyPackets, error) {
	_bsntlvapplypackets := &BsnTlvApplyPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvApplyPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvapplypackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvapplypackets, nil
}

func NewBsnTlvApplyPackets() *BsnTlvApplyPackets {
	obj := &BsnTlvApplyPackets{
		BsnTlv: NewBsnTlv(129),
	}
	return obj
}

type BsnTlvAutoNegotiation struct {
	*BsnTlv
	Value BsnAutoNegotiationType
}

func (self *BsnTlvAutoNegotiation) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvAutoNegotiation(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvAutoNegotiation, error) {
	_bsntlvautonegotiation := &BsnTlvAutoNegotiation{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvAutoNegotiation packet too short: %d < 1", decoder.Length())
	}
	_bsntlvautonegotiation.Value = BsnAutoNegotiationType(decoder.ReadByte())
	return _bsntlvautonegotiation, nil
}

func NewBsnTlvAutoNegotiation() *BsnTlvAutoNegotiation {
	obj := &BsnTlvAutoNegotiation{
		BsnTlv: NewBsnTlv(144),
	}
	return obj
}

type BsnTlvBfdEndpoint struct {
	*BsnTlv
	Value BsnBfdEndpoint
}

func (self *BsnTlvBfdEndpoint) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvBfdEndpoint(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBfdEndpoint, error) {
	_bsntlvbfdendpoint := &BsnTlvBfdEndpoint{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvBfdEndpoint packet too short: %d < 1", decoder.Length())
	}
	_bsntlvbfdendpoint.Value = BsnBfdEndpoint(decoder.ReadByte())
	return _bsntlvbfdendpoint, nil
}

func NewBsnTlvBfdEndpoint() *BsnTlvBfdEndpoint {
	obj := &BsnTlvBfdEndpoint{
		BsnTlv: NewBsnTlv(176),
	}
	return obj
}

type BsnTlvBfdState struct {
	*BsnTlv
	Value BsnBfdEndpointState
}

func (self *BsnTlvBfdState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvBfdState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBfdState, error) {
	_bsntlvbfdstate := &BsnTlvBfdState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvBfdState packet too short: %d < 1", decoder.Length())
	}
	_bsntlvbfdstate.Value = BsnBfdEndpointState(decoder.ReadByte())
	return _bsntlvbfdstate, nil
}

func NewBsnTlvBfdState() *BsnTlvBfdState {
	obj := &BsnTlvBfdState{
		BsnTlv: NewBsnTlv(177),
	}
	return obj
}

type BsnTlvBroadcastQueryTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvBroadcastQueryTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvBroadcastQueryTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBroadcastQueryTimeout, error) {
	_bsntlvbroadcastquerytimeout := &BsnTlvBroadcastQueryTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvBroadcastQueryTimeout packet too short: %d < 4", decoder.Length())
	}
	_bsntlvbroadcastquerytimeout.Value = uint32(decoder.ReadUint32())
	return _bsntlvbroadcastquerytimeout, nil
}

func NewBsnTlvBroadcastQueryTimeout() *BsnTlvBroadcastQueryTimeout {
	obj := &BsnTlvBroadcastQueryTimeout{
		BsnTlv: NewBsnTlv(10),
	}
	return obj
}

type BsnTlvBroadcastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvBroadcastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvBroadcastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBroadcastRate, error) {
	_bsntlvbroadcastrate := &BsnTlvBroadcastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvBroadcastRate packet too short: %d < 4", decoder.Length())
	}
	_bsntlvbroadcastrate.Value = uint32(decoder.ReadUint32())
	return _bsntlvbroadcastrate, nil
}

func NewBsnTlvBroadcastRate() *BsnTlvBroadcastRate {
	obj := &BsnTlvBroadcastRate{
		BsnTlv: NewBsnTlv(90),
	}
	return obj
}

type BsnTlvBucket struct {
	*BsnTlv
	Value []IBsnTlv
}

func (self *BsnTlvBucket) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvBucket(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBucket, error) {
	_bsntlvbucket := &BsnTlvBucket{BsnTlv: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsntlvbucket.Value = append(_bsntlvbucket.Value, item)
	}
	return _bsntlvbucket, nil
}

func NewBsnTlvBucket() *BsnTlvBucket {
	obj := &BsnTlvBucket{
		BsnTlv: NewBsnTlv(64),
	}
	return obj
}

type BsnTlvCircuitId struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvCircuitId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvCircuitId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCircuitId, error) {
	_bsntlvcircuitid := &BsnTlvCircuitId{BsnTlv: parent}
	_bsntlvcircuitid.Value = decoder.Read(decoder.Length())
	return _bsntlvcircuitid, nil
}

func NewBsnTlvCircuitId() *BsnTlvCircuitId {
	obj := &BsnTlvCircuitId{
		BsnTlv: NewBsnTlv(14),
	}
	return obj
}

type BsnTlvConvergenceStatus struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvConvergenceStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvConvergenceStatus(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvConvergenceStatus, error) {
	_bsntlvconvergencestatus := &BsnTlvConvergenceStatus{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvConvergenceStatus packet too short: %d < 1", decoder.Length())
	}
	_bsntlvconvergencestatus.Value = uint8(decoder.ReadByte())
	return _bsntlvconvergencestatus, nil
}

func NewBsnTlvConvergenceStatus() *BsnTlvConvergenceStatus {
	obj := &BsnTlvConvergenceStatus{
		BsnTlv: NewBsnTlv(45),
	}
	return obj
}

type BsnTlvCpuLag struct {
	*BsnTlv
}

func (self *BsnTlvCpuLag) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvCpuLag(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCpuLag, error) {
	_bsntlvcpulag := &BsnTlvCpuLag{BsnTlv: parent}
	return _bsntlvcpulag, nil
}

func NewBsnTlvCpuLag() *BsnTlvCpuLag {
	obj := &BsnTlvCpuLag{
		BsnTlv: NewBsnTlv(118),
	}
	return obj
}

type BsnTlvCrcEnabled struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvCrcEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvCrcEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCrcEnabled, error) {
	_bsntlvcrcenabled := &BsnTlvCrcEnabled{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvCrcEnabled packet too short: %d < 1", decoder.Length())
	}
	_bsntlvcrcenabled.Value = uint8(decoder.ReadByte())
	return _bsntlvcrcenabled, nil
}

func NewBsnTlvCrcEnabled() *BsnTlvCrcEnabled {
	obj := &BsnTlvCrcEnabled{
		BsnTlv: NewBsnTlv(22),
	}
	return obj
}

type BsnTlvData struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvData) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvData(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvData, error) {
	_bsntlvdata := &BsnTlvData{BsnTlv: parent}
	_bsntlvdata.Value = decoder.Read(decoder.Length())
	return _bsntlvdata, nil
}

func NewBsnTlvData() *BsnTlvData {
	obj := &BsnTlvData{
		BsnTlv: NewBsnTlv(55),
	}
	return obj
}

type BsnTlvDataMask struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvDataMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvDataMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDataMask, error) {
	_bsntlvdatamask := &BsnTlvDataMask{BsnTlv: parent}
	_bsntlvdatamask.Value = decoder.Read(decoder.Length())
	return _bsntlvdatamask, nil
}

func NewBsnTlvDataMask() *BsnTlvDataMask {
	obj := &BsnTlvDataMask{
		BsnTlv: NewBsnTlv(140),
	}
	return obj
}

type BsnTlvDecap struct {
	*BsnTlv
	Value BsnDecap
}

func (self *BsnTlvDecap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvDecap(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDecap, error) {
	_bsntlvdecap := &BsnTlvDecap{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvDecap packet too short: %d < 2", decoder.Length())
	}
	_bsntlvdecap.Value = BsnDecap(decoder.ReadUint16())
	return _bsntlvdecap, nil
}

func NewBsnTlvDecap() *BsnTlvDecap {
	obj := &BsnTlvDecap{
		BsnTlv: NewBsnTlv(85),
	}
	return obj
}

type BsnTlvDisableSrcMacCheck struct {
	*BsnTlv
}

func (self *BsnTlvDisableSrcMacCheck) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvDisableSrcMacCheck(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDisableSrcMacCheck, error) {
	_bsntlvdisablesrcmaccheck := &BsnTlvDisableSrcMacCheck{BsnTlv: parent}
	return _bsntlvdisablesrcmaccheck, nil
}

func NewBsnTlvDisableSrcMacCheck() *BsnTlvDisableSrcMacCheck {
	obj := &BsnTlvDisableSrcMacCheck{
		BsnTlv: NewBsnTlv(120),
	}
	return obj
}

type BsnTlvDrop struct {
	*BsnTlv
}

func (self *BsnTlvDrop) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvDrop(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDrop, error) {
	_bsntlvdrop := &BsnTlvDrop{BsnTlv: parent}
	return _bsntlvdrop, nil
}

func NewBsnTlvDrop() *BsnTlvDrop {
	obj := &BsnTlvDrop{
		BsnTlv: NewBsnTlv(121),
	}
	return obj
}

type BsnTlvDscp struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvDscp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvDscp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDscp, error) {
	_bsntlvdscp := &BsnTlvDscp{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvDscp packet too short: %d < 2", decoder.Length())
	}
	_bsntlvdscp.Value = uint16(decoder.ReadUint16())
	return _bsntlvdscp, nil
}

func NewBsnTlvDscp() *BsnTlvDscp {
	obj := &BsnTlvDscp{
		BsnTlv: NewBsnTlv(112),
	}
	return obj
}

type BsnTlvEcn struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvEcn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEcn(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEcn, error) {
	_bsntlvecn := &BsnTlvEcn{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvEcn packet too short: %d < 1", decoder.Length())
	}
	_bsntlvecn.Value = uint8(decoder.ReadByte())
	return _bsntlvecn, nil
}

func NewBsnTlvEcn() *BsnTlvEcn {
	obj := &BsnTlvEcn{
		BsnTlv: NewBsnTlv(132),
	}
	return obj
}

type BsnTlvEgressOnly struct {
	*BsnTlv
}

func (self *BsnTlvEgressOnly) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEgressOnly(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEgressOnly, error) {
	_bsntlvegressonly := &BsnTlvEgressOnly{BsnTlv: parent}
	return _bsntlvegressonly, nil
}

func NewBsnTlvEgressOnly() *BsnTlvEgressOnly {
	obj := &BsnTlvEgressOnly{
		BsnTlv: NewBsnTlv(137),
	}
	return obj
}

type BsnTlvEgressPortGroupId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvEgressPortGroupId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEgressPortGroupId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEgressPortGroupId, error) {
	_bsntlvegressportgroupid := &BsnTlvEgressPortGroupId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvEgressPortGroupId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvegressportgroupid.Value = uint32(decoder.ReadUint32())
	return _bsntlvegressportgroupid, nil
}

func NewBsnTlvEgressPortGroupId() *BsnTlvEgressPortGroupId {
	obj := &BsnTlvEgressPortGroupId{
		BsnTlv: NewBsnTlv(139),
	}
	return obj
}

type BsnTlvEncap struct {
	*BsnTlv
	Value BsnEncap
}

func (self *BsnTlvEncap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEncap(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEncap, error) {
	_bsntlvencap := &BsnTlvEncap{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvEncap packet too short: %d < 1", decoder.Length())
	}
	_bsntlvencap.Value = BsnEncap(decoder.ReadByte())
	return _bsntlvencap, nil
}

func NewBsnTlvEncap() *BsnTlvEncap {
	obj := &BsnTlvEncap{
		BsnTlv: NewBsnTlv(175),
	}
	return obj
}

type BsnTlvEnhancedHashCapability struct {
	*BsnTlv
	Value BsnEnhancedHashType
}

func (self *BsnTlvEnhancedHashCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEnhancedHashCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEnhancedHashCapability, error) {
	_bsntlvenhancedhashcapability := &BsnTlvEnhancedHashCapability{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvEnhancedHashCapability packet too short: %d < 8", decoder.Length())
	}
	_bsntlvenhancedhashcapability.Value = BsnEnhancedHashType(decoder.ReadUint64())
	return _bsntlvenhancedhashcapability, nil
}

func NewBsnTlvEnhancedHashCapability() *BsnTlvEnhancedHashCapability {
	obj := &BsnTlvEnhancedHashCapability{
		BsnTlv: NewBsnTlv(143),
	}
	return obj
}

type BsnTlvEthDst struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvEthDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEthDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthDst, error) {
	_bsntlvethdst := &BsnTlvEthDst{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvEthDst packet too short: %d < 6", decoder.Length())
	}
	_bsntlvethdst.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvethdst, nil
}

func NewBsnTlvEthDst() *BsnTlvEthDst {
	obj := &BsnTlvEthDst{
		BsnTlv: NewBsnTlv(33),
	}
	return obj
}

type BsnTlvEthSrc struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvEthSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEthSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthSrc, error) {
	_bsntlvethsrc := &BsnTlvEthSrc{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvEthSrc packet too short: %d < 6", decoder.Length())
	}
	_bsntlvethsrc.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvethsrc, nil
}

func NewBsnTlvEthSrc() *BsnTlvEthSrc {
	obj := &BsnTlvEthSrc{
		BsnTlv: NewBsnTlv(32),
	}
	return obj
}

type BsnTlvEthType struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvEthType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvEthType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthType, error) {
	_bsntlvethtype := &BsnTlvEthType{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvEthType packet too short: %d < 2", decoder.Length())
	}
	_bsntlvethtype.Value = uint16(decoder.ReadUint16())
	return _bsntlvethtype, nil
}

func NewBsnTlvEthType() *BsnTlvEthType {
	obj := &BsnTlvEthType{
		BsnTlv: NewBsnTlv(131),
	}
	return obj
}

type BsnTlvExternalGatewayIp struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalGatewayIp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvExternalGatewayIp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalGatewayIp, error) {
	_bsntlvexternalgatewayip := &BsnTlvExternalGatewayIp{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalGatewayIp packet too short: %d < 4", decoder.Length())
	}
	_bsntlvexternalgatewayip.Value = net.IP(decoder.Read(4))
	return _bsntlvexternalgatewayip, nil
}

func NewBsnTlvExternalGatewayIp() *BsnTlvExternalGatewayIp {
	obj := &BsnTlvExternalGatewayIp{
		BsnTlv: NewBsnTlv(26),
	}
	return obj
}

type BsnTlvExternalGatewayMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvExternalGatewayMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvExternalGatewayMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalGatewayMac, error) {
	_bsntlvexternalgatewaymac := &BsnTlvExternalGatewayMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvExternalGatewayMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvexternalgatewaymac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvexternalgatewaymac, nil
}

func NewBsnTlvExternalGatewayMac() *BsnTlvExternalGatewayMac {
	obj := &BsnTlvExternalGatewayMac{
		BsnTlv: NewBsnTlv(29),
	}
	return obj
}

type BsnTlvExternalIp struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalIp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvExternalIp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalIp, error) {
	_bsntlvexternalip := &BsnTlvExternalIp{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalIp packet too short: %d < 4", decoder.Length())
	}
	_bsntlvexternalip.Value = net.IP(decoder.Read(4))
	return _bsntlvexternalip, nil
}

func NewBsnTlvExternalIp() *BsnTlvExternalIp {
	obj := &BsnTlvExternalIp{
		BsnTlv: NewBsnTlv(23),
	}
	return obj
}

type BsnTlvExternalMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvExternalMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvExternalMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalMac, error) {
	_bsntlvexternalmac := &BsnTlvExternalMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvExternalMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvexternalmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvexternalmac, nil
}

func NewBsnTlvExternalMac() *BsnTlvExternalMac {
	obj := &BsnTlvExternalMac{
		BsnTlv: NewBsnTlv(24),
	}
	return obj
}

type BsnTlvExternalNetmask struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalNetmask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvExternalNetmask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalNetmask, error) {
	_bsntlvexternalnetmask := &BsnTlvExternalNetmask{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalNetmask packet too short: %d < 4", decoder.Length())
	}
	_bsntlvexternalnetmask.Value = net.IP(decoder.Read(4))
	return _bsntlvexternalnetmask, nil
}

func NewBsnTlvExternalNetmask() *BsnTlvExternalNetmask {
	obj := &BsnTlvExternalNetmask{
		BsnTlv: NewBsnTlv(25),
	}
	return obj
}

type BsnTlvFabricPortRole struct {
	*BsnTlv
	Value BsnFabricPortRole
}

func (self *BsnTlvFabricPortRole) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvFabricPortRole(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFabricPortRole, error) {
	_bsntlvfabricportrole := &BsnTlvFabricPortRole{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvFabricPortRole packet too short: %d < 2", decoder.Length())
	}
	_bsntlvfabricportrole.Value = BsnFabricPortRole(decoder.ReadUint16())
	return _bsntlvfabricportrole, nil
}

func NewBsnTlvFabricPortRole() *BsnTlvFabricPortRole {
	obj := &BsnTlvFabricPortRole{
		BsnTlv: NewBsnTlv(165),
	}
	return obj
}

type BsnTlvFlood struct {
	*BsnTlv
}

func (self *BsnTlvFlood) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvFlood(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlood, error) {
	_bsntlvflood := &BsnTlvFlood{BsnTlv: parent}
	return _bsntlvflood, nil
}

func NewBsnTlvFlood() *BsnTlvFlood {
	obj := &BsnTlvFlood{
		BsnTlv: NewBsnTlv(163),
	}
	return obj
}

type BsnTlvFlowClassifier struct {
	*BsnTlv
	Value BsnFlowClassifier
}

func (self *BsnTlvFlowClassifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvFlowClassifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowClassifier, error) {
	_bsntlvflowclassifier := &BsnTlvFlowClassifier{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvFlowClassifier packet too short: %d < 2", decoder.Length())
	}
	_bsntlvflowclassifier.Value = BsnFlowClassifier(decoder.ReadUint16())
	return _bsntlvflowclassifier, nil
}

func NewBsnTlvFlowClassifier() *BsnTlvFlowClassifier {
	obj := &BsnTlvFlowClassifier{
		BsnTlv: NewBsnTlv(184),
	}
	return obj
}

type BsnTlvFlowClassify struct {
	*BsnTlv
}

func (self *BsnTlvFlowClassify) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvFlowClassify(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowClassify, error) {
	_bsntlvflowclassify := &BsnTlvFlowClassify{BsnTlv: parent}
	return _bsntlvflowclassify, nil
}

func NewBsnTlvFlowClassify() *BsnTlvFlowClassify {
	obj := &BsnTlvFlowClassify{
		BsnTlv: NewBsnTlv(182),
	}
	return obj
}

type BsnTlvFlowIdentifier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvFlowIdentifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvFlowIdentifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowIdentifier, error) {
	_bsntlvflowidentifier := &BsnTlvFlowIdentifier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvFlowIdentifier packet too short: %d < 4", decoder.Length())
	}
	_bsntlvflowidentifier.Value = uint32(decoder.ReadUint32())
	return _bsntlvflowidentifier, nil
}

func NewBsnTlvFlowIdentifier() *BsnTlvFlowIdentifier {
	obj := &BsnTlvFlowIdentifier{
		BsnTlv: NewBsnTlv(183),
	}
	return obj
}

type BsnTlvForceLinkUp struct {
	*BsnTlv
}

func (self *BsnTlvForceLinkUp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvForceLinkUp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvForceLinkUp, error) {
	_bsntlvforcelinkup := &BsnTlvForceLinkUp{BsnTlv: parent}
	return _bsntlvforcelinkup, nil
}

func NewBsnTlvForceLinkUp() *BsnTlvForceLinkUp {
	obj := &BsnTlvForceLinkUp{
		BsnTlv: NewBsnTlv(151),
	}
	return obj
}

type BsnTlvForwardErrorCorrection struct {
	*BsnTlv
	Value BsnForwardErrorCorrectionType
}

func (self *BsnTlvForwardErrorCorrection) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvForwardErrorCorrection(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvForwardErrorCorrection, error) {
	_bsntlvforwarderrorcorrection := &BsnTlvForwardErrorCorrection{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvForwardErrorCorrection packet too short: %d < 1", decoder.Length())
	}
	_bsntlvforwarderrorcorrection.Value = BsnForwardErrorCorrectionType(decoder.ReadByte())
	return _bsntlvforwarderrorcorrection, nil
}

func NewBsnTlvForwardErrorCorrection() *BsnTlvForwardErrorCorrection {
	obj := &BsnTlvForwardErrorCorrection{
		BsnTlv: NewBsnTlv(149),
	}
	return obj
}

type BsnTlvGenerationId struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvGenerationId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvGenerationId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvGenerationId, error) {
	_bsntlvgenerationid := &BsnTlvGenerationId{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvGenerationId packet too short: %d < 8", decoder.Length())
	}
	_bsntlvgenerationid.Value = uint64(decoder.ReadUint64())
	return _bsntlvgenerationid, nil
}

func NewBsnTlvGenerationId() *BsnTlvGenerationId {
	obj := &BsnTlvGenerationId{
		BsnTlv: NewBsnTlv(80),
	}
	return obj
}

type BsnTlvHashAlgorithm struct {
	*BsnTlv
	Value BsnHashAlgorithmType
}

func (self *BsnTlvHashAlgorithm) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashAlgorithm(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashAlgorithm, error) {
	_bsntlvhashalgorithm := &BsnTlvHashAlgorithm{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvHashAlgorithm packet too short: %d < 2", decoder.Length())
	}
	_bsntlvhashalgorithm.Value = BsnHashAlgorithmType(decoder.ReadUint16())
	return _bsntlvhashalgorithm, nil
}

func NewBsnTlvHashAlgorithm() *BsnTlvHashAlgorithm {
	obj := &BsnTlvHashAlgorithm{
		BsnTlv: NewBsnTlv(145),
	}
	return obj
}

type BsnTlvHashGtpHeaderMatch struct {
	*BsnTlv
	FirstHeaderByte uint8
	FirstHeaderMask uint8
}

func (self *BsnTlvHashGtpHeaderMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.FirstHeaderByte))
	encoder.PutUint8(uint8(self.FirstHeaderMask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashGtpHeaderMatch(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashGtpHeaderMatch, error) {
	_bsntlvhashgtpheadermatch := &BsnTlvHashGtpHeaderMatch{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvHashGtpHeaderMatch packet too short: %d < 2", decoder.Length())
	}
	_bsntlvhashgtpheadermatch.FirstHeaderByte = uint8(decoder.ReadByte())
	_bsntlvhashgtpheadermatch.FirstHeaderMask = uint8(decoder.ReadByte())
	return _bsntlvhashgtpheadermatch, nil
}

func NewBsnTlvHashGtpHeaderMatch() *BsnTlvHashGtpHeaderMatch {
	obj := &BsnTlvHashGtpHeaderMatch{
		BsnTlv: NewBsnTlv(104),
	}
	return obj
}

type BsnTlvHashGtpPortMatch struct {
	*BsnTlv
	Match   BsnHashGtpPortMatch
	SrcPort uint16
	DstPort uint16
}

func (self *BsnTlvHashGtpPortMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Match))
	encoder.PutUint16(uint16(self.SrcPort))
	encoder.PutUint16(uint16(self.DstPort))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashGtpPortMatch(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashGtpPortMatch, error) {
	_bsntlvhashgtpportmatch := &BsnTlvHashGtpPortMatch{BsnTlv: parent}
	if decoder.Length() < 5 {
		return nil, fmt.Errorf("BsnTlvHashGtpPortMatch packet too short: %d < 5", decoder.Length())
	}
	_bsntlvhashgtpportmatch.Match = BsnHashGtpPortMatch(decoder.ReadByte())
	_bsntlvhashgtpportmatch.SrcPort = uint16(decoder.ReadUint16())
	_bsntlvhashgtpportmatch.DstPort = uint16(decoder.ReadUint16())
	return _bsntlvhashgtpportmatch, nil
}

func NewBsnTlvHashGtpPortMatch() *BsnTlvHashGtpPortMatch {
	obj := &BsnTlvHashGtpPortMatch{
		BsnTlv: NewBsnTlv(105),
	}
	return obj
}

type BsnTlvHashPacketField struct {
	*BsnTlv
	Value BsnHashPacketField
}

func (self *BsnTlvHashPacketField) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashPacketField(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashPacketField, error) {
	_bsntlvhashpacketfield := &BsnTlvHashPacketField{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvHashPacketField packet too short: %d < 8", decoder.Length())
	}
	_bsntlvhashpacketfield.Value = BsnHashPacketField(decoder.ReadUint64())
	return _bsntlvhashpacketfield, nil
}

func NewBsnTlvHashPacketField() *BsnTlvHashPacketField {
	obj := &BsnTlvHashPacketField{
		BsnTlv: NewBsnTlv(103),
	}
	return obj
}

type BsnTlvHashPacketType struct {
	*BsnTlv
	Value BsnHashPacketType
}

func (self *BsnTlvHashPacketType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashPacketType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashPacketType, error) {
	_bsntlvhashpackettype := &BsnTlvHashPacketType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvHashPacketType packet too short: %d < 1", decoder.Length())
	}
	_bsntlvhashpackettype.Value = BsnHashPacketType(decoder.ReadByte())
	return _bsntlvhashpackettype, nil
}

func NewBsnTlvHashPacketType() *BsnTlvHashPacketType {
	obj := &BsnTlvHashPacketType{
		BsnTlv: NewBsnTlv(102),
	}
	return obj
}

type BsnTlvHashSeed struct {
	*BsnTlv
	Seed1 uint32
	Seed2 uint32
}

func (self *BsnTlvHashSeed) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Seed1))
	encoder.PutUint32(uint32(self.Seed2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashSeed(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashSeed, error) {
	_bsntlvhashseed := &BsnTlvHashSeed{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvHashSeed packet too short: %d < 8", decoder.Length())
	}
	_bsntlvhashseed.Seed1 = uint32(decoder.ReadUint32())
	_bsntlvhashseed.Seed2 = uint32(decoder.ReadUint32())
	return _bsntlvhashseed, nil
}

func NewBsnTlvHashSeed() *BsnTlvHashSeed {
	obj := &BsnTlvHashSeed{
		BsnTlv: NewBsnTlv(100),
	}
	return obj
}

type BsnTlvHashType struct {
	*BsnTlv
	Value BsnHashType
}

func (self *BsnTlvHashType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHashType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashType, error) {
	_bsntlvhashtype := &BsnTlvHashType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvHashType packet too short: %d < 1", decoder.Length())
	}
	_bsntlvhashtype.Value = BsnHashType(decoder.ReadByte())
	return _bsntlvhashtype, nil
}

func NewBsnTlvHashType() *BsnTlvHashType {
	obj := &BsnTlvHashType{
		BsnTlv: NewBsnTlv(101),
	}
	return obj
}

type BsnTlvHeaderSize struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvHeaderSize) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvHeaderSize(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHeaderSize, error) {
	_bsntlvheadersize := &BsnTlvHeaderSize{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvHeaderSize packet too short: %d < 4", decoder.Length())
	}
	_bsntlvheadersize.Value = uint32(decoder.ReadUint32())
	return _bsntlvheadersize, nil
}

func NewBsnTlvHeaderSize() *BsnTlvHeaderSize {
	obj := &BsnTlvHeaderSize{
		BsnTlv: NewBsnTlv(31),
	}
	return obj
}

type BsnTlvIcmpCode struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIcmpCode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIcmpCode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpCode, error) {
	_bsntlvicmpcode := &BsnTlvIcmpCode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIcmpCode packet too short: %d < 1", decoder.Length())
	}
	_bsntlvicmpcode.Value = uint8(decoder.ReadByte())
	return _bsntlvicmpcode, nil
}

func NewBsnTlvIcmpCode() *BsnTlvIcmpCode {
	obj := &BsnTlvIcmpCode{
		BsnTlv: NewBsnTlv(69),
	}
	return obj
}

type BsnTlvIcmpId struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvIcmpId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIcmpId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpId, error) {
	_bsntlvicmpid := &BsnTlvIcmpId{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIcmpId packet too short: %d < 2", decoder.Length())
	}
	_bsntlvicmpid.Value = uint16(decoder.ReadUint16())
	return _bsntlvicmpid, nil
}

func NewBsnTlvIcmpId() *BsnTlvIcmpId {
	obj := &BsnTlvIcmpId{
		BsnTlv: NewBsnTlv(70),
	}
	return obj
}

type BsnTlvIcmpType struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIcmpType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIcmpType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpType, error) {
	_bsntlvicmptype := &BsnTlvIcmpType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIcmpType packet too short: %d < 1", decoder.Length())
	}
	_bsntlvicmptype.Value = uint8(decoder.ReadByte())
	return _bsntlvicmptype, nil
}

func NewBsnTlvIcmpType() *BsnTlvIcmpType {
	obj := &BsnTlvIcmpType{
		BsnTlv: NewBsnTlv(68),
	}
	return obj
}

type BsnTlvIcmpv6Chksum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvIcmpv6Chksum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIcmpv6Chksum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpv6Chksum, error) {
	_bsntlvicmpv6chksum := &BsnTlvIcmpv6Chksum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIcmpv6Chksum packet too short: %d < 2", decoder.Length())
	}
	_bsntlvicmpv6chksum.Value = uint16(decoder.ReadUint16())
	return _bsntlvicmpv6chksum, nil
}

func NewBsnTlvIcmpv6Chksum() *BsnTlvIcmpv6Chksum {
	obj := &BsnTlvIcmpv6Chksum{
		BsnTlv: NewBsnTlv(125),
	}
	return obj
}

type BsnTlvIdentifier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIdentifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIdentifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdentifier, error) {
	_bsntlvidentifier := &BsnTlvIdentifier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIdentifier packet too short: %d < 4", decoder.Length())
	}
	_bsntlvidentifier.Value = uint32(decoder.ReadUint32())
	return _bsntlvidentifier, nil
}

func NewBsnTlvIdentifier() *BsnTlvIdentifier {
	obj := &BsnTlvIdentifier{
		BsnTlv: NewBsnTlv(173),
	}
	return obj
}

type BsnTlvIdleNotification struct {
	*BsnTlv
}

func (self *BsnTlvIdleNotification) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIdleNotification(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleNotification, error) {
	_bsntlvidlenotification := &BsnTlvIdleNotification{BsnTlv: parent}
	return _bsntlvidlenotification, nil
}

func NewBsnTlvIdleNotification() *BsnTlvIdleNotification {
	obj := &BsnTlvIdleNotification{
		BsnTlv: NewBsnTlv(7),
	}
	return obj
}

type BsnTlvIdleTime struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvIdleTime) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIdleTime(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleTime, error) {
	_bsntlvidletime := &BsnTlvIdleTime{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvIdleTime packet too short: %d < 8", decoder.Length())
	}
	_bsntlvidletime.Value = uint64(decoder.ReadUint64())
	return _bsntlvidletime, nil
}

func NewBsnTlvIdleTime() *BsnTlvIdleTime {
	obj := &BsnTlvIdleTime{
		BsnTlv: NewBsnTlv(5),
	}
	return obj
}

type BsnTlvIdleTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIdleTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIdleTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleTimeout, error) {
	_bsntlvidletimeout := &BsnTlvIdleTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIdleTimeout packet too short: %d < 4", decoder.Length())
	}
	_bsntlvidletimeout.Value = uint32(decoder.ReadUint32())
	return _bsntlvidletimeout, nil
}

func NewBsnTlvIdleTimeout() *BsnTlvIdleTimeout {
	obj := &BsnTlvIdleTimeout{
		BsnTlv: NewBsnTlv(8),
	}
	return obj
}

type BsnTlvIgmpSnooping struct {
	*BsnTlv
}

func (self *BsnTlvIgmpSnooping) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIgmpSnooping(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIgmpSnooping, error) {
	_bsntlvigmpsnooping := &BsnTlvIgmpSnooping{BsnTlv: parent}
	return _bsntlvigmpsnooping, nil
}

func NewBsnTlvIgmpSnooping() *BsnTlvIgmpSnooping {
	obj := &BsnTlvIgmpSnooping{
		BsnTlv: NewBsnTlv(78),
	}
	return obj
}

type BsnTlvIngressPortGroupId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIngressPortGroupId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIngressPortGroupId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIngressPortGroupId, error) {
	_bsntlvingressportgroupid := &BsnTlvIngressPortGroupId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIngressPortGroupId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvingressportgroupid.Value = uint32(decoder.ReadUint32())
	return _bsntlvingressportgroupid, nil
}

func NewBsnTlvIngressPortGroupId() *BsnTlvIngressPortGroupId {
	obj := &BsnTlvIngressPortGroupId{
		BsnTlv: NewBsnTlv(138),
	}
	return obj
}

type BsnTlvInternalGatewayMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvInternalGatewayMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvInternalGatewayMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInternalGatewayMac, error) {
	_bsntlvinternalgatewaymac := &BsnTlvInternalGatewayMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvInternalGatewayMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvinternalgatewaymac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvinternalgatewaymac, nil
}

func NewBsnTlvInternalGatewayMac() *BsnTlvInternalGatewayMac {
	obj := &BsnTlvInternalGatewayMac{
		BsnTlv: NewBsnTlv(28),
	}
	return obj
}

type BsnTlvInternalMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvInternalMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvInternalMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInternalMac, error) {
	_bsntlvinternalmac := &BsnTlvInternalMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvInternalMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvinternalmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvinternalmac, nil
}

func NewBsnTlvInternalMac() *BsnTlvInternalMac {
	obj := &BsnTlvInternalMac{
		BsnTlv: NewBsnTlv(27),
	}
	return obj
}

type BsnTlvInterval struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvInterval) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvInterval(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInterval, error) {
	_bsntlvinterval := &BsnTlvInterval{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvInterval packet too short: %d < 4", decoder.Length())
	}
	_bsntlvinterval.Value = uint32(decoder.ReadUint32())
	return _bsntlvinterval, nil
}

func NewBsnTlvInterval() *BsnTlvInterval {
	obj := &BsnTlvInterval{
		BsnTlv: NewBsnTlv(58),
	}
	return obj
}

type BsnTlvIpProto struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIpProto) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpProto(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpProto, error) {
	_bsntlvipproto := &BsnTlvIpProto{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIpProto packet too short: %d < 1", decoder.Length())
	}
	_bsntlvipproto.Value = uint8(decoder.ReadByte())
	return _bsntlvipproto, nil
}

func NewBsnTlvIpProto() *BsnTlvIpProto {
	obj := &BsnTlvIpProto{
		BsnTlv: NewBsnTlv(67),
	}
	return obj
}

type BsnTlvIpTunnelType struct {
	*BsnTlv
	Value BsnIpTunnelType
}

func (self *BsnTlvIpTunnelType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpTunnelType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpTunnelType, error) {
	_bsntlviptunneltype := &BsnTlvIpTunnelType{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIpTunnelType packet too short: %d < 2", decoder.Length())
	}
	_bsntlviptunneltype.Value = BsnIpTunnelType(decoder.ReadUint16())
	return _bsntlviptunneltype, nil
}

func NewBsnTlvIpTunnelType() *BsnTlvIpTunnelType {
	obj := &BsnTlvIpTunnelType{
		BsnTlv: NewBsnTlv(169),
	}
	return obj
}

type BsnTlvIpv4 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv4(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4, error) {
	_bsntlvipv4 := &BsnTlvIpv4{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4 packet too short: %d < 4", decoder.Length())
	}
	_bsntlvipv4.Value = net.IP(decoder.Read(4))
	return _bsntlvipv4, nil
}

func NewBsnTlvIpv4() *BsnTlvIpv4 {
	obj := &BsnTlvIpv4{
		BsnTlv: NewBsnTlv(4),
	}
	return obj
}

type BsnTlvIpv4Dst struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Dst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv4Dst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Dst, error) {
	_bsntlvipv4dst := &BsnTlvIpv4Dst{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Dst packet too short: %d < 4", decoder.Length())
	}
	_bsntlvipv4dst.Value = net.IP(decoder.Read(4))
	return _bsntlvipv4dst, nil
}

func NewBsnTlvIpv4Dst() *BsnTlvIpv4Dst {
	obj := &BsnTlvIpv4Dst{
		BsnTlv: NewBsnTlv(35),
	}
	return obj
}

type BsnTlvIpv4Netmask struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Netmask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv4Netmask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Netmask, error) {
	_bsntlvipv4netmask := &BsnTlvIpv4Netmask{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Netmask packet too short: %d < 4", decoder.Length())
	}
	_bsntlvipv4netmask.Value = net.IP(decoder.Read(4))
	return _bsntlvipv4netmask, nil
}

func NewBsnTlvIpv4Netmask() *BsnTlvIpv4Netmask {
	obj := &BsnTlvIpv4Netmask{
		BsnTlv: NewBsnTlv(60),
	}
	return obj
}

type BsnTlvIpv4Src struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Src) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv4Src(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Src, error) {
	_bsntlvipv4src := &BsnTlvIpv4Src{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Src packet too short: %d < 4", decoder.Length())
	}
	_bsntlvipv4src.Value = net.IP(decoder.Read(4))
	return _bsntlvipv4src, nil
}

func NewBsnTlvIpv4Src() *BsnTlvIpv4Src {
	obj := &BsnTlvIpv4Src{
		BsnTlv: NewBsnTlv(34),
	}
	return obj
}

type BsnTlvIpv6 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv6(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6, error) {
	_bsntlvipv6 := &BsnTlvIpv6{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6 packet too short: %d < 16", decoder.Length())
	}
	_bsntlvipv6.Value = net.IP(decoder.Read(16))
	return _bsntlvipv6, nil
}

func NewBsnTlvIpv6() *BsnTlvIpv6 {
	obj := &BsnTlvIpv6{
		BsnTlv: NewBsnTlv(84),
	}
	return obj
}

type BsnTlvIpv6Dst struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6Dst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv6Dst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Dst, error) {
	_bsntlvipv6dst := &BsnTlvIpv6Dst{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6Dst packet too short: %d < 16", decoder.Length())
	}
	_bsntlvipv6dst.Value = net.IP(decoder.Read(16))
	return _bsntlvipv6dst, nil
}

func NewBsnTlvIpv6Dst() *BsnTlvIpv6Dst {
	obj := &BsnTlvIpv6Dst{
		BsnTlv: NewBsnTlv(127),
	}
	return obj
}

type BsnTlvIpv6Prefix struct {
	*BsnTlv
	Value        net.IP
	PrefixLength uint8
}

func (self *BsnTlvIpv6Prefix) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())
	encoder.PutUint8(uint8(self.PrefixLength))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv6Prefix(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Prefix, error) {
	_bsntlvipv6prefix := &BsnTlvIpv6Prefix{BsnTlv: parent}
	if decoder.Length() < 17 {
		return nil, fmt.Errorf("BsnTlvIpv6Prefix packet too short: %d < 17", decoder.Length())
	}
	_bsntlvipv6prefix.Value = net.IP(decoder.Read(16))
	_bsntlvipv6prefix.PrefixLength = uint8(decoder.ReadByte())
	return _bsntlvipv6prefix, nil
}

func NewBsnTlvIpv6Prefix() *BsnTlvIpv6Prefix {
	obj := &BsnTlvIpv6Prefix{
		BsnTlv: NewBsnTlv(122),
	}
	return obj
}

type BsnTlvIpv6Src struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6Src) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvIpv6Src(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Src, error) {
	_bsntlvipv6src := &BsnTlvIpv6Src{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6Src packet too short: %d < 16", decoder.Length())
	}
	_bsntlvipv6src.Value = net.IP(decoder.Read(16))
	return _bsntlvipv6src, nil
}

func NewBsnTlvIpv6Src() *BsnTlvIpv6Src {
	obj := &BsnTlvIpv6Src{
		BsnTlv: NewBsnTlv(126),
	}
	return obj
}

type BsnTlvKnownMulticastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvKnownMulticastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvKnownMulticastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvKnownMulticastRate, error) {
	_bsntlvknownmulticastrate := &BsnTlvKnownMulticastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvKnownMulticastRate packet too short: %d < 4", decoder.Length())
	}
	_bsntlvknownmulticastrate.Value = uint32(decoder.ReadUint32())
	return _bsntlvknownmulticastrate, nil
}

func NewBsnTlvKnownMulticastRate() *BsnTlvKnownMulticastRate {
	obj := &BsnTlvKnownMulticastRate{
		BsnTlv: NewBsnTlv(91),
	}
	return obj
}

type BsnTlvL2MulticastLookup struct {
	*BsnTlv
}

func (self *BsnTlvL2MulticastLookup) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvL2MulticastLookup(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL2MulticastLookup, error) {
	_bsntlvl2multicastlookup := &BsnTlvL2MulticastLookup{BsnTlv: parent}
	return _bsntlvl2multicastlookup, nil
}

func NewBsnTlvL2MulticastLookup() *BsnTlvL2MulticastLookup {
	obj := &BsnTlvL2MulticastLookup{
		BsnTlv: NewBsnTlv(79),
	}
	return obj
}

type BsnTlvL3 struct {
	*BsnTlv
}

func (self *BsnTlvL3) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvL3(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3, error) {
	_bsntlvl3 := &BsnTlvL3{BsnTlv: parent}
	return _bsntlvl3, nil
}

func NewBsnTlvL3() *BsnTlvL3 {
	obj := &BsnTlvL3{
		BsnTlv: NewBsnTlv(168),
	}
	return obj
}

type BsnTlvL3DstClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3DstClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvL3DstClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3DstClassId, error) {
	_bsntlvl3dstclassid := &BsnTlvL3DstClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3DstClassId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvl3dstclassid.Value = uint32(decoder.ReadUint32())
	return _bsntlvl3dstclassid, nil
}

func NewBsnTlvL3DstClassId() *BsnTlvL3DstClassId {
	obj := &BsnTlvL3DstClassId{
		BsnTlv: NewBsnTlv(136),
	}
	return obj
}

type BsnTlvL3InterfaceClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3InterfaceClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvL3InterfaceClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3InterfaceClassId, error) {
	_bsntlvl3interfaceclassid := &BsnTlvL3InterfaceClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3InterfaceClassId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvl3interfaceclassid.Value = uint32(decoder.ReadUint32())
	return _bsntlvl3interfaceclassid, nil
}

func NewBsnTlvL3InterfaceClassId() *BsnTlvL3InterfaceClassId {
	obj := &BsnTlvL3InterfaceClassId{
		BsnTlv: NewBsnTlv(134),
	}
	return obj
}

type BsnTlvL3SrcClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3SrcClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvL3SrcClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3SrcClassId, error) {
	_bsntlvl3srcclassid := &BsnTlvL3SrcClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3SrcClassId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvl3srcclassid.Value = uint32(decoder.ReadUint32())
	return _bsntlvl3srcclassid, nil
}

func NewBsnTlvL3SrcClassId() *BsnTlvL3SrcClassId {
	obj := &BsnTlvL3SrcClassId{
		BsnTlv: NewBsnTlv(135),
	}
	return obj
}

type BsnTlvLagOptions struct {
	*BsnTlv
	Flags BsnLagFlag
}

func (self *BsnTlvLagOptions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvLagOptions(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLagOptions, error) {
	_bsntlvlagoptions := &BsnTlvLagOptions{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvLagOptions packet too short: %d < 2", decoder.Length())
	}
	_bsntlvlagoptions.Flags = BsnLagFlag(decoder.ReadUint16())
	return _bsntlvlagoptions, nil
}

func NewBsnTlvLagOptions() *BsnTlvLagOptions {
	obj := &BsnTlvLagOptions{
		BsnTlv: NewBsnTlv(160),
	}
	return obj
}

type BsnTlvLoopbackMode struct {
	*BsnTlv
	Value BsnLoopbackMode
}

func (self *BsnTlvLoopbackMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvLoopbackMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLoopbackMode, error) {
	_bsntlvloopbackmode := &BsnTlvLoopbackMode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvLoopbackMode packet too short: %d < 1", decoder.Length())
	}
	_bsntlvloopbackmode.Value = BsnLoopbackMode(decoder.ReadByte())
	return _bsntlvloopbackmode, nil
}

func NewBsnTlvLoopbackMode() *BsnTlvLoopbackMode {
	obj := &BsnTlvLoopbackMode{
		BsnTlv: NewBsnTlv(146),
	}
	return obj
}

type BsnTlvLoopbackPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvLoopbackPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvLoopbackPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLoopbackPort, error) {
	_bsntlvloopbackport := &BsnTlvLoopbackPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvLoopbackPort packet too short: %d < 4", decoder.Length())
	}
	_bsntlvloopbackport.Value.Decode(decoder)
	return _bsntlvloopbackport, nil
}

func NewBsnTlvLoopbackPort() *BsnTlvLoopbackPort {
	obj := &BsnTlvLoopbackPort{
		BsnTlv: NewBsnTlv(110),
	}
	return obj
}

type BsnTlvLrAllEnabled struct {
	*BsnTlv
}

func (self *BsnTlvLrAllEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvLrAllEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLrAllEnabled, error) {
	_bsntlvlrallenabled := &BsnTlvLrAllEnabled{BsnTlv: parent}
	return _bsntlvlrallenabled, nil
}

func NewBsnTlvLrAllEnabled() *BsnTlvLrAllEnabled {
	obj := &BsnTlvLrAllEnabled{
		BsnTlv: NewBsnTlv(178),
	}
	return obj
}

type BsnTlvMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMac, error) {
	_bsntlvmac := &BsnTlvMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvmac, nil
}

func NewBsnTlvMac() *BsnTlvMac {
	obj := &BsnTlvMac{
		BsnTlv: NewBsnTlv(1),
	}
	return obj
}

type BsnTlvMacMask struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvMacMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMacMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMacMask, error) {
	_bsntlvmacmask := &BsnTlvMacMask{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvMacMask packet too short: %d < 6", decoder.Length())
	}
	_bsntlvmacmask.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvmacmask, nil
}

func NewBsnTlvMacMask() *BsnTlvMacMask {
	obj := &BsnTlvMacMask{
		BsnTlv: NewBsnTlv(56),
	}
	return obj
}

type BsnTlvMcgTypeVxlan struct {
	*BsnTlv
}

func (self *BsnTlvMcgTypeVxlan) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMcgTypeVxlan(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMcgTypeVxlan, error) {
	_bsntlvmcgtypevxlan := &BsnTlvMcgTypeVxlan{BsnTlv: parent}
	return _bsntlvmcgtypevxlan, nil
}

func NewBsnTlvMcgTypeVxlan() *BsnTlvMcgTypeVxlan {
	obj := &BsnTlvMcgTypeVxlan{
		BsnTlv: NewBsnTlv(87),
	}
	return obj
}

type BsnTlvMissPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvMissPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMissPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMissPackets, error) {
	_bsntlvmisspackets := &BsnTlvMissPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvMissPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvmisspackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvmisspackets, nil
}

func NewBsnTlvMissPackets() *BsnTlvMissPackets {
	obj := &BsnTlvMissPackets{
		BsnTlv: NewBsnTlv(13),
	}
	return obj
}

type BsnTlvMplsControlWord struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvMplsControlWord) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMplsControlWord(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsControlWord, error) {
	_bsntlvmplscontrolword := &BsnTlvMplsControlWord{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvMplsControlWord packet too short: %d < 1", decoder.Length())
	}
	_bsntlvmplscontrolword.Value = uint8(decoder.ReadByte())
	return _bsntlvmplscontrolword, nil
}

func NewBsnTlvMplsControlWord() *BsnTlvMplsControlWord {
	obj := &BsnTlvMplsControlWord{
		BsnTlv: NewBsnTlv(62),
	}
	return obj
}

type BsnTlvMplsLabel struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMplsLabel) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMplsLabel(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsLabel, error) {
	_bsntlvmplslabel := &BsnTlvMplsLabel{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMplsLabel packet too short: %d < 4", decoder.Length())
	}
	_bsntlvmplslabel.Value = uint32(decoder.ReadUint32())
	return _bsntlvmplslabel, nil
}

func NewBsnTlvMplsLabel() *BsnTlvMplsLabel {
	obj := &BsnTlvMplsLabel{
		BsnTlv: NewBsnTlv(61),
	}
	return obj
}

type BsnTlvMplsSequenced struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvMplsSequenced) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMplsSequenced(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsSequenced, error) {
	_bsntlvmplssequenced := &BsnTlvMplsSequenced{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvMplsSequenced packet too short: %d < 1", decoder.Length())
	}
	_bsntlvmplssequenced.Value = uint8(decoder.ReadByte())
	return _bsntlvmplssequenced, nil
}

func NewBsnTlvMplsSequenced() *BsnTlvMplsSequenced {
	obj := &BsnTlvMplsSequenced{
		BsnTlv: NewBsnTlv(63),
	}
	return obj
}

type BsnTlvMulticastInterfaceId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMulticastInterfaceId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMulticastInterfaceId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMulticastInterfaceId, error) {
	_bsntlvmulticastinterfaceid := &BsnTlvMulticastInterfaceId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMulticastInterfaceId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvmulticastinterfaceid.Value = uint32(decoder.ReadUint32())
	return _bsntlvmulticastinterfaceid, nil
}

func NewBsnTlvMulticastInterfaceId() *BsnTlvMulticastInterfaceId {
	obj := &BsnTlvMulticastInterfaceId{
		BsnTlv: NewBsnTlv(95),
	}
	return obj
}

type BsnTlvMulticastPacket struct {
	*BsnTlv
	Value BsnMulticastPacket
}

func (self *BsnTlvMulticastPacket) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMulticastPacket(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMulticastPacket, error) {
	_bsntlvmulticastpacket := &BsnTlvMulticastPacket{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvMulticastPacket packet too short: %d < 2", decoder.Length())
	}
	_bsntlvmulticastpacket.Value = BsnMulticastPacket(decoder.ReadUint16())
	return _bsntlvmulticastpacket, nil
}

func NewBsnTlvMulticastPacket() *BsnTlvMulticastPacket {
	obj := &BsnTlvMulticastPacket{
		BsnTlv: NewBsnTlv(170),
	}
	return obj
}

type BsnTlvMultiplier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMultiplier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvMultiplier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMultiplier, error) {
	_bsntlvmultiplier := &BsnTlvMultiplier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMultiplier packet too short: %d < 4", decoder.Length())
	}
	_bsntlvmultiplier.Value = uint32(decoder.ReadUint32())
	return _bsntlvmultiplier, nil
}

func NewBsnTlvMultiplier() *BsnTlvMultiplier {
	obj := &BsnTlvMultiplier{
		BsnTlv: NewBsnTlv(174),
	}
	return obj
}

type BsnTlvName struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvName) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvName(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvName, error) {
	_bsntlvname := &BsnTlvName{BsnTlv: parent}
	_bsntlvname.Value = decoder.Read(decoder.Length())
	return _bsntlvname, nil
}

func NewBsnTlvName() *BsnTlvName {
	obj := &BsnTlvName{
		BsnTlv: NewBsnTlv(52),
	}
	return obj
}

type BsnTlvNdpOffload struct {
	*BsnTlv
}

func (self *BsnTlvNdpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNdpOffload(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNdpOffload, error) {
	_bsntlvndpoffload := &BsnTlvNdpOffload{BsnTlv: parent}
	return _bsntlvndpoffload, nil
}

func NewBsnTlvNdpOffload() *BsnTlvNdpOffload {
	obj := &BsnTlvNdpOffload{
		BsnTlv: NewBsnTlv(123),
	}
	return obj
}

type BsnTlvNdpStatic struct {
	*BsnTlv
}

func (self *BsnTlvNdpStatic) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNdpStatic(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNdpStatic, error) {
	_bsntlvndpstatic := &BsnTlvNdpStatic{BsnTlv: parent}
	return _bsntlvndpstatic, nil
}

func NewBsnTlvNdpStatic() *BsnTlvNdpStatic {
	obj := &BsnTlvNdpStatic{
		BsnTlv: NewBsnTlv(124),
	}
	return obj
}

type BsnTlvNegate struct {
	*BsnTlv
}

func (self *BsnTlvNegate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNegate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNegate, error) {
	_bsntlvnegate := &BsnTlvNegate{BsnTlv: parent}
	return _bsntlvnegate, nil
}

func NewBsnTlvNegate() *BsnTlvNegate {
	obj := &BsnTlvNegate{
		BsnTlv: NewBsnTlv(83),
	}
	return obj
}

type BsnTlvNextHopIpv4 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvNextHopIpv4) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNextHopIpv4(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNextHopIpv4, error) {
	_bsntlvnexthopipv4 := &BsnTlvNextHopIpv4{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvNextHopIpv4 packet too short: %d < 4", decoder.Length())
	}
	_bsntlvnexthopipv4.Value = net.IP(decoder.Read(4))
	return _bsntlvnexthopipv4, nil
}

func NewBsnTlvNextHopIpv4() *BsnTlvNextHopIpv4 {
	obj := &BsnTlvNextHopIpv4{
		BsnTlv: NewBsnTlv(115),
	}
	return obj
}

type BsnTlvNextHopMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvNextHopMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNextHopMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNextHopMac, error) {
	_bsntlvnexthopmac := &BsnTlvNextHopMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvNextHopMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvnexthopmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvnexthopmac, nil
}

func NewBsnTlvNextHopMac() *BsnTlvNextHopMac {
	obj := &BsnTlvNextHopMac{
		BsnTlv: NewBsnTlv(114),
	}
	return obj
}

type BsnTlvNexthopTypeVxlan struct {
	*BsnTlv
}

func (self *BsnTlvNexthopTypeVxlan) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNexthopTypeVxlan(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNexthopTypeVxlan, error) {
	_bsntlvnexthoptypevxlan := &BsnTlvNexthopTypeVxlan{BsnTlv: parent}
	return _bsntlvnexthoptypevxlan, nil
}

func NewBsnTlvNexthopTypeVxlan() *BsnTlvNexthopTypeVxlan {
	obj := &BsnTlvNexthopTypeVxlan{
		BsnTlv: NewBsnTlv(94),
	}
	return obj
}

type BsnTlvNoArpResponse struct {
	*BsnTlv
}

func (self *BsnTlvNoArpResponse) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNoArpResponse(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNoArpResponse, error) {
	_bsntlvnoarpresponse := &BsnTlvNoArpResponse{BsnTlv: parent}
	return _bsntlvnoarpresponse, nil
}

func NewBsnTlvNoArpResponse() *BsnTlvNoArpResponse {
	obj := &BsnTlvNoArpResponse{
		BsnTlv: NewBsnTlv(147),
	}
	return obj
}

type BsnTlvNoNsResponse struct {
	*BsnTlv
}

func (self *BsnTlvNoNsResponse) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvNoNsResponse(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNoNsResponse, error) {
	_bsntlvnonsresponse := &BsnTlvNoNsResponse{BsnTlv: parent}
	return _bsntlvnonsresponse, nil
}

func NewBsnTlvNoNsResponse() *BsnTlvNoNsResponse {
	obj := &BsnTlvNoNsResponse{
		BsnTlv: NewBsnTlv(148),
	}
	return obj
}

type BsnTlvOffset struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvOffset) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvOffset(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOffset, error) {
	_bsntlvoffset := &BsnTlvOffset{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvOffset packet too short: %d < 2", decoder.Length())
	}
	_bsntlvoffset.Value = uint16(decoder.ReadUint16())
	return _bsntlvoffset, nil
}

func NewBsnTlvOffset() *BsnTlvOffset {
	obj := &BsnTlvOffset{
		BsnTlv: NewBsnTlv(82),
	}
	return obj
}

type BsnTlvOpticsAlwaysEnabled struct {
	*BsnTlv
}

func (self *BsnTlvOpticsAlwaysEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvOpticsAlwaysEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOpticsAlwaysEnabled, error) {
	_bsntlvopticsalwaysenabled := &BsnTlvOpticsAlwaysEnabled{BsnTlv: parent}
	return _bsntlvopticsalwaysenabled, nil
}

func NewBsnTlvOpticsAlwaysEnabled() *BsnTlvOpticsAlwaysEnabled {
	obj := &BsnTlvOpticsAlwaysEnabled{
		BsnTlv: NewBsnTlv(150),
	}
	return obj
}

type BsnTlvOuterSrcMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvOuterSrcMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvOuterSrcMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOuterSrcMac, error) {
	_bsntlvoutersrcmac := &BsnTlvOuterSrcMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvOuterSrcMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvoutersrcmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvoutersrcmac, nil
}

func NewBsnTlvOuterSrcMac() *BsnTlvOuterSrcMac {
	obj := &BsnTlvOuterSrcMac{
		BsnTlv: NewBsnTlv(157),
	}
	return obj
}

type BsnTlvParentPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvParentPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvParentPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvParentPort, error) {
	_bsntlvparentport := &BsnTlvParentPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvParentPort packet too short: %d < 4", decoder.Length())
	}
	_bsntlvparentport.Value.Decode(decoder)
	return _bsntlvparentport, nil
}

func NewBsnTlvParentPort() *BsnTlvParentPort {
	obj := &BsnTlvParentPort{
		BsnTlv: NewBsnTlv(109),
	}
	return obj
}

type BsnTlvPartnerKey struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerKey, error) {
	_bsntlvpartnerkey := &BsnTlvPartnerKey{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerKey packet too short: %d < 2", decoder.Length())
	}
	_bsntlvpartnerkey.Value = uint16(decoder.ReadUint16())
	return _bsntlvpartnerkey, nil
}

func NewBsnTlvPartnerKey() *BsnTlvPartnerKey {
	obj := &BsnTlvPartnerKey{
		BsnTlv: NewBsnTlv(51),
	}
	return obj
}

type BsnTlvPartnerPortNum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerPortNum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerPortNum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerPortNum, error) {
	_bsntlvpartnerportnum := &BsnTlvPartnerPortNum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerPortNum packet too short: %d < 2", decoder.Length())
	}
	_bsntlvpartnerportnum.Value = uint16(decoder.ReadUint16())
	return _bsntlvpartnerportnum, nil
}

func NewBsnTlvPartnerPortNum() *BsnTlvPartnerPortNum {
	obj := &BsnTlvPartnerPortNum{
		BsnTlv: NewBsnTlv(50),
	}
	return obj
}

type BsnTlvPartnerPortPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerPortPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerPortPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerPortPriority, error) {
	_bsntlvpartnerportpriority := &BsnTlvPartnerPortPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerPortPriority packet too short: %d < 2", decoder.Length())
	}
	_bsntlvpartnerportpriority.Value = uint16(decoder.ReadUint16())
	return _bsntlvpartnerportpriority, nil
}

func NewBsnTlvPartnerPortPriority() *BsnTlvPartnerPortPriority {
	obj := &BsnTlvPartnerPortPriority{
		BsnTlv: NewBsnTlv(49),
	}
	return obj
}

type BsnTlvPartnerState struct {
	*BsnTlv
	Value BsnLacpState
}

func (self *BsnTlvPartnerState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerState, error) {
	_bsntlvpartnerstate := &BsnTlvPartnerState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPartnerState packet too short: %d < 1", decoder.Length())
	}
	_bsntlvpartnerstate.Value = BsnLacpState(decoder.ReadByte())
	return _bsntlvpartnerstate, nil
}

func NewBsnTlvPartnerState() *BsnTlvPartnerState {
	obj := &BsnTlvPartnerState{
		BsnTlv: NewBsnTlv(54),
	}
	return obj
}

type BsnTlvPartnerSystemMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvPartnerSystemMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerSystemMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerSystemMac, error) {
	_bsntlvpartnersystemmac := &BsnTlvPartnerSystemMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvPartnerSystemMac packet too short: %d < 6", decoder.Length())
	}
	_bsntlvpartnersystemmac.Value = net.HardwareAddr(decoder.Read(6))
	return _bsntlvpartnersystemmac, nil
}

func NewBsnTlvPartnerSystemMac() *BsnTlvPartnerSystemMac {
	obj := &BsnTlvPartnerSystemMac{
		BsnTlv: NewBsnTlv(48),
	}
	return obj
}

type BsnTlvPartnerSystemPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerSystemPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPartnerSystemPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerSystemPriority, error) {
	_bsntlvpartnersystempriority := &BsnTlvPartnerSystemPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerSystemPriority packet too short: %d < 2", decoder.Length())
	}
	_bsntlvpartnersystempriority.Value = uint16(decoder.ReadUint16())
	return _bsntlvpartnersystempriority, nil
}

func NewBsnTlvPartnerSystemPriority() *BsnTlvPartnerSystemPriority {
	obj := &BsnTlvPartnerSystemPriority{
		BsnTlv: NewBsnTlv(47),
	}
	return obj
}

type BsnTlvPassive struct {
	*BsnTlv
}

func (self *BsnTlvPassive) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPassive(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPassive, error) {
	_bsntlvpassive := &BsnTlvPassive{BsnTlv: parent}
	return _bsntlvpassive, nil
}

func NewBsnTlvPassive() *BsnTlvPassive {
	obj := &BsnTlvPassive{
		BsnTlv: NewBsnTlv(172),
	}
	return obj
}

type BsnTlvPduaRxInstance struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvPduaRxInstance) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPduaRxInstance(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPduaRxInstance, error) {
	_bsntlvpduarxinstance := &BsnTlvPduaRxInstance{BsnTlv: parent}
	_bsntlvpduarxinstance.Value = decoder.Read(decoder.Length())
	return _bsntlvpduarxinstance, nil
}

func NewBsnTlvPduaRxInstance() *BsnTlvPduaRxInstance {
	obj := &BsnTlvPduaRxInstance{
		BsnTlv: NewBsnTlv(159),
	}
	return obj
}

type BsnTlvPimDr struct {
	*BsnTlv
}

func (self *BsnTlvPimDr) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPimDr(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPimDr, error) {
	_bsntlvpimdr := &BsnTlvPimDr{BsnTlv: parent}
	return _bsntlvpimdr, nil
}

func NewBsnTlvPimDr() *BsnTlvPimDr {
	obj := &BsnTlvPimDr{
		BsnTlv: NewBsnTlv(171),
	}
	return obj
}

type BsnTlvPimHelloFlood struct {
	*BsnTlv
}

func (self *BsnTlvPimHelloFlood) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPimHelloFlood(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPimHelloFlood, error) {
	_bsntlvpimhelloflood := &BsnTlvPimHelloFlood{BsnTlv: parent}
	return _bsntlvpimhelloflood, nil
}

func NewBsnTlvPimHelloFlood() *BsnTlvPimHelloFlood {
	obj := &BsnTlvPimHelloFlood{
		BsnTlv: NewBsnTlv(181),
	}
	return obj
}

type BsnTlvPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPort, error) {
	_bsntlvport := &BsnTlvPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPort packet too short: %d < 4", decoder.Length())
	}
	_bsntlvport.Value.Decode(decoder)
	return _bsntlvport, nil
}

func NewBsnTlvPort() *BsnTlvPort {
	obj := &BsnTlvPort{
		BsnTlv: NewBsnTlv(0),
	}
	return obj
}

type BsnTlvPortMode struct {
	*BsnTlv
	Value BsnPortMode
}

func (self *BsnTlvPortMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPortMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortMode, error) {
	_bsntlvportmode := &BsnTlvPortMode{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPortMode packet too short: %d < 2", decoder.Length())
	}
	_bsntlvportmode.Value = BsnPortMode(decoder.ReadUint16())
	return _bsntlvportmode, nil
}

func NewBsnTlvPortMode() *BsnTlvPortMode {
	obj := &BsnTlvPortMode{
		BsnTlv: NewBsnTlv(179),
	}
	return obj
}

type BsnTlvPortSpeedGbps struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvPortSpeedGbps) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPortSpeedGbps(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortSpeedGbps, error) {
	_bsntlvportspeedgbps := &BsnTlvPortSpeedGbps{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPortSpeedGbps packet too short: %d < 4", decoder.Length())
	}
	_bsntlvportspeedgbps.Value = uint32(decoder.ReadUint32())
	return _bsntlvportspeedgbps, nil
}

func NewBsnTlvPortSpeedGbps() *BsnTlvPortSpeedGbps {
	obj := &BsnTlvPortSpeedGbps{
		BsnTlv: NewBsnTlv(156),
	}
	return obj
}

type BsnTlvPortUsage struct {
	*BsnTlv
	Value BsnPortUsage
}

func (self *BsnTlvPortUsage) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPortUsage(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortUsage, error) {
	_bsntlvportusage := &BsnTlvPortUsage{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPortUsage packet too short: %d < 2", decoder.Length())
	}
	_bsntlvportusage.Value = BsnPortUsage(decoder.ReadUint16())
	return _bsntlvportusage, nil
}

func NewBsnTlvPortUsage() *BsnTlvPortUsage {
	obj := &BsnTlvPortUsage{
		BsnTlv: NewBsnTlv(141),
	}
	return obj
}

type BsnTlvPortVxlanMode struct {
	*BsnTlv
	Value BsnPortVxlanMode
}

func (self *BsnTlvPortVxlanMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPortVxlanMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortVxlanMode, error) {
	_bsntlvportvxlanmode := &BsnTlvPortVxlanMode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPortVxlanMode packet too short: %d < 1", decoder.Length())
	}
	_bsntlvportvxlanmode.Value = BsnPortVxlanMode(decoder.ReadByte())
	return _bsntlvportvxlanmode, nil
}

func NewBsnTlvPortVxlanMode() *BsnTlvPortVxlanMode {
	obj := &BsnTlvPortVxlanMode{
		BsnTlv: NewBsnTlv(88),
	}
	return obj
}

type BsnTlvPriority struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPriority, error) {
	_bsntlvpriority := &BsnTlvPriority{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPriority packet too short: %d < 4", decoder.Length())
	}
	_bsntlvpriority.Value = uint32(decoder.ReadUint32())
	return _bsntlvpriority, nil
}

func NewBsnTlvPriority() *BsnTlvPriority {
	obj := &BsnTlvPriority{
		BsnTlv: NewBsnTlv(57),
	}
	return obj
}

type BsnTlvPushVlanOnEgress struct {
	*BsnTlv
}

func (self *BsnTlvPushVlanOnEgress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPushVlanOnEgress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPushVlanOnEgress, error) {
	_bsntlvpushvlanonegress := &BsnTlvPushVlanOnEgress{BsnTlv: parent}
	return _bsntlvpushvlanonegress, nil
}

func NewBsnTlvPushVlanOnEgress() *BsnTlvPushVlanOnEgress {
	obj := &BsnTlvPushVlanOnEgress{
		BsnTlv: NewBsnTlv(162),
	}
	return obj
}

type BsnTlvPushVlanOnIngress struct {
	*BsnTlv
	Flags BsnPushVlan
}

func (self *BsnTlvPushVlanOnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvPushVlanOnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPushVlanOnIngress, error) {
	_bsntlvpushvlanoningress := &BsnTlvPushVlanOnIngress{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPushVlanOnIngress packet too short: %d < 1", decoder.Length())
	}
	_bsntlvpushvlanoningress.Flags = BsnPushVlan(decoder.ReadByte())
	return _bsntlvpushvlanoningress, nil
}

func NewBsnTlvPushVlanOnIngress() *BsnTlvPushVlanOnIngress {
	obj := &BsnTlvPushVlanOnIngress{
		BsnTlv: NewBsnTlv(128),
	}
	return obj
}

type BsnTlvQosPriority struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQosPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvQosPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQosPriority, error) {
	_bsntlvqospriority := &BsnTlvQosPriority{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQosPriority packet too short: %d < 4", decoder.Length())
	}
	_bsntlvqospriority.Value = uint32(decoder.ReadUint32())
	return _bsntlvqospriority, nil
}

func NewBsnTlvQosPriority() *BsnTlvQosPriority {
	obj := &BsnTlvQosPriority{
		BsnTlv: NewBsnTlv(108),
	}
	return obj
}

type BsnTlvQueueId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQueueId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvQueueId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQueueId, error) {
	_bsntlvqueueid := &BsnTlvQueueId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQueueId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvqueueid.Value = uint32(decoder.ReadUint32())
	return _bsntlvqueueid, nil
}

func NewBsnTlvQueueId() *BsnTlvQueueId {
	obj := &BsnTlvQueueId{
		BsnTlv: NewBsnTlv(20),
	}
	return obj
}

type BsnTlvQueueWeight struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQueueWeight) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvQueueWeight(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQueueWeight, error) {
	_bsntlvqueueweight := &BsnTlvQueueWeight{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQueueWeight packet too short: %d < 4", decoder.Length())
	}
	_bsntlvqueueweight.Value = uint32(decoder.ReadUint32())
	return _bsntlvqueueweight, nil
}

func NewBsnTlvQueueWeight() *BsnTlvQueueWeight {
	obj := &BsnTlvQueueWeight{
		BsnTlv: NewBsnTlv(21),
	}
	return obj
}

type BsnTlvRateLimit struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvRateLimit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRateLimit(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRateLimit, error) {
	_bsntlvratelimit := &BsnTlvRateLimit{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvRateLimit packet too short: %d < 4", decoder.Length())
	}
	_bsntlvratelimit.Value = uint32(decoder.ReadUint32())
	return _bsntlvratelimit, nil
}

func NewBsnTlvRateLimit() *BsnTlvRateLimit {
	obj := &BsnTlvRateLimit{
		BsnTlv: NewBsnTlv(116),
	}
	return obj
}

type BsnTlvRateUnit struct {
	*BsnTlv
	Value BsnRateUnit
}

func (self *BsnTlvRateUnit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRateUnit(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRateUnit, error) {
	_bsntlvrateunit := &BsnTlvRateUnit{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvRateUnit packet too short: %d < 1", decoder.Length())
	}
	_bsntlvrateunit.Value = BsnRateUnit(decoder.ReadByte())
	return _bsntlvrateunit, nil
}

func NewBsnTlvRateUnit() *BsnTlvRateUnit {
	obj := &BsnTlvRateUnit{
		BsnTlv: NewBsnTlv(89),
	}
	return obj
}

type BsnTlvRecordPackets struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvRecordPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRecordPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRecordPackets, error) {
	_bsntlvrecordpackets := &BsnTlvRecordPackets{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvRecordPackets packet too short: %d < 4", decoder.Length())
	}
	_bsntlvrecordpackets.Value = uint32(decoder.ReadUint32())
	return _bsntlvrecordpackets, nil
}

func NewBsnTlvRecordPackets() *BsnTlvRecordPackets {
	obj := &BsnTlvRecordPackets{
		BsnTlv: NewBsnTlv(155),
	}
	return obj
}

type BsnTlvReference struct {
	*BsnTlv
	TableId uint16
	Key     []IBsnTlv
}

func (self *BsnTlvReference) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvReference(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvReference, error) {
	_bsntlvreference := &BsnTlvReference{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvReference packet too short: %d < 2", decoder.Length())
	}
	_bsntlvreference.TableId = uint16(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := DecodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		_bsntlvreference.Key = append(_bsntlvreference.Key, item)
	}
	return _bsntlvreference, nil
}

func NewBsnTlvReference() *BsnTlvReference {
	obj := &BsnTlvReference{
		BsnTlv: NewBsnTlv(59),
	}
	return obj
}

type BsnTlvReplyPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvReplyPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvReplyPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvReplyPackets, error) {
	_bsntlvreplypackets := &BsnTlvReplyPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvReplyPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvreplypackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvreplypackets, nil
}

func NewBsnTlvReplyPackets() *BsnTlvReplyPackets {
	obj := &BsnTlvReplyPackets{
		BsnTlv: NewBsnTlv(12),
	}
	return obj
}

type BsnTlvRequestPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRequestPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRequestPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRequestPackets, error) {
	_bsntlvrequestpackets := &BsnTlvRequestPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRequestPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvrequestpackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvrequestpackets, nil
}

func NewBsnTlvRequestPackets() *BsnTlvRequestPackets {
	obj := &BsnTlvRequestPackets{
		BsnTlv: NewBsnTlv(11),
	}
	return obj
}

type BsnTlvRestServer struct {
	*BsnTlv
}

func (self *BsnTlvRestServer) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRestServer(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRestServer, error) {
	_bsntlvrestserver := &BsnTlvRestServer{BsnTlv: parent}
	return _bsntlvrestserver, nil
}

func NewBsnTlvRestServer() *BsnTlvRestServer {
	obj := &BsnTlvRestServer{
		BsnTlv: NewBsnTlv(152),
	}
	return obj
}

type BsnTlvRoutingParam struct {
	*BsnTlv
	Value BsnRoutingParam
}

func (self *BsnTlvRoutingParam) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRoutingParam(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRoutingParam, error) {
	_bsntlvroutingparam := &BsnTlvRoutingParam{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvRoutingParam packet too short: %d < 2", decoder.Length())
	}
	_bsntlvroutingparam.Value = BsnRoutingParam(decoder.ReadUint16())
	return _bsntlvroutingparam, nil
}

func NewBsnTlvRoutingParam() *BsnTlvRoutingParam {
	obj := &BsnTlvRoutingParam{
		BsnTlv: NewBsnTlv(161),
	}
	return obj
}

type BsnTlvRxBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRxBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRxBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRxBytes, error) {
	_bsntlvrxbytes := &BsnTlvRxBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRxBytes packet too short: %d < 8", decoder.Length())
	}
	_bsntlvrxbytes.Value = uint64(decoder.ReadUint64())
	return _bsntlvrxbytes, nil
}

func NewBsnTlvRxBytes() *BsnTlvRxBytes {
	obj := &BsnTlvRxBytes{
		BsnTlv: NewBsnTlv(71),
	}
	return obj
}

type BsnTlvRxPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRxPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvRxPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRxPackets, error) {
	_bsntlvrxpackets := &BsnTlvRxPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRxPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvrxpackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvrxpackets, nil
}

func NewBsnTlvRxPackets() *BsnTlvRxPackets {
	obj := &BsnTlvRxPackets{
		BsnTlv: NewBsnTlv(2),
	}
	return obj
}

type BsnTlvSamplingRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvSamplingRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvSamplingRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSamplingRate, error) {
	_bsntlvsamplingrate := &BsnTlvSamplingRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvSamplingRate packet too short: %d < 4", decoder.Length())
	}
	_bsntlvsamplingrate.Value = uint32(decoder.ReadUint32())
	return _bsntlvsamplingrate, nil
}

func NewBsnTlvSamplingRate() *BsnTlvSamplingRate {
	obj := &BsnTlvSamplingRate{
		BsnTlv: NewBsnTlv(30),
	}
	return obj
}

type BsnTlvSetLoopbackMode struct {
	*BsnTlv
}

func (self *BsnTlvSetLoopbackMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvSetLoopbackMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSetLoopbackMode, error) {
	_bsntlvsetloopbackmode := &BsnTlvSetLoopbackMode{BsnTlv: parent}
	return _bsntlvsetloopbackmode, nil
}

func NewBsnTlvSetLoopbackMode() *BsnTlvSetLoopbackMode {
	obj := &BsnTlvSetLoopbackMode{
		BsnTlv: NewBsnTlv(74),
	}
	return obj
}

type BsnTlvStatus struct {
	*BsnTlv
	Value BsnStatus
}

func (self *BsnTlvStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvStatus(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStatus, error) {
	_bsntlvstatus := &BsnTlvStatus{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvStatus packet too short: %d < 1", decoder.Length())
	}
	_bsntlvstatus.Value = BsnStatus(decoder.ReadByte())
	return _bsntlvstatus, nil
}

func NewBsnTlvStatus() *BsnTlvStatus {
	obj := &BsnTlvStatus{
		BsnTlv: NewBsnTlv(97),
	}
	return obj
}

type BsnTlvStripMplsL2OnIngress struct {
	*BsnTlv
}

func (self *BsnTlvStripMplsL2OnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvStripMplsL2OnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripMplsL2OnIngress, error) {
	_bsntlvstripmplsl2oningress := &BsnTlvStripMplsL2OnIngress{BsnTlv: parent}
	return _bsntlvstripmplsl2oningress, nil
}

func NewBsnTlvStripMplsL2OnIngress() *BsnTlvStripMplsL2OnIngress {
	obj := &BsnTlvStripMplsL2OnIngress{
		BsnTlv: NewBsnTlv(75),
	}
	return obj
}

type BsnTlvStripMplsL3OnIngress struct {
	*BsnTlv
}

func (self *BsnTlvStripMplsL3OnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvStripMplsL3OnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripMplsL3OnIngress, error) {
	_bsntlvstripmplsl3oningress := &BsnTlvStripMplsL3OnIngress{BsnTlv: parent}
	return _bsntlvstripmplsl3oningress, nil
}

func NewBsnTlvStripMplsL3OnIngress() *BsnTlvStripMplsL3OnIngress {
	obj := &BsnTlvStripMplsL3OnIngress{
		BsnTlv: NewBsnTlv(76),
	}
	return obj
}

type BsnTlvStripVlanOnEgress struct {
	*BsnTlv
	Flags BsnStripVlan
}

func (self *BsnTlvStripVlanOnEgress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvStripVlanOnEgress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripVlanOnEgress, error) {
	_bsntlvstripvlanonegress := &BsnTlvStripVlanOnEgress{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvStripVlanOnEgress packet too short: %d < 1", decoder.Length())
	}
	_bsntlvstripvlanonegress.Flags = BsnStripVlan(decoder.ReadByte())
	return _bsntlvstripvlanonegress, nil
}

func NewBsnTlvStripVlanOnEgress() *BsnTlvStripVlanOnEgress {
	obj := &BsnTlvStripVlanOnEgress{
		BsnTlv: NewBsnTlv(73),
	}
	return obj
}

type BsnTlvSubAgentId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvSubAgentId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvSubAgentId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSubAgentId, error) {
	_bsntlvsubagentid := &BsnTlvSubAgentId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvSubAgentId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvsubagentid.Value = uint32(decoder.ReadUint32())
	return _bsntlvsubagentid, nil
}

func NewBsnTlvSubAgentId() *BsnTlvSubAgentId {
	obj := &BsnTlvSubAgentId{
		BsnTlv: NewBsnTlv(38),
	}
	return obj
}

type BsnTlvTcpDst struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTcpDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpDst, error) {
	_bsntlvtcpdst := &BsnTlvTcpDst{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpDst packet too short: %d < 2", decoder.Length())
	}
	_bsntlvtcpdst.Value = uint16(decoder.ReadUint16())
	return _bsntlvtcpdst, nil
}

func NewBsnTlvTcpDst() *BsnTlvTcpDst {
	obj := &BsnTlvTcpDst{
		BsnTlv: NewBsnTlv(66),
	}
	return obj
}

type BsnTlvTcpFlags struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpFlags) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTcpFlags(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpFlags, error) {
	_bsntlvtcpflags := &BsnTlvTcpFlags{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpFlags packet too short: %d < 2", decoder.Length())
	}
	_bsntlvtcpflags.Value = uint16(decoder.ReadUint16())
	return _bsntlvtcpflags, nil
}

func NewBsnTlvTcpFlags() *BsnTlvTcpFlags {
	obj := &BsnTlvTcpFlags{
		BsnTlv: NewBsnTlv(133),
	}
	return obj
}

type BsnTlvTcpSrc struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTcpSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpSrc, error) {
	_bsntlvtcpsrc := &BsnTlvTcpSrc{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpSrc packet too short: %d < 2", decoder.Length())
	}
	_bsntlvtcpsrc.Value = uint16(decoder.ReadUint16())
	return _bsntlvtcpsrc, nil
}

func NewBsnTlvTcpSrc() *BsnTlvTcpSrc {
	obj := &BsnTlvTcpSrc{
		BsnTlv: NewBsnTlv(65),
	}
	return obj
}

type BsnTlvTimestamp struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTimestamp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTimestamp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTimestamp, error) {
	_bsntlvtimestamp := &BsnTlvTimestamp{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTimestamp packet too short: %d < 8", decoder.Length())
	}
	_bsntlvtimestamp.Value = uint64(decoder.ReadUint64())
	return _bsntlvtimestamp, nil
}

func NewBsnTlvTimestamp() *BsnTlvTimestamp {
	obj := &BsnTlvTimestamp{
		BsnTlv: NewBsnTlv(154),
	}
	return obj
}

type BsnTlvTtl struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTtl) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTtl(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTtl, error) {
	_bsntlvttl := &BsnTlvTtl{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTtl packet too short: %d < 2", decoder.Length())
	}
	_bsntlvttl.Value = uint16(decoder.ReadUint16())
	return _bsntlvttl, nil
}

func NewBsnTlvTtl() *BsnTlvTtl {
	obj := &BsnTlvTtl{
		BsnTlv: NewBsnTlv(113),
	}
	return obj
}

type BsnTlvTunnelCapability struct {
	*BsnTlv
	Value BsnTunnelType
}

func (self *BsnTlvTunnelCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTunnelCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTunnelCapability, error) {
	_bsntlvtunnelcapability := &BsnTlvTunnelCapability{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTunnelCapability packet too short: %d < 8", decoder.Length())
	}
	_bsntlvtunnelcapability.Value = BsnTunnelType(decoder.ReadUint64())
	return _bsntlvtunnelcapability, nil
}

func NewBsnTlvTunnelCapability() *BsnTlvTunnelCapability {
	obj := &BsnTlvTunnelCapability{
		BsnTlv: NewBsnTlv(142),
	}
	return obj
}

type BsnTlvTxBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTxBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTxBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTxBytes, error) {
	_bsntlvtxbytes := &BsnTlvTxBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTxBytes packet too short: %d < 8", decoder.Length())
	}
	_bsntlvtxbytes.Value = uint64(decoder.ReadUint64())
	return _bsntlvtxbytes, nil
}

func NewBsnTlvTxBytes() *BsnTlvTxBytes {
	obj := &BsnTlvTxBytes{
		BsnTlv: NewBsnTlv(39),
	}
	return obj
}

type BsnTlvTxPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTxPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvTxPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTxPackets, error) {
	_bsntlvtxpackets := &BsnTlvTxPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTxPackets packet too short: %d < 8", decoder.Length())
	}
	_bsntlvtxpackets.Value = uint64(decoder.ReadUint64())
	return _bsntlvtxpackets, nil
}

func NewBsnTlvTxPackets() *BsnTlvTxPackets {
	obj := &BsnTlvTxPackets{
		BsnTlv: NewBsnTlv(3),
	}
	return obj
}

type BsnTlvUdfAnchor struct {
	*BsnTlv
	Value BsnUdfAnchor
}

func (self *BsnTlvUdfAnchor) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdfAnchor(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfAnchor, error) {
	_bsntlvudfanchor := &BsnTlvUdfAnchor{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfAnchor packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudfanchor.Value = BsnUdfAnchor(decoder.ReadUint16())
	return _bsntlvudfanchor, nil
}

func NewBsnTlvUdfAnchor() *BsnTlvUdfAnchor {
	obj := &BsnTlvUdfAnchor{
		BsnTlv: NewBsnTlv(16),
	}
	return obj
}

type BsnTlvUdfCapability struct {
	*BsnTlv
	Value BsnUdfMode
}

func (self *BsnTlvUdfCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdfCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfCapability, error) {
	_bsntlvudfcapability := &BsnTlvUdfCapability{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvUdfCapability packet too short: %d < 1", decoder.Length())
	}
	_bsntlvudfcapability.Value = BsnUdfMode(decoder.ReadByte())
	return _bsntlvudfcapability, nil
}

func NewBsnTlvUdfCapability() *BsnTlvUdfCapability {
	obj := &BsnTlvUdfCapability{
		BsnTlv: NewBsnTlv(180),
	}
	return obj
}

type BsnTlvUdfId struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdfId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfId, error) {
	_bsntlvudfid := &BsnTlvUdfId{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfId packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudfid.Value = uint16(decoder.ReadUint16())
	return _bsntlvudfid, nil
}

func NewBsnTlvUdfId() *BsnTlvUdfId {
	obj := &BsnTlvUdfId{
		BsnTlv: NewBsnTlv(15),
	}
	return obj
}

type BsnTlvUdfLength struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfLength) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdfLength(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfLength, error) {
	_bsntlvudflength := &BsnTlvUdfLength{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfLength packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudflength.Value = uint16(decoder.ReadUint16())
	return _bsntlvudflength, nil
}

func NewBsnTlvUdfLength() *BsnTlvUdfLength {
	obj := &BsnTlvUdfLength{
		BsnTlv: NewBsnTlv(18),
	}
	return obj
}

type BsnTlvUdfOffset struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfOffset) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdfOffset(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfOffset, error) {
	_bsntlvudfoffset := &BsnTlvUdfOffset{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfOffset packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudfoffset.Value = uint16(decoder.ReadUint16())
	return _bsntlvudfoffset, nil
}

func NewBsnTlvUdfOffset() *BsnTlvUdfOffset {
	obj := &BsnTlvUdfOffset{
		BsnTlv: NewBsnTlv(17),
	}
	return obj
}

type BsnTlvUdpDst struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdpDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdpDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdpDst, error) {
	_bsntlvudpdst := &BsnTlvUdpDst{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdpDst packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudpdst.Value = uint16(decoder.ReadUint16())
	return _bsntlvudpdst, nil
}

func NewBsnTlvUdpDst() *BsnTlvUdpDst {
	obj := &BsnTlvUdpDst{
		BsnTlv: NewBsnTlv(37),
	}
	return obj
}

type BsnTlvUdpSrc struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdpSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUdpSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdpSrc, error) {
	_bsntlvudpsrc := &BsnTlvUdpSrc{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdpSrc packet too short: %d < 2", decoder.Length())
	}
	_bsntlvudpsrc.Value = uint16(decoder.ReadUint16())
	return _bsntlvudpsrc, nil
}

func NewBsnTlvUdpSrc() *BsnTlvUdpSrc {
	obj := &BsnTlvUdpSrc{
		BsnTlv: NewBsnTlv(36),
	}
	return obj
}

type BsnTlvUint32 struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUint32) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUint32(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUint32, error) {
	_bsntlvuint32 := &BsnTlvUint32{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUint32 packet too short: %d < 4", decoder.Length())
	}
	_bsntlvuint32.Value = uint32(decoder.ReadUint32())
	return _bsntlvuint32, nil
}

func NewBsnTlvUint32() *BsnTlvUint32 {
	obj := &BsnTlvUint32{
		BsnTlv: NewBsnTlv(167),
	}
	return obj
}

type BsnTlvUint64List struct {
	*BsnTlv
	Value []*Uint64
}

func (self *BsnTlvUint64List) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUint64List(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUint64List, error) {
	_bsntlvuint64list := &BsnTlvUint64List{BsnTlv: parent}

	for decoder.Length() >= 8 {
		item, err := DecodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		_bsntlvuint64list.Value = append(_bsntlvuint64list.Value, item)
	}
	return _bsntlvuint64list, nil
}

func NewBsnTlvUint64List() *BsnTlvUint64List {
	obj := &BsnTlvUint64List{
		BsnTlv: NewBsnTlv(119),
	}
	return obj
}

type BsnTlvUnicastQueryTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnicastQueryTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUnicastQueryTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnicastQueryTimeout, error) {
	_bsntlvunicastquerytimeout := &BsnTlvUnicastQueryTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnicastQueryTimeout packet too short: %d < 4", decoder.Length())
	}
	_bsntlvunicastquerytimeout.Value = uint32(decoder.ReadUint32())
	return _bsntlvunicastquerytimeout, nil
}

func NewBsnTlvUnicastQueryTimeout() *BsnTlvUnicastQueryTimeout {
	obj := &BsnTlvUnicastQueryTimeout{
		BsnTlv: NewBsnTlv(9),
	}
	return obj
}

type BsnTlvUnicastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnicastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUnicastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnicastRate, error) {
	_bsntlvunicastrate := &BsnTlvUnicastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnicastRate packet too short: %d < 4", decoder.Length())
	}
	_bsntlvunicastrate.Value = uint32(decoder.ReadUint32())
	return _bsntlvunicastrate, nil
}

func NewBsnTlvUnicastRate() *BsnTlvUnicastRate {
	obj := &BsnTlvUnicastRate{
		BsnTlv: NewBsnTlv(93),
	}
	return obj
}

type BsnTlvUnknownMulticastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnknownMulticastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUnknownMulticastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnknownMulticastRate, error) {
	_bsntlvunknownmulticastrate := &BsnTlvUnknownMulticastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnknownMulticastRate packet too short: %d < 4", decoder.Length())
	}
	_bsntlvunknownmulticastrate.Value = uint32(decoder.ReadUint32())
	return _bsntlvunknownmulticastrate, nil
}

func NewBsnTlvUnknownMulticastRate() *BsnTlvUnknownMulticastRate {
	obj := &BsnTlvUnknownMulticastRate{
		BsnTlv: NewBsnTlv(92),
	}
	return obj
}

type BsnTlvUntagged struct {
	*BsnTlv
}

func (self *BsnTlvUntagged) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUntagged(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUntagged, error) {
	_bsntlvuntagged := &BsnTlvUntagged{BsnTlv: parent}
	return _bsntlvuntagged, nil
}

func NewBsnTlvUntagged() *BsnTlvUntagged {
	obj := &BsnTlvUntagged{
		BsnTlv: NewBsnTlv(106),
	}
	return obj
}

type BsnTlvUpgrade struct {
	*BsnTlv
	Value BsnUpgrade
}

func (self *BsnTlvUpgrade) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUpgrade(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUpgrade, error) {
	_bsntlvupgrade := &BsnTlvUpgrade{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUpgrade packet too short: %d < 2", decoder.Length())
	}
	_bsntlvupgrade.Value = BsnUpgrade(decoder.ReadUint16())
	return _bsntlvupgrade, nil
}

func NewBsnTlvUpgrade() *BsnTlvUpgrade {
	obj := &BsnTlvUpgrade{
		BsnTlv: NewBsnTlv(164),
	}
	return obj
}

type BsnTlvUriScheme struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvUriScheme) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUriScheme(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUriScheme, error) {
	_bsntlvurischeme := &BsnTlvUriScheme{BsnTlv: parent}
	_bsntlvurischeme.Value = decoder.Read(decoder.Length())
	return _bsntlvurischeme, nil
}

func NewBsnTlvUriScheme() *BsnTlvUriScheme {
	obj := &BsnTlvUriScheme{
		BsnTlv: NewBsnTlv(153),
	}
	return obj
}

type BsnTlvUsePacketState struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvUsePacketState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUsePacketState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUsePacketState, error) {
	_bsntlvusepacketstate := &BsnTlvUsePacketState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvUsePacketState packet too short: %d < 1", decoder.Length())
	}
	_bsntlvusepacketstate.Value = uint8(decoder.ReadByte())
	return _bsntlvusepacketstate, nil
}

func NewBsnTlvUsePacketState() *BsnTlvUsePacketState {
	obj := &BsnTlvUsePacketState{
		BsnTlv: NewBsnTlv(96),
	}
	return obj
}

type BsnTlvUserConfigured struct {
	*BsnTlv
}

func (self *BsnTlvUserConfigured) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvUserConfigured(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUserConfigured, error) {
	_bsntlvuserconfigured := &BsnTlvUserConfigured{BsnTlv: parent}
	return _bsntlvuserconfigured, nil
}

func NewBsnTlvUserConfigured() *BsnTlvUserConfigured {
	obj := &BsnTlvUserConfigured{
		BsnTlv: NewBsnTlv(166),
	}
	return obj
}

type BsnTlvVfi struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVfi) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVfi(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVfi, error) {
	_bsntlvvfi := &BsnTlvVfi{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVfi packet too short: %d < 2", decoder.Length())
	}
	_bsntlvvfi.Value = uint16(decoder.ReadUint16())
	return _bsntlvvfi, nil
}

func NewBsnTlvVfi() *BsnTlvVfi {
	obj := &BsnTlvVfi{
		BsnTlv: NewBsnTlv(99),
	}
	return obj
}

type BsnTlvVfpClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVfpClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVfpClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVfpClassId, error) {
	_bsntlvvfpclassid := &BsnTlvVfpClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVfpClassId packet too short: %d < 4", decoder.Length())
	}
	_bsntlvvfpclassid.Value = uint32(decoder.ReadUint32())
	return _bsntlvvfpclassid, nil
}

func NewBsnTlvVfpClassId() *BsnTlvVfpClassId {
	obj := &BsnTlvVfpClassId{
		BsnTlv: NewBsnTlv(107),
	}
	return obj
}

type BsnTlvVirtual struct {
	*BsnTlv
}

func (self *BsnTlvVirtual) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVirtual(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVirtual, error) {
	_bsntlvvirtual := &BsnTlvVirtual{BsnTlv: parent}
	return _bsntlvvirtual, nil
}

func NewBsnTlvVirtual() *BsnTlvVirtual {
	obj := &BsnTlvVirtual{
		BsnTlv: NewBsnTlv(158),
	}
	return obj
}

type BsnTlvVlanMacList struct {
	*BsnTlv
	Key []*BsnVlanMac
}

func (self *BsnTlvVlanMacList) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVlanMacList(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanMacList, error) {
	_bsntlvvlanmaclist := &BsnTlvVlanMacList{BsnTlv: parent}

	for decoder.Length() >= 8 {
		item, err := DecodeBsnVlanMac(decoder)
		if err != nil {
			return nil, err
		}
		_bsntlvvlanmaclist.Key = append(_bsntlvvlanmaclist.Key, item)
	}
	return _bsntlvvlanmaclist, nil
}

func NewBsnTlvVlanMacList() *BsnTlvVlanMacList {
	obj := &BsnTlvVlanMacList{
		BsnTlv: NewBsnTlv(98),
	}
	return obj
}

type BsnTlvVlanPcp struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvVlanPcp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVlanPcp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanPcp, error) {
	_bsntlvvlanpcp := &BsnTlvVlanPcp{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvVlanPcp packet too short: %d < 1", decoder.Length())
	}
	_bsntlvvlanpcp.Value = uint8(decoder.ReadByte())
	return _bsntlvvlanpcp, nil
}

func NewBsnTlvVlanPcp() *BsnTlvVlanPcp {
	obj := &BsnTlvVlanPcp{
		BsnTlv: NewBsnTlv(72),
	}
	return obj
}

type BsnTlvVlanVid struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVlanVid) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVlanVid(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanVid, error) {
	_bsntlvvlanvid := &BsnTlvVlanVid{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVlanVid packet too short: %d < 2", decoder.Length())
	}
	_bsntlvvlanvid.Value = uint16(decoder.ReadUint16())
	return _bsntlvvlanvid, nil
}

func NewBsnTlvVlanVid() *BsnTlvVlanVid {
	obj := &BsnTlvVlanVid{
		BsnTlv: NewBsnTlv(6),
	}
	return obj
}

type BsnTlvVlanVidMask struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVlanVidMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVlanVidMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanVidMask, error) {
	_bsntlvvlanvidmask := &BsnTlvVlanVidMask{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVlanVidMask packet too short: %d < 2", decoder.Length())
	}
	_bsntlvvlanvidmask.Value = uint16(decoder.ReadUint16())
	return _bsntlvvlanvidmask, nil
}

func NewBsnTlvVlanVidMask() *BsnTlvVlanVidMask {
	obj := &BsnTlvVlanVidMask{
		BsnTlv: NewBsnTlv(77),
	}
	return obj
}

type BsnTlvVni struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVni) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVni(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVni, error) {
	_bsntlvvni := &BsnTlvVni{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVni packet too short: %d < 4", decoder.Length())
	}
	_bsntlvvni.Value = uint32(decoder.ReadUint32())
	return _bsntlvvni, nil
}

func NewBsnTlvVni() *BsnTlvVni {
	obj := &BsnTlvVni{
		BsnTlv: NewBsnTlv(86),
	}
	return obj
}

type BsnTlvVpnKey struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVpnKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVpnKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVpnKey, error) {
	_bsntlvvpnkey := &BsnTlvVpnKey{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVpnKey packet too short: %d < 4", decoder.Length())
	}
	_bsntlvvpnkey.Value = uint32(decoder.ReadUint32())
	return _bsntlvvpnkey, nil
}

func NewBsnTlvVpnKey() *BsnTlvVpnKey {
	obj := &BsnTlvVpnKey{
		BsnTlv: NewBsnTlv(111),
	}
	return obj
}

type BsnTlvVrf struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVrf) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVrf(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVrf, error) {
	_bsntlvvrf := &BsnTlvVrf{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVrf packet too short: %d < 4", decoder.Length())
	}
	_bsntlvvrf.Value = uint32(decoder.ReadUint32())
	return _bsntlvvrf, nil
}

func NewBsnTlvVrf() *BsnTlvVrf {
	obj := &BsnTlvVrf{
		BsnTlv: NewBsnTlv(19),
	}
	return obj
}

type BsnTlvVxlanEgressLag struct {
	*BsnTlv
}

func (self *BsnTlvVxlanEgressLag) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnTlvVxlanEgressLag(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVxlanEgressLag, error) {
	_bsntlvvxlanegresslag := &BsnTlvVxlanEgressLag{BsnTlv: parent}
	return _bsntlvvxlanegresslag, nil
}

func NewBsnTlvVxlanEgressLag() *BsnTlvVxlanEgressLag {
	obj := &BsnTlvVxlanEgressLag{
		BsnTlv: NewBsnTlv(117),
	}
	return obj
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	obj := &BsnVport{}
	obj.Type = _type
	return obj
}

type BsnVlanCounterStatsEntry struct {
	Length  uint16
	VlanVid uint16
	Values  []*Uint64
}

func (self *BsnVlanCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVlanCounterStatsEntry(decoder *goloxi.Decoder) (*BsnVlanCounterStatsEntry, error) {
	_bsnvlancounterstatsentry := &BsnVlanCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVlanCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_bsnvlancounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsnvlancounterstatsentry.Length), 2+0)
	_bsnvlancounterstatsentry.VlanVid = uint16(decoder.ReadUint16())
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := DecodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		_bsnvlancounterstatsentry.Values = append(_bsnvlancounterstatsentry.Values, item)
	}
	return _bsnvlancounterstatsentry, nil
}

func NewBsnVlanCounterStatsEntry() *BsnVlanCounterStatsEntry {
	obj := &BsnVlanCounterStatsEntry{}
	return obj
}

type BsnVlanMac struct {
	VlanVid uint16
	Mac     net.HardwareAddr
}

func (self *BsnVlanMac) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.Write(self.Mac)

	return nil
}

func DecodeBsnVlanMac(decoder *goloxi.Decoder) (*BsnVlanMac, error) {
	_bsnvlanmac := &BsnVlanMac{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVlanMac packet too short: %d < 8", decoder.Length())
	}
	_bsnvlanmac.VlanVid = uint16(decoder.ReadUint16())
	_bsnvlanmac.Mac = net.HardwareAddr(decoder.Read(6))
	return _bsnvlanmac, nil
}

func NewBsnVlanMac() *BsnVlanMac {
	obj := &BsnVlanMac{}
	return obj
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	_bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 60 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 60", decoder.Length())
	}
	_bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	_bsnvportl2gre.PortNo.Decode(decoder)
	_bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	_bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	_bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	_bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	_bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	_bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	obj := &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
	return obj
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	_bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	_bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	_bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	obj := &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
	return obj
}

type BsnVrfCounterStatsEntry struct {
	Length uint16
	Vrf    uint32
	Values []*Uint64
}

func (self *BsnVrfCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vrf))
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVrfCounterStatsEntry(decoder *goloxi.Decoder) (*BsnVrfCounterStatsEntry, error) {
	_bsnvrfcounterstatsentry := &BsnVrfCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVrfCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_bsnvrfcounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bsnvrfcounterstatsentry.Length), 2+0)
	decoder.Skip(2)
	_bsnvrfcounterstatsentry.Vrf = uint32(decoder.ReadUint32())

	for decoder.Length() >= 8 {
		item, err := DecodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		_bsnvrfcounterstatsentry.Values = append(_bsnvrfcounterstatsentry.Values, item)
	}
	return _bsnvrfcounterstatsentry, nil
}

func NewBsnVrfCounterStatsEntry() *BsnVrfCounterStatsEntry {
	obj := &BsnVrfCounterStatsEntry{}
	return obj
}

type Bucket struct {
	Len        uint16
	Weight     uint16
	WatchPort  PortNo
	WatchGroup uint32
	Actions    []IAction
}

func (self *Bucket) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Len))
	encoder.PutUint16(uint16(self.Weight))
	self.WatchPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.WatchGroup))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBucket(decoder *goloxi.Decoder) (*Bucket, error) {
	_bucket := &Bucket{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("Bucket packet too short: %d < 16", decoder.Length())
	}
	_bucket.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bucket.Len), 2+0)
	_bucket.Weight = uint16(decoder.ReadUint16())
	_bucket.WatchPort.Decode(decoder)
	_bucket.WatchGroup = uint32(decoder.ReadUint32())
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_bucket.Actions = append(_bucket.Actions, item)
	}
	return _bucket, nil
}

func NewBucket() *Bucket {
	obj := &Bucket{}
	return obj
}

type BucketCounter struct {
	PacketCount uint64
	ByteCount   uint64
}

func (self *BucketCounter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))

	return nil
}

func DecodeBucketCounter(decoder *goloxi.Decoder) (*BucketCounter, error) {
	_bucketcounter := &BucketCounter{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BucketCounter packet too short: %d < 16", decoder.Length())
	}
	_bucketcounter.PacketCount = uint64(decoder.ReadUint64())
	_bucketcounter.ByteCount = uint64(decoder.ReadUint64())
	return _bucketcounter, nil
}

func NewBucketCounter() *BucketCounter {
	obj := &BucketCounter{}
	return obj
}

type BundleProp struct {
	Type   uint16
	Length uint16
}

type IBundleProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BundleProp) GetType() uint16 {
	return self.Type
}

func (self *BundleProp) GetLength() uint16 {
	return self.Length
}

func (self *BundleProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeBundleProp(decoder *goloxi.Decoder) (IBundleProp, error) {
	_bundleprop := &BundleProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BundleProp packet too short: %d < 4", decoder.Length())
	}
	_bundleprop.Type = uint16(decoder.ReadUint16())
	_bundleprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bundleprop.Length), 2+2)

	switch _bundleprop.Type {
	case 65535:
		return DecodeBundlePropExperimenter(_bundleprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BundleProp'", _bundleprop.Type)
	}
}

func NewBundleProp(_type uint16) *BundleProp {
	obj := &BundleProp{}
	obj.Type = _type
	return obj
}

type BundlePropExperimenter struct {
	*BundleProp
	Experimenter uint32
	ExpType      uint32
}

type IBundlePropExperimenter interface {
	IBundleProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *BundlePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *BundlePropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *BundlePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BundleProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodeBundlePropExperimenter(parent *BundleProp, decoder *goloxi.Decoder) (IBundlePropExperimenter, error) {
	_bundlepropexperimenter := &BundlePropExperimenter{BundleProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BundlePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_bundlepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_bundlepropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return _bundlepropexperimenter, nil
}

func NewBundlePropExperimenter(_experimenter uint32) *BundlePropExperimenter {
	obj := &BundlePropExperimenter{
		BundleProp: NewBundleProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type FlowMonitorEntry struct {
	MonitorId uint32
	OutPort   uint32
	OutGroup  uint32
	Flags     FlowMonitorFlags
	TableId   uint8
	Command   FlowMonitorCommand
	Match     Match
}

func (self *FlowMonitorEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MonitorId))
	encoder.PutUint32(uint32(self.OutPort))
	encoder.PutUint32(uint32(self.OutGroup))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Command))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func DecodeFlowMonitorEntry(decoder *goloxi.Decoder) (*FlowMonitorEntry, error) {
	_flowmonitorentry := &FlowMonitorEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("FlowMonitorEntry packet too short: %d < 24", decoder.Length())
	}
	_flowmonitorentry.MonitorId = uint32(decoder.ReadUint32())
	_flowmonitorentry.OutPort = uint32(decoder.ReadUint32())
	_flowmonitorentry.OutGroup = uint32(decoder.ReadUint32())
	_flowmonitorentry.Flags = FlowMonitorFlags(decoder.ReadUint16())
	_flowmonitorentry.TableId = uint8(decoder.ReadByte())
	_flowmonitorentry.Command = FlowMonitorCommand(decoder.ReadByte())
	if err := _flowmonitorentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return _flowmonitorentry, nil
}

func NewFlowMonitorEntry() *FlowMonitorEntry {
	obj := &FlowMonitorEntry{}
	return obj
}

type FlowMonitorReplyEntry struct {
	Length uint16
	Event  FlowUpdateEvent
}

type IFlowMonitorReplyEntry interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() FlowUpdateEvent
}

func (self *FlowMonitorReplyEntry) GetLength() uint16 {
	return self.Length
}

func (self *FlowMonitorReplyEntry) GetEvent() FlowUpdateEvent {
	return self.Event
}

func (self *FlowMonitorReplyEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func DecodeFlowMonitorReplyEntry(decoder *goloxi.Decoder) (IFlowMonitorReplyEntry, error) {
	_flowmonitorreplyentry := &FlowMonitorReplyEntry{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("FlowMonitorReplyEntry packet too short: %d < 4", decoder.Length())
	}
	_flowmonitorreplyentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_flowmonitorreplyentry.Length), 2+0)
	_flowmonitorreplyentry.Event = FlowUpdateEvent(decoder.ReadUint16())

	switch _flowmonitorreplyentry.Event {
	case 0:
		return DecodeFlowUpdateFullInitial(_flowmonitorreplyentry, decoder)
	case 1:
		return DecodeFlowUpdateFullAdded(_flowmonitorreplyentry, decoder)
	case 2:
		return DecodeFlowUpdateFullRemoved(_flowmonitorreplyentry, decoder)
	case 3:
		return DecodeFlowUpdateFullModified(_flowmonitorreplyentry, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'FlowMonitorReplyEntry'", _flowmonitorreplyentry.Event)
	}
}

func NewFlowMonitorReplyEntry(_event FlowUpdateEvent) *FlowMonitorReplyEntry {
	obj := &FlowMonitorReplyEntry{}
	obj.Event = _event
	return obj
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Flags        FlowModFlags
	Importance   uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.Importance))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	_flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 56", decoder.Length())
	}
	_flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_flowstatsentry.Length), 2+0)
	_flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_flowstatsentry.DurationSec = uint32(decoder.ReadUint32())
	_flowstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	_flowstatsentry.Priority = uint16(decoder.ReadUint16())
	_flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	_flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	_flowstatsentry.Flags = FlowModFlags(decoder.ReadUint16())
	_flowstatsentry.Importance = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	_flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	_flowstatsentry.PacketCount = uint64(decoder.ReadUint64())
	_flowstatsentry.ByteCount = uint64(decoder.ReadUint64())
	if err := _flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowstatsentry.Instructions = append(_flowstatsentry.Instructions, item)
	}
	return _flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	obj := &FlowStatsEntry{}
	return obj
}

type FlowUpdateFullAdded struct {
	*FlowMonitorReplyEntry
	TableId      uint8
	Reason       uint8
	IdleTimeout  uint16
	HardTimeout  uint16
	Priority     uint16
	Cookie       uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowUpdateFullAdded) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMonitorReplyEntry.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowUpdateFullAdded(parent *FlowMonitorReplyEntry, decoder *goloxi.Decoder) (*FlowUpdateFullAdded, error) {
	_flowupdatefulladded := &FlowUpdateFullAdded{FlowMonitorReplyEntry: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("FlowUpdateFullAdded packet too short: %d < 28", decoder.Length())
	}
	_flowupdatefulladded.TableId = uint8(decoder.ReadByte())
	_flowupdatefulladded.Reason = uint8(decoder.ReadByte())
	_flowupdatefulladded.IdleTimeout = uint16(decoder.ReadUint16())
	_flowupdatefulladded.HardTimeout = uint16(decoder.ReadUint16())
	_flowupdatefulladded.Priority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	_flowupdatefulladded.Cookie = uint64(decoder.ReadUint64())
	if err := _flowupdatefulladded.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowupdatefulladded.Instructions = append(_flowupdatefulladded.Instructions, item)
	}
	return _flowupdatefulladded, nil
}

func NewFlowUpdateFullAdded() *FlowUpdateFullAdded {
	obj := &FlowUpdateFullAdded{
		FlowMonitorReplyEntry: NewFlowMonitorReplyEntry(1),
	}
	return obj
}

type FlowUpdateFullInitial struct {
	*FlowMonitorReplyEntry
	TableId      uint8
	Reason       uint8
	IdleTimeout  uint16
	HardTimeout  uint16
	Priority     uint16
	Cookie       uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowUpdateFullInitial) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMonitorReplyEntry.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowUpdateFullInitial(parent *FlowMonitorReplyEntry, decoder *goloxi.Decoder) (*FlowUpdateFullInitial, error) {
	_flowupdatefullinitial := &FlowUpdateFullInitial{FlowMonitorReplyEntry: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("FlowUpdateFullInitial packet too short: %d < 28", decoder.Length())
	}
	_flowupdatefullinitial.TableId = uint8(decoder.ReadByte())
	_flowupdatefullinitial.Reason = uint8(decoder.ReadByte())
	_flowupdatefullinitial.IdleTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullinitial.HardTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullinitial.Priority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	_flowupdatefullinitial.Cookie = uint64(decoder.ReadUint64())
	if err := _flowupdatefullinitial.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowupdatefullinitial.Instructions = append(_flowupdatefullinitial.Instructions, item)
	}
	return _flowupdatefullinitial, nil
}

func NewFlowUpdateFullInitial() *FlowUpdateFullInitial {
	obj := &FlowUpdateFullInitial{
		FlowMonitorReplyEntry: NewFlowMonitorReplyEntry(0),
	}
	return obj
}

type FlowUpdateFullModified struct {
	*FlowMonitorReplyEntry
	TableId      uint8
	Reason       uint8
	IdleTimeout  uint16
	HardTimeout  uint16
	Priority     uint16
	Cookie       uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMonitorReplyEntry.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowUpdateFullModified(parent *FlowMonitorReplyEntry, decoder *goloxi.Decoder) (*FlowUpdateFullModified, error) {
	_flowupdatefullmodified := &FlowUpdateFullModified{FlowMonitorReplyEntry: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("FlowUpdateFullModified packet too short: %d < 28", decoder.Length())
	}
	_flowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	_flowupdatefullmodified.Reason = uint8(decoder.ReadByte())
	_flowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	_flowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := _flowupdatefullmodified.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowupdatefullmodified.Instructions = append(_flowupdatefullmodified.Instructions, item)
	}
	return _flowupdatefullmodified, nil
}

func NewFlowUpdateFullModified() *FlowUpdateFullModified {
	obj := &FlowUpdateFullModified{
		FlowMonitorReplyEntry: NewFlowMonitorReplyEntry(3),
	}
	return obj
}

type FlowUpdateFullRemoved struct {
	*FlowMonitorReplyEntry
	TableId      uint8
	Reason       uint8
	IdleTimeout  uint16
	HardTimeout  uint16
	Priority     uint16
	Cookie       uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowUpdateFullRemoved) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMonitorReplyEntry.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowUpdateFullRemoved(parent *FlowMonitorReplyEntry, decoder *goloxi.Decoder) (*FlowUpdateFullRemoved, error) {
	_flowupdatefullremoved := &FlowUpdateFullRemoved{FlowMonitorReplyEntry: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("FlowUpdateFullRemoved packet too short: %d < 28", decoder.Length())
	}
	_flowupdatefullremoved.TableId = uint8(decoder.ReadByte())
	_flowupdatefullremoved.Reason = uint8(decoder.ReadByte())
	_flowupdatefullremoved.IdleTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullremoved.HardTimeout = uint16(decoder.ReadUint16())
	_flowupdatefullremoved.Priority = uint16(decoder.ReadUint16())
	decoder.Skip(4)
	_flowupdatefullremoved.Cookie = uint64(decoder.ReadUint64())
	if err := _flowupdatefullremoved.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowupdatefullremoved.Instructions = append(_flowupdatefullremoved.Instructions, item)
	}
	return _flowupdatefullremoved, nil
}

func NewFlowUpdateFullRemoved() *FlowUpdateFullRemoved {
	obj := &FlowUpdateFullRemoved{
		FlowMonitorReplyEntry: NewFlowMonitorReplyEntry(2),
	}
	return obj
}

type GroupDescStatsEntry struct {
	Length    uint16
	GroupType GroupType
	GroupId   uint32
	Buckets   []*Bucket
}

func (self *GroupDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.GroupType))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.GroupId))
	for _, obj := range self.Buckets {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeGroupDescStatsEntry(decoder *goloxi.Decoder) (*GroupDescStatsEntry, error) {
	_groupdescstatsentry := &GroupDescStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupDescStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_groupdescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_groupdescstatsentry.Length), 2+0)
	_groupdescstatsentry.GroupType = GroupType(decoder.ReadByte())
	decoder.Skip(1)
	_groupdescstatsentry.GroupId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := DecodeBucket(decoder)
		if err != nil {
			return nil, err
		}
		_groupdescstatsentry.Buckets = append(_groupdescstatsentry.Buckets, item)
	}
	return _groupdescstatsentry, nil
}

func NewGroupDescStatsEntry() *GroupDescStatsEntry {
	obj := &GroupDescStatsEntry{}
	return obj
}

type GroupStatsEntry struct {
	Length       uint16
	GroupId      uint32
	RefCount     uint32
	PacketCount  uint64
	ByteCount    uint64
	DurationSec  uint32
	DurationNsec uint32
	BucketStats  []*BucketCounter
}

func (self *GroupStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.PutUint32(uint32(self.RefCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.BucketStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeGroupStatsEntry(decoder *goloxi.Decoder) (*GroupStatsEntry, error) {
	_groupstatsentry := &GroupStatsEntry{}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("GroupStatsEntry packet too short: %d < 40", decoder.Length())
	}
	_groupstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_groupstatsentry.Length), 2+0)
	decoder.Skip(2)
	_groupstatsentry.GroupId = uint32(decoder.ReadUint32())
	_groupstatsentry.RefCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	_groupstatsentry.PacketCount = uint64(decoder.ReadUint64())
	_groupstatsentry.ByteCount = uint64(decoder.ReadUint64())
	_groupstatsentry.DurationSec = uint32(decoder.ReadUint32())
	_groupstatsentry.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := DecodeBucketCounter(decoder)
		if err != nil {
			return nil, err
		}
		_groupstatsentry.BucketStats = append(_groupstatsentry.BucketStats, item)
	}
	return _groupstatsentry, nil
}

func NewGroupStatsEntry() *GroupStatsEntry {
	obj := &GroupStatsEntry{}
	return obj
}

type HelloElem struct {
	Type   uint16
	Length uint16
}

type IHelloElem interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *HelloElem) GetType() uint16 {
	return self.Type
}

func (self *HelloElem) GetLength() uint16 {
	return self.Length
}

func (self *HelloElem) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeHelloElem(decoder *goloxi.Decoder) (IHelloElem, error) {
	_helloelem := &HelloElem{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("HelloElem packet too short: %d < 4", decoder.Length())
	}
	_helloelem.Type = uint16(decoder.ReadUint16())
	_helloelem.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_helloelem.Length), 2+2)

	switch _helloelem.Type {
	case 1:
		return DecodeHelloElemVersionbitmap(_helloelem, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'HelloElem'", _helloelem.Type)
	}
}

func NewHelloElem(_type uint16) *HelloElem {
	obj := &HelloElem{}
	obj.Type = _type
	return obj
}

type HelloElemVersionbitmap struct {
	*HelloElem
	Bitmaps []*Uint32
}

func (self *HelloElemVersionbitmap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.HelloElem.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Bitmaps {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeHelloElemVersionbitmap(parent *HelloElem, decoder *goloxi.Decoder) (*HelloElemVersionbitmap, error) {
	_helloelemversionbitmap := &HelloElemVersionbitmap{HelloElem: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_helloelemversionbitmap.Bitmaps = append(_helloelemversionbitmap.Bitmaps, item)
	}
	return _helloelemversionbitmap, nil
}

func NewHelloElemVersionbitmap() *HelloElemVersionbitmap {
	obj := &HelloElemVersionbitmap{
		HelloElem: NewHelloElem(1),
	}
	return obj
}

type InstructionId struct {
	Type uint16
	Len  uint16
}

type IInstructionId interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *InstructionId) GetType() uint16 {
	return self.Type
}

func (self *InstructionId) GetLen() uint16 {
	return self.Len
}

func (self *InstructionId) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func DecodeInstructionId(decoder *goloxi.Decoder) (IInstructionId, error) {
	_instructionid := &InstructionId{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionId packet too short: %d < 4", decoder.Length())
	}
	_instructionid.Type = uint16(decoder.ReadUint16())
	_instructionid.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_instructionid.Len), 2+2)

	switch _instructionid.Type {
	case 1:
		return DecodeInstructionIdGotoTable(_instructionid, decoder)
	case 2:
		return DecodeInstructionIdWriteMetadata(_instructionid, decoder)
	case 3:
		return DecodeInstructionIdWriteActions(_instructionid, decoder)
	case 4:
		return DecodeInstructionIdApplyActions(_instructionid, decoder)
	case 5:
		return DecodeInstructionIdClearActions(_instructionid, decoder)
	case 6:
		return DecodeInstructionIdMeter(_instructionid, decoder)
	case 65535:
		return DecodeInstructionIdExperimenter(_instructionid, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionId'", _instructionid.Type)
	}
}

func NewInstructionId(_type uint16) *InstructionId {
	obj := &InstructionId{}
	obj.Type = _type
	return obj
}

type InstructionIdApplyActions struct {
	*InstructionId
}

func (self *InstructionIdApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdApplyActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdApplyActions, error) {
	_instructionidapplyactions := &InstructionIdApplyActions{InstructionId: parent}
	return _instructionidapplyactions, nil
}

func NewInstructionIdApplyActions() *InstructionIdApplyActions {
	obj := &InstructionIdApplyActions{
		InstructionId: NewInstructionId(4),
	}
	return obj
}

type InstructionIdExperimenter struct {
	*InstructionId
	Experimenter uint32
}

type IInstructionIdExperimenter interface {
	IInstructionId
	GetExperimenter() uint32
}

func (self *InstructionIdExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *InstructionIdExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func DecodeInstructionIdExperimenter(parent *InstructionId, decoder *goloxi.Decoder) (IInstructionIdExperimenter, error) {
	_instructionidexperimenter := &InstructionIdExperimenter{InstructionId: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionIdExperimenter packet too short: %d < 4", decoder.Length())
	}
	_instructionidexperimenter.Experimenter = uint32(decoder.ReadUint32())

	switch _instructionidexperimenter.Experimenter {
	case 6035143:
		return DecodeInstructionIdBsn(_instructionidexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionIdExperimenter'", _instructionidexperimenter.Experimenter)
	}
}

func NewInstructionIdExperimenter(_experimenter uint32) *InstructionIdExperimenter {
	obj := &InstructionIdExperimenter{
		InstructionId: NewInstructionId(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type InstructionIdBsn struct {
	*InstructionIdExperimenter
	Subtype uint32
}

type IInstructionIdBsn interface {
	IInstructionIdExperimenter
	GetSubtype() uint32
}

func (self *InstructionIdBsn) GetSubtype() uint32 {
	return self.Subtype
}

func (self *InstructionIdBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func DecodeInstructionIdBsn(parent *InstructionIdExperimenter, decoder *goloxi.Decoder) (IInstructionIdBsn, error) {
	_instructionidbsn := &InstructionIdBsn{InstructionIdExperimenter: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionIdBsn packet too short: %d < 4", decoder.Length())
	}
	_instructionidbsn.Subtype = uint32(decoder.ReadUint32())

	switch _instructionidbsn.Subtype {
	case 0:
		return DecodeInstructionIdBsnDisableSrcMacCheck(_instructionidbsn, decoder)
	case 1:
		return DecodeInstructionIdBsnArpOffload(_instructionidbsn, decoder)
	case 2:
		return DecodeInstructionIdBsnDhcpOffload(_instructionidbsn, decoder)
	case 4:
		return DecodeInstructionIdBsnPermit(_instructionidbsn, decoder)
	case 5:
		return DecodeInstructionIdBsnDeny(_instructionidbsn, decoder)
	case 6:
		return DecodeInstructionIdBsnPacketOfDeath(_instructionidbsn, decoder)
	case 7:
		return DecodeInstructionIdBsnPrioritizePdus(_instructionidbsn, decoder)
	case 8:
		return DecodeInstructionIdBsnRequireVlanXlate(_instructionidbsn, decoder)
	case 9:
		return DecodeInstructionIdBsnDisableVlanCounters(_instructionidbsn, decoder)
	case 10:
		return DecodeInstructionIdBsnSpanDestination(_instructionidbsn, decoder)
	case 11:
		return DecodeInstructionIdBsnAutoNegotiation(_instructionidbsn, decoder)
	case 12:
		return DecodeInstructionIdBsnInternalPriority(_instructionidbsn, decoder)
	case 13:
		return DecodeInstructionIdBsnDisableL3(_instructionidbsn, decoder)
	case 14:
		return DecodeInstructionIdBsnNdpOffload(_instructionidbsn, decoder)
	case 15:
		return DecodeInstructionIdBsnHashSelect(_instructionidbsn, decoder)
	case 16:
		return DecodeInstructionIdBsnDirectedBroadcast(_instructionidbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionIdBsn'", _instructionidbsn.Subtype)
	}
}

func NewInstructionIdBsn(_subtype uint32) *InstructionIdBsn {
	obj := &InstructionIdBsn{
		InstructionIdExperimenter: NewInstructionIdExperimenter(6035143),
	}
	obj.Subtype = _subtype
	return obj
}

type InstructionIdBsnArpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnArpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnArpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnArpOffload, error) {
	_instructionidbsnarpoffload := &InstructionIdBsnArpOffload{InstructionIdBsn: parent}
	return _instructionidbsnarpoffload, nil
}

func NewInstructionIdBsnArpOffload() *InstructionIdBsnArpOffload {
	obj := &InstructionIdBsnArpOffload{
		InstructionIdBsn: NewInstructionIdBsn(1),
	}
	return obj
}

type InstructionIdBsnAutoNegotiation struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnAutoNegotiation) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnAutoNegotiation(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnAutoNegotiation, error) {
	_instructionidbsnautonegotiation := &InstructionIdBsnAutoNegotiation{InstructionIdBsn: parent}
	return _instructionidbsnautonegotiation, nil
}

func NewInstructionIdBsnAutoNegotiation() *InstructionIdBsnAutoNegotiation {
	obj := &InstructionIdBsnAutoNegotiation{
		InstructionIdBsn: NewInstructionIdBsn(11),
	}
	return obj
}

type InstructionIdBsnDeny struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDeny) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDeny(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDeny, error) {
	_instructionidbsndeny := &InstructionIdBsnDeny{InstructionIdBsn: parent}
	return _instructionidbsndeny, nil
}

func NewInstructionIdBsnDeny() *InstructionIdBsnDeny {
	obj := &InstructionIdBsnDeny{
		InstructionIdBsn: NewInstructionIdBsn(5),
	}
	return obj
}

type InstructionIdBsnDhcpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDhcpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDhcpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDhcpOffload, error) {
	_instructionidbsndhcpoffload := &InstructionIdBsnDhcpOffload{InstructionIdBsn: parent}
	return _instructionidbsndhcpoffload, nil
}

func NewInstructionIdBsnDhcpOffload() *InstructionIdBsnDhcpOffload {
	obj := &InstructionIdBsnDhcpOffload{
		InstructionIdBsn: NewInstructionIdBsn(2),
	}
	return obj
}

type InstructionIdBsnDirectedBroadcast struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDirectedBroadcast) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDirectedBroadcast(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDirectedBroadcast, error) {
	_instructionidbsndirectedbroadcast := &InstructionIdBsnDirectedBroadcast{InstructionIdBsn: parent}
	return _instructionidbsndirectedbroadcast, nil
}

func NewInstructionIdBsnDirectedBroadcast() *InstructionIdBsnDirectedBroadcast {
	obj := &InstructionIdBsnDirectedBroadcast{
		InstructionIdBsn: NewInstructionIdBsn(16),
	}
	return obj
}

type InstructionIdBsnDisableL3 struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableL3) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDisableL3(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableL3, error) {
	_instructionidbsndisablel3 := &InstructionIdBsnDisableL3{InstructionIdBsn: parent}
	return _instructionidbsndisablel3, nil
}

func NewInstructionIdBsnDisableL3() *InstructionIdBsnDisableL3 {
	obj := &InstructionIdBsnDisableL3{
		InstructionIdBsn: NewInstructionIdBsn(13),
	}
	return obj
}

type InstructionIdBsnDisableSrcMacCheck struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableSrcMacCheck) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDisableSrcMacCheck(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableSrcMacCheck, error) {
	_instructionidbsndisablesrcmaccheck := &InstructionIdBsnDisableSrcMacCheck{InstructionIdBsn: parent}
	return _instructionidbsndisablesrcmaccheck, nil
}

func NewInstructionIdBsnDisableSrcMacCheck() *InstructionIdBsnDisableSrcMacCheck {
	obj := &InstructionIdBsnDisableSrcMacCheck{
		InstructionIdBsn: NewInstructionIdBsn(0),
	}
	return obj
}

type InstructionIdBsnDisableVlanCounters struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableVlanCounters) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnDisableVlanCounters(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableVlanCounters, error) {
	_instructionidbsndisablevlancounters := &InstructionIdBsnDisableVlanCounters{InstructionIdBsn: parent}
	return _instructionidbsndisablevlancounters, nil
}

func NewInstructionIdBsnDisableVlanCounters() *InstructionIdBsnDisableVlanCounters {
	obj := &InstructionIdBsnDisableVlanCounters{
		InstructionIdBsn: NewInstructionIdBsn(9),
	}
	return obj
}

type InstructionIdBsnHashSelect struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnHashSelect) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnHashSelect(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnHashSelect, error) {
	_instructionidbsnhashselect := &InstructionIdBsnHashSelect{InstructionIdBsn: parent}
	return _instructionidbsnhashselect, nil
}

func NewInstructionIdBsnHashSelect() *InstructionIdBsnHashSelect {
	obj := &InstructionIdBsnHashSelect{
		InstructionIdBsn: NewInstructionIdBsn(15),
	}
	return obj
}

type InstructionIdBsnInternalPriority struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnInternalPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnInternalPriority(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnInternalPriority, error) {
	_instructionidbsninternalpriority := &InstructionIdBsnInternalPriority{InstructionIdBsn: parent}
	return _instructionidbsninternalpriority, nil
}

func NewInstructionIdBsnInternalPriority() *InstructionIdBsnInternalPriority {
	obj := &InstructionIdBsnInternalPriority{
		InstructionIdBsn: NewInstructionIdBsn(12),
	}
	return obj
}

type InstructionIdBsnNdpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnNdpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnNdpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnNdpOffload, error) {
	_instructionidbsnndpoffload := &InstructionIdBsnNdpOffload{InstructionIdBsn: parent}
	return _instructionidbsnndpoffload, nil
}

func NewInstructionIdBsnNdpOffload() *InstructionIdBsnNdpOffload {
	obj := &InstructionIdBsnNdpOffload{
		InstructionIdBsn: NewInstructionIdBsn(14),
	}
	return obj
}

type InstructionIdBsnPacketOfDeath struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPacketOfDeath) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnPacketOfDeath(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPacketOfDeath, error) {
	_instructionidbsnpacketofdeath := &InstructionIdBsnPacketOfDeath{InstructionIdBsn: parent}
	return _instructionidbsnpacketofdeath, nil
}

func NewInstructionIdBsnPacketOfDeath() *InstructionIdBsnPacketOfDeath {
	obj := &InstructionIdBsnPacketOfDeath{
		InstructionIdBsn: NewInstructionIdBsn(6),
	}
	return obj
}

type InstructionIdBsnPermit struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPermit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnPermit(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPermit, error) {
	_instructionidbsnpermit := &InstructionIdBsnPermit{InstructionIdBsn: parent}
	return _instructionidbsnpermit, nil
}

func NewInstructionIdBsnPermit() *InstructionIdBsnPermit {
	obj := &InstructionIdBsnPermit{
		InstructionIdBsn: NewInstructionIdBsn(4),
	}
	return obj
}

type InstructionIdBsnPrioritizePdus struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPrioritizePdus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnPrioritizePdus(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPrioritizePdus, error) {
	_instructionidbsnprioritizepdus := &InstructionIdBsnPrioritizePdus{InstructionIdBsn: parent}
	return _instructionidbsnprioritizepdus, nil
}

func NewInstructionIdBsnPrioritizePdus() *InstructionIdBsnPrioritizePdus {
	obj := &InstructionIdBsnPrioritizePdus{
		InstructionIdBsn: NewInstructionIdBsn(7),
	}
	return obj
}

type InstructionIdBsnRequireVlanXlate struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnRequireVlanXlate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnRequireVlanXlate(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnRequireVlanXlate, error) {
	_instructionidbsnrequirevlanxlate := &InstructionIdBsnRequireVlanXlate{InstructionIdBsn: parent}
	return _instructionidbsnrequirevlanxlate, nil
}

func NewInstructionIdBsnRequireVlanXlate() *InstructionIdBsnRequireVlanXlate {
	obj := &InstructionIdBsnRequireVlanXlate{
		InstructionIdBsn: NewInstructionIdBsn(8),
	}
	return obj
}

type InstructionIdBsnSpanDestination struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnSpanDestination) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdBsnSpanDestination(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnSpanDestination, error) {
	_instructionidbsnspandestination := &InstructionIdBsnSpanDestination{InstructionIdBsn: parent}
	return _instructionidbsnspandestination, nil
}

func NewInstructionIdBsnSpanDestination() *InstructionIdBsnSpanDestination {
	obj := &InstructionIdBsnSpanDestination{
		InstructionIdBsn: NewInstructionIdBsn(10),
	}
	return obj
}

type InstructionIdClearActions struct {
	*InstructionId
}

func (self *InstructionIdClearActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdClearActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdClearActions, error) {
	_instructionidclearactions := &InstructionIdClearActions{InstructionId: parent}
	return _instructionidclearactions, nil
}

func NewInstructionIdClearActions() *InstructionIdClearActions {
	obj := &InstructionIdClearActions{
		InstructionId: NewInstructionId(5),
	}
	return obj
}

type InstructionIdGotoTable struct {
	*InstructionId
}

func (self *InstructionIdGotoTable) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdGotoTable(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdGotoTable, error) {
	_instructionidgototable := &InstructionIdGotoTable{InstructionId: parent}
	return _instructionidgototable, nil
}

func NewInstructionIdGotoTable() *InstructionIdGotoTable {
	obj := &InstructionIdGotoTable{
		InstructionId: NewInstructionId(1),
	}
	return obj
}

type InstructionIdMeter struct {
	*InstructionId
}

func (self *InstructionIdMeter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdMeter(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdMeter, error) {
	_instructionidmeter := &InstructionIdMeter{InstructionId: parent}
	return _instructionidmeter, nil
}

func NewInstructionIdMeter() *InstructionIdMeter {
	obj := &InstructionIdMeter{
		InstructionId: NewInstructionId(6),
	}
	return obj
}

type InstructionIdWriteActions struct {
	*InstructionId
}

func (self *InstructionIdWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdWriteActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdWriteActions, error) {
	_instructionidwriteactions := &InstructionIdWriteActions{InstructionId: parent}
	return _instructionidwriteactions, nil
}

func NewInstructionIdWriteActions() *InstructionIdWriteActions {
	obj := &InstructionIdWriteActions{
		InstructionId: NewInstructionId(3),
	}
	return obj
}

type InstructionIdWriteMetadata struct {
	*InstructionId
}

func (self *InstructionIdWriteMetadata) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeInstructionIdWriteMetadata(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdWriteMetadata, error) {
	_instructionidwritemetadata := &InstructionIdWriteMetadata{InstructionId: parent}
	return _instructionidwritemetadata, nil
}

func NewInstructionIdWriteMetadata() *InstructionIdWriteMetadata {
	obj := &InstructionIdWriteMetadata{
		InstructionId: NewInstructionId(2),
	}
	return obj
}

type MatchV3 struct {
	Type    uint16
	Length  uint16
	OxmList []IOxm
}

func (self *MatchV3) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.OxmList {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}
func (self *MatchV3) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("MatchV3 packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	// if self.Type != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", self.Type)
	// }
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	for decoder.Length() >= 4 {
		item, err := DecodeOxm(decoder)
		if err != nil {
			return err
		}
		self.OxmList = append(self.OxmList, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewMatchV3() *MatchV3 {
	obj := &MatchV3{}
	return obj
}

type MeterBand struct {
	Type uint16
	Len  uint16
}

type IMeterBand interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *MeterBand) GetType() uint16 {
	return self.Type
}

func (self *MeterBand) GetLen() uint16 {
	return self.Len
}

func (self *MeterBand) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func DecodeMeterBand(decoder *goloxi.Decoder) (IMeterBand, error) {
	_meterband := &MeterBand{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("MeterBand packet too short: %d < 4", decoder.Length())
	}
	_meterband.Type = uint16(decoder.ReadUint16())
	_meterband.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_meterband.Len), 2+2)

	switch _meterband.Type {
	case 1:
		return DecodeMeterBandDrop(_meterband, decoder)
	case 2:
		return DecodeMeterBandDscpRemark(_meterband, decoder)
	case 65535:
		return DecodeMeterBandExperimenter(_meterband, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'MeterBand'", _meterband.Type)
	}
}

func NewMeterBand(_type uint16) *MeterBand {
	obj := &MeterBand{}
	obj.Type = _type
	return obj
}

type MeterBandDrop struct {
	*MeterBand
	Rate      uint32
	BurstSize uint32
}

func (self *MeterBandDrop) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeMeterBandDrop(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandDrop, error) {
	_meterbanddrop := &MeterBandDrop{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandDrop packet too short: %d < 12", decoder.Length())
	}
	_meterbanddrop.Rate = uint32(decoder.ReadUint32())
	_meterbanddrop.BurstSize = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return _meterbanddrop, nil
}

func NewMeterBandDrop() *MeterBandDrop {
	obj := &MeterBandDrop{
		MeterBand: NewMeterBand(1),
	}
	return obj
}

type MeterBandDscpRemark struct {
	*MeterBand
	Rate      uint32
	BurstSize uint32
	PrecLevel uint8
}

func (self *MeterBandDscpRemark) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.PutUint8(uint8(self.PrecLevel))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeMeterBandDscpRemark(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandDscpRemark, error) {
	_meterbanddscpremark := &MeterBandDscpRemark{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandDscpRemark packet too short: %d < 12", decoder.Length())
	}
	_meterbanddscpremark.Rate = uint32(decoder.ReadUint32())
	_meterbanddscpremark.BurstSize = uint32(decoder.ReadUint32())
	_meterbanddscpremark.PrecLevel = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return _meterbanddscpremark, nil
}

func NewMeterBandDscpRemark() *MeterBandDscpRemark {
	obj := &MeterBandDscpRemark{
		MeterBand: NewMeterBand(2),
	}
	return obj
}

type MeterBandExperimenter struct {
	*MeterBand
	Rate         uint32
	BurstSize    uint32
	Experimenter uint32
}

func (self *MeterBandExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.PutUint32(uint32(self.Experimenter))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeMeterBandExperimenter(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandExperimenter, error) {
	_meterbandexperimenter := &MeterBandExperimenter{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandExperimenter packet too short: %d < 12", decoder.Length())
	}
	_meterbandexperimenter.Rate = uint32(decoder.ReadUint32())
	_meterbandexperimenter.BurstSize = uint32(decoder.ReadUint32())
	_meterbandexperimenter.Experimenter = uint32(decoder.ReadUint32())
	return _meterbandexperimenter, nil
}

func NewMeterBandExperimenter() *MeterBandExperimenter {
	obj := &MeterBandExperimenter{
		MeterBand: NewMeterBand(65535),
	}
	return obj
}

type MeterBandStats struct {
	PacketBandCount uint64
	ByteBandCount   uint64
}

func (self *MeterBandStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketBandCount))
	encoder.PutUint64(uint64(self.ByteBandCount))

	return nil
}

func DecodeMeterBandStats(decoder *goloxi.Decoder) (*MeterBandStats, error) {
	_meterbandstats := &MeterBandStats{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("MeterBandStats packet too short: %d < 16", decoder.Length())
	}
	_meterbandstats.PacketBandCount = uint64(decoder.ReadUint64())
	_meterbandstats.ByteBandCount = uint64(decoder.ReadUint64())
	return _meterbandstats, nil
}

func NewMeterBandStats() *MeterBandStats {
	obj := &MeterBandStats{}
	return obj
}

type MeterConfig struct {
	Length  uint16
	Flags   MeterFlags
	MeterId uint32
	Entries []IMeterBand
}

func (self *MeterConfig) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint32(uint32(self.MeterId))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeMeterConfig(decoder *goloxi.Decoder) (*MeterConfig, error) {
	_meterconfig := &MeterConfig{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("MeterConfig packet too short: %d < 8", decoder.Length())
	}
	_meterconfig.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_meterconfig.Length), 2+0)
	_meterconfig.Flags = MeterFlags(decoder.ReadUint16())
	_meterconfig.MeterId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := DecodeMeterBand(decoder)
		if err != nil {
			return nil, err
		}
		_meterconfig.Entries = append(_meterconfig.Entries, item)
	}
	return _meterconfig, nil
}

func NewMeterConfig() *MeterConfig {
	obj := &MeterConfig{}
	return obj
}

type MeterFeatures struct {
	MaxMeter     uint32
	BandTypes    uint32
	Capabilities uint32
	MaxBands     uint8
	MaxColor     uint8
}

func (self *MeterFeatures) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MaxMeter))
	encoder.PutUint32(uint32(self.BandTypes))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint8(uint8(self.MaxBands))
	encoder.PutUint8(uint8(self.MaxColor))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	return nil
}
func (self *MeterFeatures) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 16 {
		return fmt.Errorf("MeterFeatures packet too short: %d < 16", decoder.Length())
	}

	self.MaxMeter = uint32(decoder.ReadUint32())
	self.BandTypes = uint32(decoder.ReadUint32())
	self.Capabilities = uint32(decoder.ReadUint32())
	self.MaxBands = uint8(decoder.ReadByte())
	self.MaxColor = uint8(decoder.ReadByte())
	decoder.Skip(2)

	return nil
}

func NewMeterFeatures() *MeterFeatures {
	obj := &MeterFeatures{}
	return obj
}

type MeterStats struct {
	MeterId       uint32
	Len           uint16
	FlowCount     uint32
	PacketInCount uint64
	ByteInCount   uint64
	DurationSec   uint32
	DurationNsec  uint32
	BandStats     []*MeterBandStats
}

func (self *MeterStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MeterId))
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint32(uint32(self.FlowCount))
	encoder.PutUint64(uint64(self.PacketInCount))
	encoder.PutUint64(uint64(self.ByteInCount))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.BandStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeMeterStats(decoder *goloxi.Decoder) (*MeterStats, error) {
	_meterstats := &MeterStats{}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("MeterStats packet too short: %d < 40", decoder.Length())
	}
	_meterstats.MeterId = uint32(decoder.ReadUint32())
	_meterstats.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_meterstats.Len), 2+4)
	decoder.Skip(6)
	_meterstats.FlowCount = uint32(decoder.ReadUint32())
	_meterstats.PacketInCount = uint64(decoder.ReadUint64())
	_meterstats.ByteInCount = uint64(decoder.ReadUint64())
	_meterstats.DurationSec = uint32(decoder.ReadUint32())
	_meterstats.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := DecodeMeterBandStats(decoder)
		if err != nil {
			return nil, err
		}
		_meterstats.BandStats = append(_meterstats.BandStats, item)
	}
	return _meterstats, nil
}

func NewMeterStats() *MeterStats {
	obj := &MeterStats{}
	return obj
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := DecodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	obj := &NiciraMatch{}
	return obj
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	_niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	_niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowstats.Length), 2+0)
	_niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	_niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	_niciraflowstats.Priority = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	_niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	_niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	_niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	_niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := _niciraflowstats.Match.Decode(decoder.SliceDecoder(int(_niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowstats.Actions = append(_niciraflowstats.Actions, item)
	}
	return _niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	obj := &NiciraFlowStats{}
	return obj
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func DecodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	_niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	_niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowupdateevent.Length), 2+0)
	_niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch _niciraflowupdateevent.Event {
	case 0:
		return DecodeNiciraFlowUpdateFullAdd(_niciraflowupdateevent, decoder)
	case 1:
		return DecodeNiciraFlowUpdateFullDeleted(_niciraflowupdateevent, decoder)
	case 2:
		return DecodeNiciraFlowUpdateFullModified(_niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", _niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	obj := &NiciraFlowUpdateEvent{}
	obj.Event = _event
	return obj
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	_niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulladd.Actions = append(_niciraflowupdatefulladd.Actions, item)
	}
	return _niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	obj := &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
	return obj
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	_niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulldeleted.Actions = append(_niciraflowupdatefulldeleted.Actions, item)
	}
	return _niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	obj := &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
	return obj
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	_niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefullmodified.Actions = append(_niciraflowupdatefullmodified.Actions, item)
	}
	return _niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	obj := &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
	return obj
}

type PacketQueue struct {
	QueueId    uint32
	Port       PortNo
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	self.Port.Serialize(encoder)
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	_packetqueue := &PacketQueue{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 16", decoder.Length())
	}
	_packetqueue.QueueId = uint32(decoder.ReadUint32())
	_packetqueue.Port.Decode(decoder)
	_packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_packetqueue.Len), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := DecodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		_packetqueue.Properties = append(_packetqueue.Properties, item)
	}
	return _packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	obj := &PacketQueue{}
	return obj
}

type PortDesc struct {
	PortNo     PortNo
	Length     uint16
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Properties []IPortDescProp
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 40 {
		return fmt.Errorf("PortDesc packet too short: %d < 40", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+4)
	decoder.Skip(2)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := DecodePortDescProp(decoder)
		if err != nil {
			return err
		}
		self.Properties = append(self.Properties, item)
	}

	return nil
}

func NewPortDesc() *PortDesc {
	obj := &PortDesc{}
	return obj
}

type PortDescProp struct {
	Type   uint16
	Length uint16
}

type IPortDescProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortDescProp) GetType() uint16 {
	return self.Type
}

func (self *PortDescProp) GetLength() uint16 {
	return self.Length
}

func (self *PortDescProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodePortDescProp(decoder *goloxi.Decoder) (IPortDescProp, error) {
	_portdescprop := &PortDescProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescProp packet too short: %d < 4", decoder.Length())
	}
	_portdescprop.Type = uint16(decoder.ReadUint16())
	_portdescprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_portdescprop.Length), 2+2)

	switch _portdescprop.Type {
	case 0:
		return DecodePortDescPropEthernet(_portdescprop, decoder)
	case 1:
		return DecodePortDescPropOptical(_portdescprop, decoder)
	case 65535:
		return DecodePortDescPropExperimenter(_portdescprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescProp'", _portdescprop.Type)
	}
}

func NewPortDescProp(_type uint16) *PortDescProp {
	obj := &PortDescProp{}
	obj.Type = _type
	return obj
}

type PortDescPropExperimenter struct {
	*PortDescProp
	Experimenter uint32
	ExpType      uint32
}

type IPortDescPropExperimenter interface {
	IPortDescProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortDescPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortDescPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortDescPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodePortDescPropExperimenter(parent *PortDescProp, decoder *goloxi.Decoder) (IPortDescPropExperimenter, error) {
	_portdescpropexperimenter := &PortDescPropExperimenter{PortDescProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_portdescpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_portdescpropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch _portdescpropexperimenter.Experimenter {
	case 6035143:
		return DecodePortDescPropBsn(_portdescpropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescPropExperimenter'", _portdescpropexperimenter.Experimenter)
	}
}

func NewPortDescPropExperimenter(_experimenter uint32) *PortDescPropExperimenter {
	obj := &PortDescPropExperimenter{
		PortDescProp: NewPortDescProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type PortDescPropBsn struct {
	*PortDescPropExperimenter
}

type IPortDescPropBsn interface {
	IPortDescPropExperimenter
}

func (self *PortDescPropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func DecodePortDescPropBsn(parent *PortDescPropExperimenter, decoder *goloxi.Decoder) (IPortDescPropBsn, error) {
	_portdescpropbsn := &PortDescPropBsn{PortDescPropExperimenter: parent}

	switch _portdescpropbsn.ExpType {
	case 0:
		return DecodePortDescPropBsnUplink(_portdescpropbsn, decoder)
	case 1:
		return DecodePortDescPropBsnGenerationId(_portdescpropbsn, decoder)
	case 2:
		return DecodePortDescPropBsnForwardErrorCorrection(_portdescpropbsn, decoder)
	case 3:
		return DecodePortDescPropBsnBreakout(_portdescpropbsn, decoder)
	case 4:
		return DecodePortDescPropBsnSpeedCapabilities(_portdescpropbsn, decoder)
	case 5:
		return DecodePortDescPropBsnMiscCapabilities(_portdescpropbsn, decoder)
	case 6:
		return DecodePortDescPropBsnSffJson(_portdescpropbsn, decoder)
	case 7:
		return DecodePortDescPropBsnDriverInfoJson(_portdescpropbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescPropBsn'", _portdescpropbsn.ExpType)
	}
}

func NewPortDescPropBsn(_exp_type uint32) *PortDescPropBsn {
	obj := &PortDescPropBsn{
		PortDescPropExperimenter: NewPortDescPropExperimenter(6035143),
	}
	obj.ExpType = _exp_type
	return obj
}

type PortDescPropBsnBreakout struct {
	*PortDescPropBsn
	SubInterfaceCount     uint16
	SubInterfaceSpeedGbps uint16
}

func (self *PortDescPropBsnBreakout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.SubInterfaceCount))
	encoder.PutUint16(uint16(self.SubInterfaceSpeedGbps))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnBreakout(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnBreakout, error) {
	_portdescpropbsnbreakout := &PortDescPropBsnBreakout{PortDescPropBsn: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescPropBsnBreakout packet too short: %d < 4", decoder.Length())
	}
	_portdescpropbsnbreakout.SubInterfaceCount = uint16(decoder.ReadUint16())
	_portdescpropbsnbreakout.SubInterfaceSpeedGbps = uint16(decoder.ReadUint16())
	return _portdescpropbsnbreakout, nil
}

func NewPortDescPropBsnBreakout() *PortDescPropBsnBreakout {
	obj := &PortDescPropBsnBreakout{
		PortDescPropBsn: NewPortDescPropBsn(3),
	}
	return obj
}

type PortDescPropBsnDriverInfoJson struct {
	*PortDescPropBsn
	DriverInfoJson []byte
}

func (self *PortDescPropBsnDriverInfoJson) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.DriverInfoJson)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnDriverInfoJson(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnDriverInfoJson, error) {
	_portdescpropbsndriverinfojson := &PortDescPropBsnDriverInfoJson{PortDescPropBsn: parent}
	_portdescpropbsndriverinfojson.DriverInfoJson = decoder.Read(decoder.Length())
	return _portdescpropbsndriverinfojson, nil
}

func NewPortDescPropBsnDriverInfoJson() *PortDescPropBsnDriverInfoJson {
	obj := &PortDescPropBsnDriverInfoJson{
		PortDescPropBsn: NewPortDescPropBsn(7),
	}
	return obj
}

type PortDescPropBsnForwardErrorCorrection struct {
	*PortDescPropBsn
	Configured BsnFecConfigState
	Enabled    uint32
}

func (self *PortDescPropBsnForwardErrorCorrection) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Configured))
	encoder.PutUint32(uint32(self.Enabled))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnForwardErrorCorrection(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnForwardErrorCorrection, error) {
	_portdescpropbsnforwarderrorcorrection := &PortDescPropBsnForwardErrorCorrection{PortDescPropBsn: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropBsnForwardErrorCorrection packet too short: %d < 8", decoder.Length())
	}
	_portdescpropbsnforwarderrorcorrection.Configured = BsnFecConfigState(decoder.ReadUint32())
	_portdescpropbsnforwarderrorcorrection.Enabled = uint32(decoder.ReadUint32())
	return _portdescpropbsnforwarderrorcorrection, nil
}

func NewPortDescPropBsnForwardErrorCorrection() *PortDescPropBsnForwardErrorCorrection {
	obj := &PortDescPropBsnForwardErrorCorrection{
		PortDescPropBsn: NewPortDescPropBsn(2),
	}
	return obj
}

type PortDescPropBsnGenerationId struct {
	*PortDescPropBsn
	GenerationId uint64
}

func (self *PortDescPropBsnGenerationId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.GenerationId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnGenerationId(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnGenerationId, error) {
	_portdescpropbsngenerationid := &PortDescPropBsnGenerationId{PortDescPropBsn: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropBsnGenerationId packet too short: %d < 8", decoder.Length())
	}
	_portdescpropbsngenerationid.GenerationId = uint64(decoder.ReadUint64())
	return _portdescpropbsngenerationid, nil
}

func NewPortDescPropBsnGenerationId() *PortDescPropBsnGenerationId {
	obj := &PortDescPropBsnGenerationId{
		PortDescPropBsn: NewPortDescPropBsn(1),
	}
	return obj
}

type PortDescPropBsnMiscCapabilities struct {
	*PortDescPropBsn
	Current   uint64
	Available uint64
	Supported uint64
}

func (self *PortDescPropBsnMiscCapabilities) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Current))
	encoder.PutUint64(uint64(self.Available))
	encoder.PutUint64(uint64(self.Supported))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnMiscCapabilities(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnMiscCapabilities, error) {
	_portdescpropbsnmisccapabilities := &PortDescPropBsnMiscCapabilities{PortDescPropBsn: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropBsnMiscCapabilities packet too short: %d < 24", decoder.Length())
	}
	_portdescpropbsnmisccapabilities.Current = uint64(decoder.ReadUint64())
	_portdescpropbsnmisccapabilities.Available = uint64(decoder.ReadUint64())
	_portdescpropbsnmisccapabilities.Supported = uint64(decoder.ReadUint64())
	return _portdescpropbsnmisccapabilities, nil
}

func NewPortDescPropBsnMiscCapabilities() *PortDescPropBsnMiscCapabilities {
	obj := &PortDescPropBsnMiscCapabilities{
		PortDescPropBsn: NewPortDescPropBsn(5),
	}
	return obj
}

type PortDescPropBsnSffJson struct {
	*PortDescPropBsn
	DataJson []byte
}

func (self *PortDescPropBsnSffJson) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.DataJson)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnSffJson(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnSffJson, error) {
	_portdescpropbsnsffjson := &PortDescPropBsnSffJson{PortDescPropBsn: parent}
	_portdescpropbsnsffjson.DataJson = decoder.Read(decoder.Length())
	return _portdescpropbsnsffjson, nil
}

func NewPortDescPropBsnSffJson() *PortDescPropBsnSffJson {
	obj := &PortDescPropBsnSffJson{
		PortDescPropBsn: NewPortDescPropBsn(6),
	}
	return obj
}

type PortDescPropBsnSpeedCapabilities struct {
	*PortDescPropBsn
	Current   uint64
	Available uint64
	Supported uint64
}

func (self *PortDescPropBsnSpeedCapabilities) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Current))
	encoder.PutUint64(uint64(self.Available))
	encoder.PutUint64(uint64(self.Supported))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnSpeedCapabilities(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnSpeedCapabilities, error) {
	_portdescpropbsnspeedcapabilities := &PortDescPropBsnSpeedCapabilities{PortDescPropBsn: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropBsnSpeedCapabilities packet too short: %d < 24", decoder.Length())
	}
	_portdescpropbsnspeedcapabilities.Current = uint64(decoder.ReadUint64())
	_portdescpropbsnspeedcapabilities.Available = uint64(decoder.ReadUint64())
	_portdescpropbsnspeedcapabilities.Supported = uint64(decoder.ReadUint64())
	return _portdescpropbsnspeedcapabilities, nil
}

func NewPortDescPropBsnSpeedCapabilities() *PortDescPropBsnSpeedCapabilities {
	obj := &PortDescPropBsnSpeedCapabilities{
		PortDescPropBsn: NewPortDescPropBsn(4),
	}
	return obj
}

type PortDescPropBsnUplink struct {
	*PortDescPropBsn
}

func (self *PortDescPropBsnUplink) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropBsnUplink(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnUplink, error) {
	_portdescpropbsnuplink := &PortDescPropBsnUplink{PortDescPropBsn: parent}
	return _portdescpropbsnuplink, nil
}

func NewPortDescPropBsnUplink() *PortDescPropBsnUplink {
	obj := &PortDescPropBsnUplink{
		PortDescPropBsn: NewPortDescPropBsn(0),
	}
	return obj
}

type PortDescPropEthernet struct {
	*PortDescProp
	Curr       uint32
	Advertised uint32
	Supported  uint32
	Peer       uint32
	CurrSpeed  uint32
	MaxSpeed   uint32
}

func (self *PortDescPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))
	encoder.PutUint32(uint32(self.CurrSpeed))
	encoder.PutUint32(uint32(self.MaxSpeed))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropEthernet(parent *PortDescProp, decoder *goloxi.Decoder) (*PortDescPropEthernet, error) {
	_portdescpropethernet := &PortDescPropEthernet{PortDescProp: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropEthernet packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	_portdescpropethernet.Curr = uint32(decoder.ReadUint32())
	_portdescpropethernet.Advertised = uint32(decoder.ReadUint32())
	_portdescpropethernet.Supported = uint32(decoder.ReadUint32())
	_portdescpropethernet.Peer = uint32(decoder.ReadUint32())
	_portdescpropethernet.CurrSpeed = uint32(decoder.ReadUint32())
	_portdescpropethernet.MaxSpeed = uint32(decoder.ReadUint32())
	return _portdescpropethernet, nil
}

func NewPortDescPropEthernet() *PortDescPropEthernet {
	obj := &PortDescPropEthernet{
		PortDescProp: NewPortDescProp(0),
	}
	return obj
}

type PortDescPropOptical struct {
	*PortDescProp
	Supported      uint32
	TxMinFreqLmda  uint32
	TxMaxFreqLmda  uint32
	TxGridFreqLmda uint32
	RxMinFreqLmda  uint32
	RxMaxFreqLmda  uint32
	RxGridFreqLmda uint32
	TxPwrMin       uint32
	TxPwrMax       uint32
}

func (self *PortDescPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.TxMinFreqLmda))
	encoder.PutUint32(uint32(self.TxMaxFreqLmda))
	encoder.PutUint32(uint32(self.TxGridFreqLmda))
	encoder.PutUint32(uint32(self.RxMinFreqLmda))
	encoder.PutUint32(uint32(self.RxMaxFreqLmda))
	encoder.PutUint32(uint32(self.RxGridFreqLmda))
	encoder.PutUint32(uint32(self.TxPwrMin))
	encoder.PutUint32(uint32(self.TxPwrMax))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortDescPropOptical(parent *PortDescProp, decoder *goloxi.Decoder) (*PortDescPropOptical, error) {
	_portdescpropoptical := &PortDescPropOptical{PortDescProp: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("PortDescPropOptical packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	_portdescpropoptical.Supported = uint32(decoder.ReadUint32())
	_portdescpropoptical.TxMinFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.TxMaxFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.TxGridFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.RxMinFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.RxMaxFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.RxGridFreqLmda = uint32(decoder.ReadUint32())
	_portdescpropoptical.TxPwrMin = uint32(decoder.ReadUint32())
	_portdescpropoptical.TxPwrMax = uint32(decoder.ReadUint32())
	return _portdescpropoptical, nil
}

func NewPortDescPropOptical() *PortDescPropOptical {
	obj := &PortDescPropOptical{
		PortDescProp: NewPortDescProp(1),
	}
	return obj
}

type PortModProp struct {
	Type   uint16
	Length uint16
}

type IPortModProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortModProp) GetType() uint16 {
	return self.Type
}

func (self *PortModProp) GetLength() uint16 {
	return self.Length
}

func (self *PortModProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodePortModProp(decoder *goloxi.Decoder) (IPortModProp, error) {
	_portmodprop := &PortModProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortModProp packet too short: %d < 4", decoder.Length())
	}
	_portmodprop.Type = uint16(decoder.ReadUint16())
	_portmodprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_portmodprop.Length), 2+2)

	switch _portmodprop.Type {
	case 0:
		return DecodePortModPropEthernet(_portmodprop, decoder)
	case 1:
		return DecodePortModPropOptical(_portmodprop, decoder)
	case 65535:
		return DecodePortModPropExperimenter(_portmodprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortModProp'", _portmodprop.Type)
	}
}

func NewPortModProp(_type uint16) *PortModProp {
	obj := &PortModProp{}
	obj.Type = _type
	return obj
}

type PortModPropEthernet struct {
	*PortModProp
	Advertise PortFeatures
}

func (self *PortModPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Advertise))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortModPropEthernet(parent *PortModProp, decoder *goloxi.Decoder) (*PortModPropEthernet, error) {
	_portmodpropethernet := &PortModPropEthernet{PortModProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortModPropEthernet packet too short: %d < 4", decoder.Length())
	}
	_portmodpropethernet.Advertise = PortFeatures(decoder.ReadUint32())
	return _portmodpropethernet, nil
}

func NewPortModPropEthernet() *PortModPropEthernet {
	obj := &PortModPropEthernet{
		PortModProp: NewPortModProp(0),
	}
	return obj
}

type PortModPropExperimenter struct {
	*PortModProp
	Experimenter uint32
	ExpType      uint32
}

type IPortModPropExperimenter interface {
	IPortModProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortModPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortModPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortModPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodePortModPropExperimenter(parent *PortModProp, decoder *goloxi.Decoder) (IPortModPropExperimenter, error) {
	_portmodpropexperimenter := &PortModPropExperimenter{PortModProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortModPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_portmodpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_portmodpropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return _portmodpropexperimenter, nil
}

func NewPortModPropExperimenter(_experimenter uint32) *PortModPropExperimenter {
	obj := &PortModPropExperimenter{
		PortModProp: NewPortModProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type PortModPropOptical struct {
	*PortModProp
	Configure uint32
	FreqLdma  uint32
	FlOffset  uint32
	GridSpan  uint32
	TxPwr     uint32
}

func (self *PortModPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Configure))
	encoder.PutUint32(uint32(self.FreqLdma))
	encoder.PutUint32(uint32(self.FlOffset))
	encoder.PutUint32(uint32(self.GridSpan))
	encoder.PutUint32(uint32(self.TxPwr))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortModPropOptical(parent *PortModProp, decoder *goloxi.Decoder) (*PortModPropOptical, error) {
	_portmodpropoptical := &PortModPropOptical{PortModProp: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("PortModPropOptical packet too short: %d < 20", decoder.Length())
	}
	_portmodpropoptical.Configure = uint32(decoder.ReadUint32())
	_portmodpropoptical.FreqLdma = uint32(decoder.ReadUint32())
	_portmodpropoptical.FlOffset = uint32(decoder.ReadUint32())
	_portmodpropoptical.GridSpan = uint32(decoder.ReadUint32())
	_portmodpropoptical.TxPwr = uint32(decoder.ReadUint32())
	return _portmodpropoptical, nil
}

func NewPortModPropOptical() *PortModPropOptical {
	obj := &PortModPropOptical{
		PortModProp: NewPortModProp(1),
	}
	return obj
}

type PortStatsEntry struct {
	Length       uint16
	PortNo       PortNo
	DurationSec  uint32
	DurationNsec uint32
	RxPackets    uint64
	TxPackets    uint64
	RxBytes      uint64
	TxBytes      uint64
	RxDropped    uint64
	TxDropped    uint64
	RxErrors     uint64
	TxErrors     uint64
	Properties   []IPortStatsProp
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	_portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 80 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 80", decoder.Length())
	}
	_portstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_portstatsentry.Length), 2+0)
	decoder.Skip(2)
	_portstatsentry.PortNo.Decode(decoder)
	_portstatsentry.DurationSec = uint32(decoder.ReadUint32())
	_portstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	_portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	_portstatsentry.TxErrors = uint64(decoder.ReadUint64())

	for decoder.Length() >= 4 {
		item, err := DecodePortStatsProp(decoder)
		if err != nil {
			return nil, err
		}
		_portstatsentry.Properties = append(_portstatsentry.Properties, item)
	}
	return _portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	obj := &PortStatsEntry{}
	return obj
}

type PortStatsProp struct {
	Type   uint16
	Length uint16
}

type IPortStatsProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortStatsProp) GetType() uint16 {
	return self.Type
}

func (self *PortStatsProp) GetLength() uint16 {
	return self.Length
}

func (self *PortStatsProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodePortStatsProp(decoder *goloxi.Decoder) (IPortStatsProp, error) {
	_portstatsprop := &PortStatsProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortStatsProp packet too short: %d < 4", decoder.Length())
	}
	_portstatsprop.Type = uint16(decoder.ReadUint16())
	_portstatsprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_portstatsprop.Length), 2+2)

	switch _portstatsprop.Type {
	case 0:
		return DecodePortStatsPropEthernet(_portstatsprop, decoder)
	case 1:
		return DecodePortStatsPropOptical(_portstatsprop, decoder)
	case 65535:
		return DecodePortStatsPropExperimenter(_portstatsprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortStatsProp'", _portstatsprop.Type)
	}
}

func NewPortStatsProp(_type uint16) *PortStatsProp {
	obj := &PortStatsProp{}
	obj.Type = _type
	return obj
}

type PortStatsPropEthernet struct {
	*PortStatsProp
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortStatsPropEthernet(parent *PortStatsProp, decoder *goloxi.Decoder) (*PortStatsPropEthernet, error) {
	_portstatspropethernet := &PortStatsPropEthernet{PortStatsProp: parent}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("PortStatsPropEthernet packet too short: %d < 32", decoder.Length())
	}
	decoder.Skip(4)
	_portstatspropethernet.RxFrameErr = uint64(decoder.ReadUint64())
	_portstatspropethernet.RxOverErr = uint64(decoder.ReadUint64())
	_portstatspropethernet.RxCrcErr = uint64(decoder.ReadUint64())
	_portstatspropethernet.Collisions = uint64(decoder.ReadUint64())
	return _portstatspropethernet, nil
}

func NewPortStatsPropEthernet() *PortStatsPropEthernet {
	obj := &PortStatsPropEthernet{
		PortStatsProp: NewPortStatsProp(0),
	}
	return obj
}

type PortStatsPropExperimenter struct {
	*PortStatsProp
	Experimenter uint32
	ExpType      uint32
}

type IPortStatsPropExperimenter interface {
	IPortStatsProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortStatsPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortStatsPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortStatsPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodePortStatsPropExperimenter(parent *PortStatsProp, decoder *goloxi.Decoder) (IPortStatsPropExperimenter, error) {
	_portstatspropexperimenter := &PortStatsPropExperimenter{PortStatsProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortStatsPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_portstatspropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_portstatspropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch _portstatspropexperimenter.Experimenter {
	case 43521:
		return DecodePortStatsPropExperimenterIntel(_portstatspropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortStatsPropExperimenter'", _portstatspropexperimenter.Experimenter)
	}
}

func NewPortStatsPropExperimenter(_experimenter uint32) *PortStatsPropExperimenter {
	obj := &PortStatsPropExperimenter{
		PortStatsProp: NewPortStatsProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type PortStatsPropExperimenterIntel struct {
	*PortStatsPropExperimenter
	Rx1To64Packets      uint64
	Rx65To127Packets    uint64
	Rx128To255Packets   uint64
	Rx256To511Packets   uint64
	Rx512To1023Packets  uint64
	Rx1024To1522Packets uint64
	Rx1523ToMaxPackets  uint64
	Tx1To64Packets      uint64
	Tx65To127Packets    uint64
	Tx128To255Packets   uint64
	Tx256To511Packets   uint64
	Tx512To1023Packets  uint64
	Tx1024To1522Packets uint64
	Tx1523ToMaxPackets  uint64
	TxMulticastPackets  uint64
	RxBroadcastPackets  uint64
	TxBroadcastPackets  uint64
	RxUndersizedErrors  uint64
	RxOversizeErrors    uint64
	RxFragmentedErrors  uint64
	RxJabberErrors      uint64
}

func (self *PortStatsPropExperimenterIntel) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Rx1To64Packets))
	encoder.PutUint64(uint64(self.Rx65To127Packets))
	encoder.PutUint64(uint64(self.Rx128To255Packets))
	encoder.PutUint64(uint64(self.Rx256To511Packets))
	encoder.PutUint64(uint64(self.Rx512To1023Packets))
	encoder.PutUint64(uint64(self.Rx1024To1522Packets))
	encoder.PutUint64(uint64(self.Rx1523ToMaxPackets))
	encoder.PutUint64(uint64(self.Tx1To64Packets))
	encoder.PutUint64(uint64(self.Tx65To127Packets))
	encoder.PutUint64(uint64(self.Tx128To255Packets))
	encoder.PutUint64(uint64(self.Tx256To511Packets))
	encoder.PutUint64(uint64(self.Tx512To1023Packets))
	encoder.PutUint64(uint64(self.Tx1024To1522Packets))
	encoder.PutUint64(uint64(self.Tx1523ToMaxPackets))
	encoder.PutUint64(uint64(self.TxMulticastPackets))
	encoder.PutUint64(uint64(self.RxBroadcastPackets))
	encoder.PutUint64(uint64(self.TxBroadcastPackets))
	encoder.PutUint64(uint64(self.RxUndersizedErrors))
	encoder.PutUint64(uint64(self.RxOversizeErrors))
	encoder.PutUint64(uint64(self.RxFragmentedErrors))
	encoder.PutUint64(uint64(self.RxJabberErrors))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortStatsPropExperimenterIntel(parent *PortStatsPropExperimenter, decoder *goloxi.Decoder) (*PortStatsPropExperimenterIntel, error) {
	_portstatspropexperimenterintel := &PortStatsPropExperimenterIntel{PortStatsPropExperimenter: parent}
	if decoder.Length() < 168 {
		return nil, fmt.Errorf("PortStatsPropExperimenterIntel packet too short: %d < 168", decoder.Length())
	}
	decoder.Skip(4)
	_portstatspropexperimenterintel.Rx1To64Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx65To127Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx128To255Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx256To511Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx512To1023Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx1024To1522Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Rx1523ToMaxPackets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx1To64Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx65To127Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx128To255Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx256To511Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx512To1023Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx1024To1522Packets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.Tx1523ToMaxPackets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.TxMulticastPackets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.RxBroadcastPackets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.TxBroadcastPackets = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.RxUndersizedErrors = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.RxOversizeErrors = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.RxFragmentedErrors = uint64(decoder.ReadUint64())
	_portstatspropexperimenterintel.RxJabberErrors = uint64(decoder.ReadUint64())
	return _portstatspropexperimenterintel, nil
}

func NewPortStatsPropExperimenterIntel() *PortStatsPropExperimenterIntel {
	obj := &PortStatsPropExperimenterIntel{
		PortStatsPropExperimenter: NewPortStatsPropExperimenter(43521),
	}
	return obj
}

type PortStatsPropOptical struct {
	*PortStatsProp
	Flags       uint32
	TxFreqLmda  uint32
	TxOffset    uint32
	TxGridSpan  uint32
	RxFreqLmda  uint32
	RxOffset    uint32
	RxGridSpan  uint32
	TxPwr       uint16
	RxPwr       uint16
	BiasCurrent uint16
	Temperature uint16
}

func (self *PortStatsPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Flags))
	encoder.PutUint32(uint32(self.TxFreqLmda))
	encoder.PutUint32(uint32(self.TxOffset))
	encoder.PutUint32(uint32(self.TxGridSpan))
	encoder.PutUint32(uint32(self.RxFreqLmda))
	encoder.PutUint32(uint32(self.RxOffset))
	encoder.PutUint32(uint32(self.RxGridSpan))
	encoder.PutUint16(uint16(self.TxPwr))
	encoder.PutUint16(uint16(self.RxPwr))
	encoder.PutUint16(uint16(self.BiasCurrent))
	encoder.PutUint16(uint16(self.Temperature))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePortStatsPropOptical(parent *PortStatsProp, decoder *goloxi.Decoder) (*PortStatsPropOptical, error) {
	_portstatspropoptical := &PortStatsPropOptical{PortStatsProp: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("PortStatsPropOptical packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	_portstatspropoptical.Flags = uint32(decoder.ReadUint32())
	_portstatspropoptical.TxFreqLmda = uint32(decoder.ReadUint32())
	_portstatspropoptical.TxOffset = uint32(decoder.ReadUint32())
	_portstatspropoptical.TxGridSpan = uint32(decoder.ReadUint32())
	_portstatspropoptical.RxFreqLmda = uint32(decoder.ReadUint32())
	_portstatspropoptical.RxOffset = uint32(decoder.ReadUint32())
	_portstatspropoptical.RxGridSpan = uint32(decoder.ReadUint32())
	_portstatspropoptical.TxPwr = uint16(decoder.ReadUint16())
	_portstatspropoptical.RxPwr = uint16(decoder.ReadUint16())
	_portstatspropoptical.BiasCurrent = uint16(decoder.ReadUint16())
	_portstatspropoptical.Temperature = uint16(decoder.ReadUint16())
	return _portstatspropoptical, nil
}

func NewPortStatsPropOptical() *PortStatsPropOptical {
	obj := &PortStatsPropOptical{
		PortStatsProp: NewPortStatsProp(1),
	}
	return obj
}

type QueueDesc struct {
	PortNo     uint32
	QueueId    uint32
	Length     uint16
	Properties []IQueueDescProp
}

func (self *QueueDesc) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueueDesc(decoder *goloxi.Decoder) (*QueueDesc, error) {
	_queuedesc := &QueueDesc{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("QueueDesc packet too short: %d < 16", decoder.Length())
	}
	_queuedesc.PortNo = uint32(decoder.ReadUint32())
	_queuedesc.QueueId = uint32(decoder.ReadUint32())
	_queuedesc.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queuedesc.Length), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 4 {
		item, err := DecodeQueueDescProp(decoder)
		if err != nil {
			return nil, err
		}
		_queuedesc.Properties = append(_queuedesc.Properties, item)
	}
	return _queuedesc, nil
}

func NewQueueDesc() *QueueDesc {
	obj := &QueueDesc{}
	return obj
}

type QueueDescProp struct {
	Type   uint16
	Length uint16
}

type IQueueDescProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *QueueDescProp) GetType() uint16 {
	return self.Type
}

func (self *QueueDescProp) GetLength() uint16 {
	return self.Length
}

func (self *QueueDescProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeQueueDescProp(decoder *goloxi.Decoder) (IQueueDescProp, error) {
	_queuedescprop := &QueueDescProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescProp packet too short: %d < 4", decoder.Length())
	}
	_queuedescprop.Type = uint16(decoder.ReadUint16())
	_queuedescprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queuedescprop.Length), 2+2)

	switch _queuedescprop.Type {
	case 1:
		return DecodeQueueDescPropMinRate(_queuedescprop, decoder)
	case 2:
		return DecodeQueueDescPropMaxRate(_queuedescprop, decoder)
	case 65535:
		return DecodeQueueDescPropExperimenter(_queuedescprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescProp'", _queuedescprop.Type)
	}
}

func NewQueueDescProp(_type uint16) *QueueDescProp {
	obj := &QueueDescProp{}
	obj.Type = _type
	return obj
}

type QueueDescPropExperimenter struct {
	*QueueDescProp
	Experimenter uint32
	ExpType      uint32
}

type IQueueDescPropExperimenter interface {
	IQueueDescProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *QueueDescPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueueDescPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *QueueDescPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodeQueueDescPropExperimenter(parent *QueueDescProp, decoder *goloxi.Decoder) (IQueueDescPropExperimenter, error) {
	_queuedescpropexperimenter := &QueueDescPropExperimenter{QueueDescProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueDescPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_queuedescpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_queuedescpropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch _queuedescpropexperimenter.Experimenter {
	case 6035143:
		return DecodeQueueDescPropBsn(_queuedescpropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescPropExperimenter'", _queuedescpropexperimenter.Experimenter)
	}
}

func NewQueueDescPropExperimenter(_experimenter uint32) *QueueDescPropExperimenter {
	obj := &QueueDescPropExperimenter{
		QueueDescProp: NewQueueDescProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type QueueDescPropBsn struct {
	*QueueDescPropExperimenter
}

type IQueueDescPropBsn interface {
	IQueueDescPropExperimenter
}

func (self *QueueDescPropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func DecodeQueueDescPropBsn(parent *QueueDescPropExperimenter, decoder *goloxi.Decoder) (IQueueDescPropBsn, error) {
	_queuedescpropbsn := &QueueDescPropBsn{QueueDescPropExperimenter: parent}

	switch _queuedescpropbsn.ExpType {
	case 0:
		return DecodeQueueDescPropBsnQueueName(_queuedescpropbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescPropBsn'", _queuedescpropbsn.ExpType)
	}
}

func NewQueueDescPropBsn(_exp_type uint32) *QueueDescPropBsn {
	obj := &QueueDescPropBsn{
		QueueDescPropExperimenter: NewQueueDescPropExperimenter(6035143),
	}
	obj.ExpType = _exp_type
	return obj
}

type QueueDescPropBsnQueueName struct {
	*QueueDescPropBsn
	Name []byte
}

func (self *QueueDescPropBsnQueueName) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Name)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueueDescPropBsnQueueName(parent *QueueDescPropBsn, decoder *goloxi.Decoder) (*QueueDescPropBsnQueueName, error) {
	_queuedescpropbsnqueuename := &QueueDescPropBsnQueueName{QueueDescPropBsn: parent}
	_queuedescpropbsnqueuename.Name = decoder.Read(decoder.Length())
	return _queuedescpropbsnqueuename, nil
}

func NewQueueDescPropBsnQueueName() *QueueDescPropBsnQueueName {
	obj := &QueueDescPropBsnQueueName{
		QueueDescPropBsn: NewQueueDescPropBsn(0),
	}
	return obj
}

type QueueDescPropMaxRate struct {
	*QueueDescProp
	Rate uint16
}

func (self *QueueDescPropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueueDescPropMaxRate(parent *QueueDescProp, decoder *goloxi.Decoder) (*QueueDescPropMaxRate, error) {
	_queuedescpropmaxrate := &QueueDescPropMaxRate{QueueDescProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescPropMaxRate packet too short: %d < 4", decoder.Length())
	}
	_queuedescpropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return _queuedescpropmaxrate, nil
}

func NewQueueDescPropMaxRate() *QueueDescPropMaxRate {
	obj := &QueueDescPropMaxRate{
		QueueDescProp: NewQueueDescProp(2),
	}
	return obj
}

type QueueDescPropMinRate struct {
	*QueueDescProp
	Rate uint16
}

func (self *QueueDescPropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueueDescPropMinRate(parent *QueueDescProp, decoder *goloxi.Decoder) (*QueueDescPropMinRate, error) {
	_queuedescpropminrate := &QueueDescPropMinRate{QueueDescProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescPropMinRate packet too short: %d < 4", decoder.Length())
	}
	_queuedescpropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return _queuedescpropminrate, nil
}

func NewQueueDescPropMinRate() *QueueDescPropMinRate {
	obj := &QueueDescPropMinRate{
		QueueDescProp: NewQueueDescProp(1),
	}
	return obj
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func DecodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	_queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	_queueprop.Type = uint16(decoder.ReadUint16())
	_queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queueprop.Len), 2+2)

	switch _queueprop.Type {
	case 1:
		return DecodeQueuePropMinRate(_queueprop, decoder)
	case 2:
		return DecodeQueuePropMaxRate(_queueprop, decoder)
	case 65535:
		return DecodeQueuePropExperimenter(_queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", _queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	obj := &QueueProp{}
	obj.Type = _type
	return obj
}

type QueuePropExperimenter struct {
	*QueueProp
	Experimenter uint32
}

type IQueuePropExperimenter interface {
	IQueueProp
	GetExperimenter() uint32
}

func (self *QueuePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueuePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func DecodeQueuePropExperimenter(parent *QueueProp, decoder *goloxi.Decoder) (IQueuePropExperimenter, error) {
	_queuepropexperimenter := &QueuePropExperimenter{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return _queuepropexperimenter, nil
}

func NewQueuePropExperimenter(_experimenter uint32) *QueuePropExperimenter {
	obj := &QueuePropExperimenter{
		QueueProp: NewQueueProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type QueuePropMaxRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueuePropMaxRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMaxRate, error) {
	_queuepropmaxrate := &QueuePropMaxRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMaxRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return _queuepropmaxrate, nil
}

func NewQueuePropMaxRate() *QueuePropMaxRate {
	obj := &QueuePropMaxRate{
		QueueProp: NewQueueProp(2),
	}
	return obj
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	_queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return _queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	obj := &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
	return obj
}

type QueueStatsEntry struct {
	Length       uint16
	PortNo       PortNo
	QueueId      uint32
	TxBytes      uint64
	TxPackets    uint64
	TxErrors     uint64
	DurationSec  uint32
	DurationNsec uint32
	Properties   []IQueueStatsProp
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	_queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 48", decoder.Length())
	}
	_queuestatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queuestatsentry.Length), 2+0)
	decoder.Skip(6)
	_queuestatsentry.PortNo.Decode(decoder)
	_queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	_queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	_queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	_queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	_queuestatsentry.DurationSec = uint32(decoder.ReadUint32())
	_queuestatsentry.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := DecodeQueueStatsProp(decoder)
		if err != nil {
			return nil, err
		}
		_queuestatsentry.Properties = append(_queuestatsentry.Properties, item)
	}
	return _queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	obj := &QueueStatsEntry{}
	return obj
}

type QueueStatsProp struct {
	Type   uint16
	Length uint16
}

type IQueueStatsProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *QueueStatsProp) GetType() uint16 {
	return self.Type
}

func (self *QueueStatsProp) GetLength() uint16 {
	return self.Length
}

func (self *QueueStatsProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeQueueStatsProp(decoder *goloxi.Decoder) (IQueueStatsProp, error) {
	_queuestatsprop := &QueueStatsProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueStatsProp packet too short: %d < 4", decoder.Length())
	}
	_queuestatsprop.Type = uint16(decoder.ReadUint16())
	_queuestatsprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queuestatsprop.Length), 2+2)

	switch _queuestatsprop.Type {
	case 65535:
		return DecodeQueueStatsPropExperimenter(_queuestatsprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueStatsProp'", _queuestatsprop.Type)
	}
}

func NewQueueStatsProp(_type uint16) *QueueStatsProp {
	obj := &QueueStatsProp{}
	obj.Type = _type
	return obj
}

type QueueStatsPropExperimenter struct {
	*QueueStatsProp
	Experimenter uint32
	ExpType      uint32
}

type IQueueStatsPropExperimenter interface {
	IQueueStatsProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *QueueStatsPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueueStatsPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *QueueStatsPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodeQueueStatsPropExperimenter(parent *QueueStatsProp, decoder *goloxi.Decoder) (IQueueStatsPropExperimenter, error) {
	_queuestatspropexperimenter := &QueueStatsPropExperimenter{QueueStatsProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueStatsPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_queuestatspropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_queuestatspropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return _queuestatspropexperimenter, nil
}

func NewQueueStatsPropExperimenter(_experimenter uint32) *QueueStatsPropExperimenter {
	obj := &QueueStatsPropExperimenter{
		QueueStatsProp: NewQueueStatsProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type RoleProp struct {
	Type   uint16
	Length uint16
}

type IRoleProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *RoleProp) GetType() uint16 {
	return self.Type
}

func (self *RoleProp) GetLength() uint16 {
	return self.Length
}

func (self *RoleProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeRoleProp(decoder *goloxi.Decoder) (IRoleProp, error) {
	_roleprop := &RoleProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("RoleProp packet too short: %d < 4", decoder.Length())
	}
	_roleprop.Type = uint16(decoder.ReadUint16())
	_roleprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_roleprop.Length), 2+2)

	switch _roleprop.Type {
	case 65535:
		return DecodeRolePropExperimenter(_roleprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'RoleProp'", _roleprop.Type)
	}
}

func NewRoleProp(_type uint16) *RoleProp {
	obj := &RoleProp{}
	obj.Type = _type
	return obj
}

type RolePropExperimenter struct {
	*RoleProp
	Experimenter uint32
	ExpType      uint32
}

type IRolePropExperimenter interface {
	IRoleProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *RolePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *RolePropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *RolePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.RoleProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodeRolePropExperimenter(parent *RoleProp, decoder *goloxi.Decoder) (IRolePropExperimenter, error) {
	_rolepropexperimenter := &RolePropExperimenter{RoleProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("RolePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_rolepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_rolepropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return _rolepropexperimenter, nil
}

func NewRolePropExperimenter(_experimenter uint32) *RolePropExperimenter {
	obj := &RolePropExperimenter{
		RoleProp: NewRoleProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type TableDesc struct {
	Length  uint16
	TableId uint8
	Config  TableConfig
}

func (self *TableDesc) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.Config))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}
func (self *TableDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 8 {
		return fmt.Errorf("TableDesc packet too short: %d < 8", decoder.Length())
	}

	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+0)
	self.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	self.Config = TableConfig(decoder.ReadUint32())

	return nil
}

func NewTableDesc() *TableDesc {
	obj := &TableDesc{}
	return obj
}

type TableFeatureProp struct {
	Type   uint16
	Length uint16
}

type ITableFeatureProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *TableFeatureProp) GetType() uint16 {
	return self.Type
}

func (self *TableFeatureProp) GetLength() uint16 {
	return self.Length
}

func (self *TableFeatureProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeTableFeatureProp(decoder *goloxi.Decoder) (ITableFeatureProp, error) {
	_tablefeatureprop := &TableFeatureProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableFeatureProp packet too short: %d < 4", decoder.Length())
	}
	_tablefeatureprop.Type = uint16(decoder.ReadUint16())
	_tablefeatureprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablefeatureprop.Length), 2+2)

	switch _tablefeatureprop.Type {
	case 0:
		return DecodeTableFeaturePropInstructions(_tablefeatureprop, decoder)
	case 1:
		return DecodeTableFeaturePropInstructionsMiss(_tablefeatureprop, decoder)
	case 2:
		return DecodeTableFeaturePropNextTables(_tablefeatureprop, decoder)
	case 3:
		return DecodeTableFeaturePropNextTablesMiss(_tablefeatureprop, decoder)
	case 4:
		return DecodeTableFeaturePropWriteActions(_tablefeatureprop, decoder)
	case 5:
		return DecodeTableFeaturePropWriteActionsMiss(_tablefeatureprop, decoder)
	case 6:
		return DecodeTableFeaturePropApplyActions(_tablefeatureprop, decoder)
	case 7:
		return DecodeTableFeaturePropApplyActionsMiss(_tablefeatureprop, decoder)
	case 8:
		return DecodeTableFeaturePropMatch(_tablefeatureprop, decoder)
	case 10:
		return DecodeTableFeaturePropWildcards(_tablefeatureprop, decoder)
	case 12:
		return DecodeTableFeaturePropWriteSetfield(_tablefeatureprop, decoder)
	case 13:
		return DecodeTableFeaturePropWriteSetfieldMiss(_tablefeatureprop, decoder)
	case 14:
		return DecodeTableFeaturePropApplySetfield(_tablefeatureprop, decoder)
	case 15:
		return DecodeTableFeaturePropApplySetfieldMiss(_tablefeatureprop, decoder)
	case 16:
		return DecodeTableFeaturePropTableSyncFrom(_tablefeatureprop, decoder)
	case 65534:
		return DecodeTableFeaturePropExperimenter(_tablefeatureprop, decoder)
	case 65535:
		return DecodeTableFeaturePropExperimenterMiss(_tablefeatureprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'TableFeatureProp'", _tablefeatureprop.Type)
	}
}

func NewTableFeatureProp(_type uint16) *TableFeatureProp {
	obj := &TableFeatureProp{}
	obj.Type = _type
	return obj
}

type TableFeaturePropApplyActions struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropApplyActions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyActions, error) {
	_tablefeaturepropapplyactions := &TableFeaturePropApplyActions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropapplyactions.ActionIds = append(_tablefeaturepropapplyactions.ActionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropapplyactions, nil
}

func NewTableFeaturePropApplyActions() *TableFeaturePropApplyActions {
	obj := &TableFeaturePropApplyActions{
		TableFeatureProp: NewTableFeatureProp(6),
	}
	return obj
}

type TableFeaturePropApplyActionsMiss struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropApplyActionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropApplyActionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyActionsMiss, error) {
	_tablefeaturepropapplyactionsmiss := &TableFeaturePropApplyActionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropapplyactionsmiss.ActionIds = append(_tablefeaturepropapplyactionsmiss.ActionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropapplyactionsmiss, nil
}

func NewTableFeaturePropApplyActionsMiss() *TableFeaturePropApplyActionsMiss {
	obj := &TableFeaturePropApplyActionsMiss{
		TableFeatureProp: NewTableFeatureProp(7),
	}
	return obj
}

type TableFeaturePropApplySetfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplySetfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropApplySetfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplySetfield, error) {
	_tablefeaturepropapplysetfield := &TableFeaturePropApplySetfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropapplysetfield.OxmIds = append(_tablefeaturepropapplysetfield.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropapplysetfield, nil
}

func NewTableFeaturePropApplySetfield() *TableFeaturePropApplySetfield {
	obj := &TableFeaturePropApplySetfield{
		TableFeatureProp: NewTableFeatureProp(14),
	}
	return obj
}

type TableFeaturePropApplySetfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplySetfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropApplySetfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplySetfieldMiss, error) {
	_tablefeaturepropapplysetfieldmiss := &TableFeaturePropApplySetfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropapplysetfieldmiss.OxmIds = append(_tablefeaturepropapplysetfieldmiss.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropapplysetfieldmiss, nil
}

func NewTableFeaturePropApplySetfieldMiss() *TableFeaturePropApplySetfieldMiss {
	obj := &TableFeaturePropApplySetfieldMiss{
		TableFeatureProp: NewTableFeatureProp(15),
	}
	return obj
}

type TableFeaturePropExperimenter struct {
	*TableFeatureProp
	Experimenter uint32
	Subtype      uint32
}

type ITableFeaturePropExperimenter interface {
	ITableFeatureProp
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *TableFeaturePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableFeaturePropExperimenter) GetSubtype() uint32 {
	return self.Subtype
}

func (self *TableFeaturePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	encoder.SkipAlign()

	return nil
}

func DecodeTableFeaturePropExperimenter(parent *TableFeatureProp, decoder *goloxi.Decoder) (ITableFeaturePropExperimenter, error) {
	_tablefeaturepropexperimenter := &TableFeaturePropExperimenter{TableFeatureProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableFeaturePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	_tablefeaturepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_tablefeaturepropexperimenter.Subtype = uint32(decoder.ReadUint32())

	decoder.SkipAlign()

	return _tablefeaturepropexperimenter, nil
}

func NewTableFeaturePropExperimenter(_experimenter uint32) *TableFeaturePropExperimenter {
	obj := &TableFeaturePropExperimenter{
		TableFeatureProp: NewTableFeatureProp(65534),
	}
	obj.Experimenter = _experimenter
	return obj
}

type TableFeaturePropExperimenterMiss struct {
	*TableFeatureProp
	Experimenter uint32
	Subtype      uint32
}

type ITableFeaturePropExperimenterMiss interface {
	ITableFeatureProp
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *TableFeaturePropExperimenterMiss) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableFeaturePropExperimenterMiss) GetSubtype() uint32 {
	return self.Subtype
}

func (self *TableFeaturePropExperimenterMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	encoder.SkipAlign()

	return nil
}

func DecodeTableFeaturePropExperimenterMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (ITableFeaturePropExperimenterMiss, error) {
	_tablefeaturepropexperimentermiss := &TableFeaturePropExperimenterMiss{TableFeatureProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableFeaturePropExperimenterMiss packet too short: %d < 8", decoder.Length())
	}
	_tablefeaturepropexperimentermiss.Experimenter = uint32(decoder.ReadUint32())
	_tablefeaturepropexperimentermiss.Subtype = uint32(decoder.ReadUint32())

	decoder.SkipAlign()

	return _tablefeaturepropexperimentermiss, nil
}

func NewTableFeaturePropExperimenterMiss(_experimenter uint32) *TableFeaturePropExperimenterMiss {
	obj := &TableFeaturePropExperimenterMiss{
		TableFeatureProp: NewTableFeatureProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type TableFeaturePropInstructions struct {
	*TableFeatureProp
	InstructionIds []IInstructionId
}

func (self *TableFeaturePropInstructions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.InstructionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropInstructions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropInstructions, error) {
	_tablefeaturepropinstructions := &TableFeaturePropInstructions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeInstructionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropinstructions.InstructionIds = append(_tablefeaturepropinstructions.InstructionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropinstructions, nil
}

func NewTableFeaturePropInstructions() *TableFeaturePropInstructions {
	obj := &TableFeaturePropInstructions{
		TableFeatureProp: NewTableFeatureProp(0),
	}
	return obj
}

type TableFeaturePropInstructionsMiss struct {
	*TableFeatureProp
	InstructionIds []IInstructionId
}

func (self *TableFeaturePropInstructionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.InstructionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropInstructionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropInstructionsMiss, error) {
	_tablefeaturepropinstructionsmiss := &TableFeaturePropInstructionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeInstructionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropinstructionsmiss.InstructionIds = append(_tablefeaturepropinstructionsmiss.InstructionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropinstructionsmiss, nil
}

func NewTableFeaturePropInstructionsMiss() *TableFeaturePropInstructionsMiss {
	obj := &TableFeaturePropInstructionsMiss{
		TableFeatureProp: NewTableFeatureProp(1),
	}
	return obj
}

type TableFeaturePropMatch struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropMatch(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropMatch, error) {
	_tablefeaturepropmatch := &TableFeaturePropMatch{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropmatch.OxmIds = append(_tablefeaturepropmatch.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropmatch, nil
}

func NewTableFeaturePropMatch() *TableFeaturePropMatch {
	obj := &TableFeaturePropMatch{
		TableFeatureProp: NewTableFeatureProp(8),
	}
	return obj
}

type TableFeaturePropNextTables struct {
	*TableFeatureProp
	NextTableIds []*Uint8
}

func (self *TableFeaturePropNextTables) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.NextTableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropNextTables(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropNextTables, error) {
	_tablefeaturepropnexttables := &TableFeaturePropNextTables{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := DecodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropnexttables.NextTableIds = append(_tablefeaturepropnexttables.NextTableIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropnexttables, nil
}

func NewTableFeaturePropNextTables() *TableFeaturePropNextTables {
	obj := &TableFeaturePropNextTables{
		TableFeatureProp: NewTableFeatureProp(2),
	}
	return obj
}

type TableFeaturePropNextTablesMiss struct {
	*TableFeatureProp
	NextTableIds []*Uint8
}

func (self *TableFeaturePropNextTablesMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.NextTableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropNextTablesMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropNextTablesMiss, error) {
	_tablefeaturepropnexttablesmiss := &TableFeaturePropNextTablesMiss{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := DecodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropnexttablesmiss.NextTableIds = append(_tablefeaturepropnexttablesmiss.NextTableIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropnexttablesmiss, nil
}

func NewTableFeaturePropNextTablesMiss() *TableFeaturePropNextTablesMiss {
	obj := &TableFeaturePropNextTablesMiss{
		TableFeatureProp: NewTableFeatureProp(3),
	}
	return obj
}

type TableFeaturePropTableSyncFrom struct {
	*TableFeatureProp
	TableIds []*Uint8
}

func (self *TableFeaturePropTableSyncFrom) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.TableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropTableSyncFrom(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropTableSyncFrom, error) {
	_tablefeatureproptablesyncfrom := &TableFeaturePropTableSyncFrom{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := DecodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeatureproptablesyncfrom.TableIds = append(_tablefeatureproptablesyncfrom.TableIds, item)
	}

	decoder.SkipAlign()

	return _tablefeatureproptablesyncfrom, nil
}

func NewTableFeaturePropTableSyncFrom() *TableFeaturePropTableSyncFrom {
	obj := &TableFeaturePropTableSyncFrom{
		TableFeatureProp: NewTableFeatureProp(16),
	}
	return obj
}

type TableFeaturePropWildcards struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWildcards) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropWildcards(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWildcards, error) {
	_tablefeaturepropwildcards := &TableFeaturePropWildcards{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropwildcards.OxmIds = append(_tablefeaturepropwildcards.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropwildcards, nil
}

func NewTableFeaturePropWildcards() *TableFeaturePropWildcards {
	obj := &TableFeaturePropWildcards{
		TableFeatureProp: NewTableFeatureProp(10),
	}
	return obj
}

type TableFeaturePropWriteActions struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropWriteActions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteActions, error) {
	_tablefeaturepropwriteactions := &TableFeaturePropWriteActions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropwriteactions.ActionIds = append(_tablefeaturepropwriteactions.ActionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropwriteactions, nil
}

func NewTableFeaturePropWriteActions() *TableFeaturePropWriteActions {
	obj := &TableFeaturePropWriteActions{
		TableFeatureProp: NewTableFeatureProp(4),
	}
	return obj
}

type TableFeaturePropWriteActionsMiss struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropWriteActionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropWriteActionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteActionsMiss, error) {
	_tablefeaturepropwriteactionsmiss := &TableFeaturePropWriteActionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropwriteactionsmiss.ActionIds = append(_tablefeaturepropwriteactionsmiss.ActionIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropwriteactionsmiss, nil
}

func NewTableFeaturePropWriteActionsMiss() *TableFeaturePropWriteActionsMiss {
	obj := &TableFeaturePropWriteActionsMiss{
		TableFeatureProp: NewTableFeatureProp(5),
	}
	return obj
}

type TableFeaturePropWriteSetfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteSetfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropWriteSetfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteSetfield, error) {
	_tablefeaturepropwritesetfield := &TableFeaturePropWriteSetfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropwritesetfield.OxmIds = append(_tablefeaturepropwritesetfield.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropwritesetfield, nil
}

func NewTableFeaturePropWriteSetfield() *TableFeaturePropWriteSetfield {
	obj := &TableFeaturePropWriteSetfield{
		TableFeatureProp: NewTableFeatureProp(12),
	}
	return obj
}

type TableFeaturePropWriteSetfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteSetfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeaturePropWriteSetfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteSetfieldMiss, error) {
	_tablefeaturepropwritesetfieldmiss := &TableFeaturePropWriteSetfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := DecodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeaturepropwritesetfieldmiss.OxmIds = append(_tablefeaturepropwritesetfieldmiss.OxmIds, item)
	}

	decoder.SkipAlign()

	return _tablefeaturepropwritesetfieldmiss, nil
}

func NewTableFeaturePropWriteSetfieldMiss() *TableFeaturePropWriteSetfieldMiss {
	obj := &TableFeaturePropWriteSetfieldMiss{
		TableFeatureProp: NewTableFeatureProp(13),
	}
	return obj
}

type TableFeatures struct {
	Length        uint16
	TableId       uint8
	Name          string
	MetadataMatch uint64
	MetadataWrite uint64
	Config        uint32
	MaxEntries    uint32
	Properties    []ITableFeatureProp
}

func (self *TableFeatures) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 5))
	encoder.Write([]byte(self.Name))
	encoder.PutUint64(uint64(self.MetadataMatch))
	encoder.PutUint64(uint64(self.MetadataWrite))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.MaxEntries))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableFeatures(decoder *goloxi.Decoder) (*TableFeatures, error) {
	_tablefeatures := &TableFeatures{}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("TableFeatures packet too short: %d < 64", decoder.Length())
	}
	_tablefeatures.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablefeatures.Length), 2+0)
	_tablefeatures.TableId = uint8(decoder.ReadByte())
	decoder.Skip(5)
	_tablefeatures.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	_tablefeatures.MetadataMatch = uint64(decoder.ReadUint64())
	_tablefeatures.MetadataWrite = uint64(decoder.ReadUint64())
	_tablefeatures.Config = uint32(decoder.ReadUint32())
	_tablefeatures.MaxEntries = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := DecodeTableFeatureProp(decoder)
		if err != nil {
			return nil, err
		}
		_tablefeatures.Properties = append(_tablefeatures.Properties, item)
	}
	return _tablefeatures, nil
}

func NewTableFeatures() *TableFeatures {
	obj := &TableFeatures{}
	return obj
}

type TableModProp struct {
	Type   uint16
	Length uint16
}

type ITableModProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *TableModProp) GetType() uint16 {
	return self.Type
}

func (self *TableModProp) GetLength() uint16 {
	return self.Length
}

func (self *TableModProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func DecodeTableModProp(decoder *goloxi.Decoder) (ITableModProp, error) {
	_tablemodprop := &TableModProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableModProp packet too short: %d < 4", decoder.Length())
	}
	_tablemodprop.Type = uint16(decoder.ReadUint16())
	_tablemodprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablemodprop.Length), 2+2)
	return _tablemodprop, nil
}

func NewTableModProp(_type uint16) *TableModProp {
	obj := &TableModProp{}
	obj.Type = _type
	return obj
}

type TableModPropEviction struct {
	Type   uint16
	Length uint16
	Flags  TableModPropEvictionFlag
}

func (self *TableModPropEviction) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint32(uint32(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableModPropEviction(decoder *goloxi.Decoder) (*TableModPropEviction, error) {
	_tablemodpropeviction := &TableModPropEviction{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableModPropEviction packet too short: %d < 8", decoder.Length())
	}
	_tablemodpropeviction.Type = uint16(decoder.ReadUint16())
	// if _tablemodpropeviction.Type != 2 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '2'.", _tablemodpropeviction.Type)
	// }
	_tablemodpropeviction.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablemodpropeviction.Length), 2+2)
	_tablemodpropeviction.Flags = TableModPropEvictionFlag(decoder.ReadUint32())
	return _tablemodpropeviction, nil
}

func NewTableModPropEviction() *TableModPropEviction {
	obj := &TableModPropEviction{}
	return obj
}

type TableModPropExperimenter struct {
	Type         uint16
	Length       uint16
	Experimenter uint32
	ExpType      uint32
}

type ITableModPropExperimenter interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *TableModPropExperimenter) GetType() uint16 {
	return self.Type
}

func (self *TableModPropExperimenter) GetLength() uint16 {
	return self.Length
}

func (self *TableModPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableModPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *TableModPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func DecodeTableModPropExperimenter(decoder *goloxi.Decoder) (ITableModPropExperimenter, error) {
	_tablemodpropexperimenter := &TableModPropExperimenter{}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("TableModPropExperimenter packet too short: %d < 12", decoder.Length())
	}
	_tablemodpropexperimenter.Type = uint16(decoder.ReadUint16())
	// if _tablemodpropexperimenter.Type != 65535 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '65535'.", _tablemodpropexperimenter.Type)
	// }
	_tablemodpropexperimenter.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablemodpropexperimenter.Length), 2+2)
	_tablemodpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	_tablemodpropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return _tablemodpropexperimenter, nil
}

func NewTableModPropExperimenter(_experimenter uint32) *TableModPropExperimenter {
	obj := &TableModPropExperimenter{}
	obj.Experimenter = _experimenter
	return obj
}

type TableModPropVacancy struct {
	Type        uint16
	Length      uint16
	VacancyDown uint8
	VacancyUp   uint8
	Vacancy     uint8
}

func (self *TableModPropVacancy) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.VacancyDown))
	encoder.PutUint8(uint8(self.VacancyUp))
	encoder.PutUint8(uint8(self.Vacancy))
	encoder.Write(bytes.Repeat([]byte{0}, 1))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeTableModPropVacancy(decoder *goloxi.Decoder) (*TableModPropVacancy, error) {
	_tablemodpropvacancy := &TableModPropVacancy{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableModPropVacancy packet too short: %d < 8", decoder.Length())
	}
	_tablemodpropvacancy.Type = uint16(decoder.ReadUint16())
	// if _tablemodpropvacancy.Type != 3 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '3'.", _tablemodpropvacancy.Type)
	// }
	_tablemodpropvacancy.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_tablemodpropvacancy.Length), 2+2)
	_tablemodpropvacancy.VacancyDown = uint8(decoder.ReadByte())
	_tablemodpropvacancy.VacancyUp = uint8(decoder.ReadByte())
	_tablemodpropvacancy.Vacancy = uint8(decoder.ReadByte())
	decoder.Skip(1)
	return _tablemodpropvacancy, nil
}

func NewTableModPropVacancy() *TableModPropVacancy {
	obj := &TableModPropVacancy{}
	return obj
}

type TableStatsEntry struct {
	TableId      uint8
	ActiveCount  uint32
	LookupCount  uint64
	MatchedCount uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func DecodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	_tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 24", decoder.Length())
	}
	_tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	_tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	_tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	_tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return _tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	obj := &TableStatsEntry{}
	return obj
}

type Uint32 struct {
	Value uint32
}

func (self *Uint32) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.Value))

	return nil
}

func DecodeUint32(decoder *goloxi.Decoder) (*Uint32, error) {
	_uint32 := &Uint32{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Uint32 packet too short: %d < 4", decoder.Length())
	}
	_uint32.Value = uint32(decoder.ReadUint32())
	return _uint32, nil
}

func NewUint32() *Uint32 {
	obj := &Uint32{}
	return obj
}

type Uint64 struct {
	Value uint64
}

func (self *Uint64) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.Value))

	return nil
}

func DecodeUint64(decoder *goloxi.Decoder) (*Uint64, error) {
	_uint64 := &Uint64{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Uint64 packet too short: %d < 8", decoder.Length())
	}
	_uint64.Value = uint64(decoder.ReadUint64())
	return _uint64, nil
}

func NewUint64() *Uint64 {
	obj := &Uint64{}
	return obj
}

type Uint8 struct {
	Value uint8
}

func (self *Uint8) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.Value))

	return nil
}

func DecodeUint8(decoder *goloxi.Decoder) (*Uint8, error) {
	_uint8 := &Uint8{}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("Uint8 packet too short: %d < 1", decoder.Length())
	}
	_uint8.Value = uint8(decoder.ReadByte())
	return _uint8, nil
}

func NewUint8() *Uint8 {
	obj := &Uint8{}
	return obj
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	obj := &EdPropHeader{}
	obj.PropClass = _prop_class
	return obj
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func DecodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	_edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	_edpropnsh.Type = uint8(decoder.ReadByte())
	_edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(_edpropnsh.Len), 1+3)

	switch _edpropnsh.Type {
	case 1:
		return DecodeEdPropNshMdType(_edpropnsh, decoder)
	case 2:
		return DecodeEdPropNshTlv(_edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", _edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	obj := &EdPropNsh{
		EdPropHeader: NewEdPropHeader(4),
	}
	obj.Type = _type
	return obj
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	_edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	_edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return _edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	obj := &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
	return obj
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	_edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	_edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	_edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	_edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return _edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	obj := &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
	return obj
}
