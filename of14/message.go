/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of14

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type Header struct {
	Version uint8
	Type    uint8
	Length  uint16
	Xid     uint32
}

type IHeader interface {
	goloxi.Serializable
	GetVersion() uint8
	GetType() uint8
	GetLength() uint16
	GetXid() uint32
}

func (self *Header) GetVersion() uint8 {
	return self.Version
}

func (self *Header) GetType() uint8 {
	return self.Type
}

func (self *Header) GetLength() uint16 {
	return self.Length
}

func (self *Header) GetXid() uint32 {
	return self.Xid
}

func (self *Header) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(5))
	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint32(uint32(self.Xid))

	return nil
}
func (self *Header) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 8 {
		return fmt.Errorf("Header packet too short: %d < 8", decoder.Length())
	}

	self.Version = uint8(decoder.ReadByte())
	// if self.Version != 5 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '5'.", self.Version)
	// }
	self.Type = uint8(decoder.ReadByte())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)
	self.Xid = uint32(decoder.ReadUint32())

	return nil
}
func decodeHeader(decoder *goloxi.Decoder) (IHeader, error) {
	header := &Header{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Header packet too short: %d < 8", decoder.Length())
	}
	header.Version = uint8(decoder.ReadByte())
	// if header.Version != 5 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '5'.", header.Version)
	// }
	header.Type = uint8(decoder.ReadByte())
	header.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(header.Length), 2+2)
	header.Xid = uint32(decoder.ReadUint32())

	switch header.Type {
	case 0:
		return decodeHello(header, decoder)
	case 1:
		return decodeErrorMsg(header, decoder)
	case 2:
		return decodeEchoRequest(header, decoder)
	case 3:
		return decodeEchoReply(header, decoder)
	case 4:
		return decodeExperimenter(header, decoder)
	case 5:
		return decodeFeaturesRequest(header, decoder)
	case 6:
		return decodeFeaturesReply(header, decoder)
	case 7:
		return decodeGetConfigRequest(header, decoder)
	case 8:
		return decodeGetConfigReply(header, decoder)
	case 9:
		return decodeSetConfig(header, decoder)
	case 10:
		return decodePacketIn(header, decoder)
	case 11:
		return decodeFlowRemoved(header, decoder)
	case 12:
		return decodePortStatus(header, decoder)
	case 13:
		return decodePacketOut(header, decoder)
	case 14:
		return decodeFlowMod(header, decoder)
	case 15:
		return decodeGroupMod(header, decoder)
	case 16:
		return decodePortMod(header, decoder)
	case 17:
		return decodeTableMod(header, decoder)
	case 18:
		return decodeStatsRequest(header, decoder)
	case 19:
		return decodeStatsReply(header, decoder)
	case 20:
		return decodeBarrierRequest(header, decoder)
	case 21:
		return decodeBarrierReply(header, decoder)
	case 24:
		return decodeRoleRequest(header, decoder)
	case 25:
		return decodeRoleReply(header, decoder)
	case 26:
		return decodeAsyncGetRequest(header, decoder)
	case 27:
		return decodeAsyncGetReply(header, decoder)
	case 28:
		return decodeAsyncSet(header, decoder)
	case 29:
		return decodeMeterMod(header, decoder)
	case 30:
		return decodeRoleStatus(header, decoder)
	case 31:
		return decodeTableStatus(header, decoder)
	case 32:
		return decodeRequestforward(header, decoder)
	case 33:
		return decodeBundleCtrlMsg(header, decoder)
	case 34:
		return decodeBundleAddMsg(header, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Header'", header.Type)
	}
}

func NewHeader(_type uint8) *Header {
	return &Header{
		Type: _type,
	}
}

type StatsReply struct {
	*Header
	StatsType uint16
	Flags     StatsReplyFlags
}

type IStatsReply interface {
	IHeader
	GetStatsType() uint16
	GetFlags() StatsReplyFlags
}

func (self *StatsReply) GetStatsType() uint16 {
	return self.StatsType
}

func (self *StatsReply) GetFlags() StatsReplyFlags {
	return self.Flags
}

func (self *StatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.StatsType))
	encoder.PutUint16(uint16(self.Flags))

	return nil
}

func decodeStatsReply(parent *Header, decoder *goloxi.Decoder) (IStatsReply, error) {
	statsreply := &StatsReply{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("StatsReply packet too short: %d < 4", decoder.Length())
	}
	statsreply.StatsType = uint16(decoder.ReadUint16())
	statsreply.Flags = StatsReplyFlags(decoder.ReadUint16())

	switch statsreply.StatsType {
	case 0:
		return decodeDescStatsReply(statsreply, decoder)
	case 1:
		return decodeFlowStatsReply(statsreply, decoder)
	case 2:
		return decodeAggregateStatsReply(statsreply, decoder)
	case 3:
		return decodeTableStatsReply(statsreply, decoder)
	case 4:
		return decodePortStatsReply(statsreply, decoder)
	case 5:
		return decodeQueueStatsReply(statsreply, decoder)
	case 6:
		return decodeGroupStatsReply(statsreply, decoder)
	case 7:
		return decodeGroupDescStatsReply(statsreply, decoder)
	case 8:
		return decodeGroupFeaturesStatsReply(statsreply, decoder)
	case 9:
		return decodeMeterStatsReply(statsreply, decoder)
	case 10:
		return decodeMeterConfigStatsReply(statsreply, decoder)
	case 11:
		return decodeMeterFeaturesStatsReply(statsreply, decoder)
	case 12:
		return decodeTableFeaturesStatsReply(statsreply, decoder)
	case 13:
		return decodePortDescStatsReply(statsreply, decoder)
	case 14:
		return decodeTableDescStatsReply(statsreply, decoder)
	case 15:
		return decodeQueueDescStatsReply(statsreply, decoder)
	case 65535:
		return decodeExperimenterStatsReply(statsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'StatsReply'", statsreply.StatsType)
	}
}

func NewStatsReply(_stats_type uint16) *StatsReply {
	return &StatsReply{
		StatsType: _stats_type,
		Header:    NewHeader(19),
	}
}

type AggregateStatsReply struct {
	*StatsReply
	PacketCount uint64
	ByteCount   uint64
	FlowCount   uint32
}

func (self *AggregateStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	encoder.PutUint32(uint32(self.FlowCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAggregateStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*AggregateStatsReply, error) {
	aggregatestatsreply := &AggregateStatsReply{StatsReply: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("AggregateStatsReply packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	aggregatestatsreply.PacketCount = uint64(decoder.ReadUint64())
	aggregatestatsreply.ByteCount = uint64(decoder.ReadUint64())
	aggregatestatsreply.FlowCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return aggregatestatsreply, nil
}

func NewAggregateStatsReply() *AggregateStatsReply {
	return &AggregateStatsReply{
		StatsReply: NewStatsReply(2),
	}
}

type StatsRequest struct {
	*Header
	StatsType uint16
	Flags     StatsRequestFlags
}

type IStatsRequest interface {
	IHeader
	GetStatsType() uint16
	GetFlags() StatsRequestFlags
}

func (self *StatsRequest) GetStatsType() uint16 {
	return self.StatsType
}

func (self *StatsRequest) GetFlags() StatsRequestFlags {
	return self.Flags
}

func (self *StatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.StatsType))
	encoder.PutUint16(uint16(self.Flags))

	return nil
}

func decodeStatsRequest(parent *Header, decoder *goloxi.Decoder) (IStatsRequest, error) {
	statsrequest := &StatsRequest{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("StatsRequest packet too short: %d < 4", decoder.Length())
	}
	statsrequest.StatsType = uint16(decoder.ReadUint16())
	statsrequest.Flags = StatsRequestFlags(decoder.ReadUint16())

	switch statsrequest.StatsType {
	case 0:
		return decodeDescStatsRequest(statsrequest, decoder)
	case 1:
		return decodeFlowStatsRequest(statsrequest, decoder)
	case 2:
		return decodeAggregateStatsRequest(statsrequest, decoder)
	case 3:
		return decodeTableStatsRequest(statsrequest, decoder)
	case 4:
		return decodePortStatsRequest(statsrequest, decoder)
	case 5:
		return decodeQueueStatsRequest(statsrequest, decoder)
	case 6:
		return decodeGroupStatsRequest(statsrequest, decoder)
	case 7:
		return decodeGroupDescStatsRequest(statsrequest, decoder)
	case 8:
		return decodeGroupFeaturesStatsRequest(statsrequest, decoder)
	case 9:
		return decodeMeterStatsRequest(statsrequest, decoder)
	case 10:
		return decodeMeterConfigStatsRequest(statsrequest, decoder)
	case 11:
		return decodeMeterFeaturesStatsRequest(statsrequest, decoder)
	case 12:
		return decodeTableFeaturesStatsRequest(statsrequest, decoder)
	case 13:
		return decodePortDescStatsRequest(statsrequest, decoder)
	case 14:
		return decodeTableDescStatsRequest(statsrequest, decoder)
	case 15:
		return decodeQueueDescStatsRequest(statsrequest, decoder)
	case 65535:
		return decodeExperimenterStatsRequest(statsrequest, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'StatsRequest'", statsrequest.StatsType)
	}
}

func NewStatsRequest(_stats_type uint16) *StatsRequest {
	return &StatsRequest{
		StatsType: _stats_type,
		Header:    NewHeader(18),
	}
}

type AggregateStatsRequest struct {
	*StatsRequest
	TableId    uint8
	OutPort    PortNo
	OutGroup   uint32
	Cookie     uint64
	CookieMask uint64
	Match      Match
}

func (self *AggregateStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	self.OutPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.OutGroup))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.CookieMask))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAggregateStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*AggregateStatsRequest, error) {
	aggregatestatsrequest := &AggregateStatsRequest{StatsRequest: parent}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("AggregateStatsRequest packet too short: %d < 40", decoder.Length())
	}
	decoder.Skip(4)
	aggregatestatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	aggregatestatsrequest.OutPort.Decode(decoder)
	aggregatestatsrequest.OutGroup = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	aggregatestatsrequest.Cookie = uint64(decoder.ReadUint64())
	aggregatestatsrequest.CookieMask = uint64(decoder.ReadUint64())
	if err := aggregatestatsrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return aggregatestatsrequest, nil
}

func NewAggregateStatsRequest() *AggregateStatsRequest {
	return &AggregateStatsRequest{
		StatsRequest: NewStatsRequest(2),
	}
}

type ErrorMsg struct {
	*Header
	ErrType uint16
}

type IErrorMsg interface {
	IHeader
	GetErrType() uint16
}

func (self *ErrorMsg) GetErrType() uint16 {
	return self.ErrType
}

func (self *ErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.ErrType))

	return nil
}

func decodeErrorMsg(parent *Header, decoder *goloxi.Decoder) (IErrorMsg, error) {
	errormsg := &ErrorMsg{Header: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("ErrorMsg packet too short: %d < 2", decoder.Length())
	}
	errormsg.ErrType = uint16(decoder.ReadUint16())

	switch errormsg.ErrType {
	case 0:
		return decodeHelloFailedErrorMsg(errormsg, decoder)
	case 1:
		return decodeBadRequestErrorMsg(errormsg, decoder)
	case 2:
		return decodeBadActionErrorMsg(errormsg, decoder)
	case 3:
		return decodeBadInstructionErrorMsg(errormsg, decoder)
	case 4:
		return decodeBadMatchErrorMsg(errormsg, decoder)
	case 5:
		return decodeFlowModFailedErrorMsg(errormsg, decoder)
	case 6:
		return decodeGroupModFailedErrorMsg(errormsg, decoder)
	case 7:
		return decodePortModFailedErrorMsg(errormsg, decoder)
	case 8:
		return decodeTableModFailedErrorMsg(errormsg, decoder)
	case 9:
		return decodeQueueOpFailedErrorMsg(errormsg, decoder)
	case 10:
		return decodeSwitchConfigFailedErrorMsg(errormsg, decoder)
	case 11:
		return decodeRoleRequestFailedErrorMsg(errormsg, decoder)
	case 12:
		return decodeMeterModFailedErrorMsg(errormsg, decoder)
	case 13:
		return decodeTableFeaturesFailedErrorMsg(errormsg, decoder)
	case 14:
		return decodeBadPropertyErrorMsg(errormsg, decoder)
	case 15:
		return decodeAsyncConfigFailedErrorMsg(errormsg, decoder)
	case 16:
		return decodeFlowMonitorFailedErrorMsg(errormsg, decoder)
	case 17:
		return decodeBundleFailedErrorMsg(errormsg, decoder)
	case 65535:
		return decodeExperimenterErrorMsg(errormsg, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ErrorMsg'", errormsg.ErrType)
	}
}

func NewErrorMsg(_err_type uint16) *ErrorMsg {
	return &ErrorMsg{
		ErrType: _err_type,
		Header:  NewHeader(1),
	}
}

type AsyncConfigFailedErrorMsg struct {
	*ErrorMsg
	Code AsyncConfigFailedCode
	Data []byte
}

func (self *AsyncConfigFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*AsyncConfigFailedErrorMsg, error) {
	asyncconfigfailederrormsg := &AsyncConfigFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("AsyncConfigFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	asyncconfigfailederrormsg.Code = AsyncConfigFailedCode(decoder.ReadUint16())
	asyncconfigfailederrormsg.Data = decoder.Read(decoder.Length())
	return asyncconfigfailederrormsg, nil
}

func NewAsyncConfigFailedErrorMsg() *AsyncConfigFailedErrorMsg {
	return &AsyncConfigFailedErrorMsg{
		ErrorMsg: NewErrorMsg(15),
	}
}

type AsyncGetReply struct {
	*Header
	Properties []IAsyncConfigProp
}

func (self *AsyncGetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncGetReply(parent *Header, decoder *goloxi.Decoder) (*AsyncGetReply, error) {
	asyncgetreply := &AsyncGetReply{Header: parent}

	for decoder.Length() >= 4 {
		item, err := decodeAsyncConfigProp(decoder)
		if err != nil {
			return nil, err
		}
		asyncgetreply.Properties = append(asyncgetreply.Properties, item)
	}
	return asyncgetreply, nil
}

func NewAsyncGetReply() *AsyncGetReply {
	return &AsyncGetReply{
		Header: NewHeader(27),
	}
}

type AsyncGetRequest struct {
	*Header
	Properties []IAsyncConfigProp
}

func (self *AsyncGetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncGetRequest(parent *Header, decoder *goloxi.Decoder) (*AsyncGetRequest, error) {
	asyncgetrequest := &AsyncGetRequest{Header: parent}

	for decoder.Length() >= 4 {
		item, err := decodeAsyncConfigProp(decoder)
		if err != nil {
			return nil, err
		}
		asyncgetrequest.Properties = append(asyncgetrequest.Properties, item)
	}
	return asyncgetrequest, nil
}

func NewAsyncGetRequest() *AsyncGetRequest {
	return &AsyncGetRequest{
		Header: NewHeader(26),
	}
}

type AsyncSet struct {
	*Header
	Properties []IAsyncConfigProp
}

func (self *AsyncSet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncSet(parent *Header, decoder *goloxi.Decoder) (*AsyncSet, error) {
	asyncset := &AsyncSet{Header: parent}

	for decoder.Length() >= 4 {
		item, err := decodeAsyncConfigProp(decoder)
		if err != nil {
			return nil, err
		}
		asyncset.Properties = append(asyncset.Properties, item)
	}
	return asyncset, nil
}

func NewAsyncSet() *AsyncSet {
	return &AsyncSet{
		Header: NewHeader(28),
	}
}

type BadActionErrorMsg struct {
	*ErrorMsg
	Code BadActionCode
	Data []byte
}

func (self *BadActionErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadActionErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadActionErrorMsg, error) {
	badactionerrormsg := &BadActionErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadActionErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badactionerrormsg.Code = BadActionCode(decoder.ReadUint16())
	badactionerrormsg.Data = decoder.Read(decoder.Length())
	return badactionerrormsg, nil
}

func NewBadActionErrorMsg() *BadActionErrorMsg {
	return &BadActionErrorMsg{
		ErrorMsg: NewErrorMsg(2),
	}
}

type BadInstructionErrorMsg struct {
	*ErrorMsg
	Code BadInstructionCode
	Data []byte
}

func (self *BadInstructionErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadInstructionErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadInstructionErrorMsg, error) {
	badinstructionerrormsg := &BadInstructionErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadInstructionErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badinstructionerrormsg.Code = BadInstructionCode(decoder.ReadUint16())
	badinstructionerrormsg.Data = decoder.Read(decoder.Length())
	return badinstructionerrormsg, nil
}

func NewBadInstructionErrorMsg() *BadInstructionErrorMsg {
	return &BadInstructionErrorMsg{
		ErrorMsg: NewErrorMsg(3),
	}
}

type BadMatchErrorMsg struct {
	*ErrorMsg
	Code BadMatchCode
	Data []byte
}

func (self *BadMatchErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadMatchErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadMatchErrorMsg, error) {
	badmatcherrormsg := &BadMatchErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadMatchErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badmatcherrormsg.Code = BadMatchCode(decoder.ReadUint16())
	badmatcherrormsg.Data = decoder.Read(decoder.Length())
	return badmatcherrormsg, nil
}

func NewBadMatchErrorMsg() *BadMatchErrorMsg {
	return &BadMatchErrorMsg{
		ErrorMsg: NewErrorMsg(4),
	}
}

type BadPropertyErrorMsg struct {
	*ErrorMsg
	Code BadPropertyCode
	Data []byte
}

func (self *BadPropertyErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadPropertyErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadPropertyErrorMsg, error) {
	badpropertyerrormsg := &BadPropertyErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadPropertyErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badpropertyerrormsg.Code = BadPropertyCode(decoder.ReadUint16())
	badpropertyerrormsg.Data = decoder.Read(decoder.Length())
	return badpropertyerrormsg, nil
}

func NewBadPropertyErrorMsg() *BadPropertyErrorMsg {
	return &BadPropertyErrorMsg{
		ErrorMsg: NewErrorMsg(14),
	}
}

type BadRequestErrorMsg struct {
	*ErrorMsg
	Code BadRequestCode
	Data []byte
}

func (self *BadRequestErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBadRequestErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BadRequestErrorMsg, error) {
	badrequesterrormsg := &BadRequestErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BadRequestErrorMsg packet too short: %d < 2", decoder.Length())
	}
	badrequesterrormsg.Code = BadRequestCode(decoder.ReadUint16())
	badrequesterrormsg.Data = decoder.Read(decoder.Length())
	return badrequesterrormsg, nil
}

func NewBadRequestErrorMsg() *BadRequestErrorMsg {
	return &BadRequestErrorMsg{
		ErrorMsg: NewErrorMsg(1),
	}
}

type BarrierReply struct {
	*Header
}

func (self *BarrierReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBarrierReply(parent *Header, decoder *goloxi.Decoder) (*BarrierReply, error) {
	barrierreply := &BarrierReply{Header: parent}
	return barrierreply, nil
}

func NewBarrierReply() *BarrierReply {
	return &BarrierReply{
		Header: NewHeader(21),
	}
}

type BarrierRequest struct {
	*Header
}

func (self *BarrierRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBarrierRequest(parent *Header, decoder *goloxi.Decoder) (*BarrierRequest, error) {
	barrierrequest := &BarrierRequest{Header: parent}
	return barrierrequest, nil
}

func NewBarrierRequest() *BarrierRequest {
	return &BarrierRequest{
		Header: NewHeader(20),
	}
}

type Experimenter struct {
	*Header
	Experimenter uint32
	Subtype      uint32
}

type IExperimenter interface {
	IHeader
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *Experimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *Experimenter) GetSubtype() uint32 {
	return self.Subtype
}

func (self *Experimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeExperimenter(parent *Header, decoder *goloxi.Decoder) (IExperimenter, error) {
	experimenter := &Experimenter{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Experimenter packet too short: %d < 8", decoder.Length())
	}
	experimenter.Experimenter = uint32(decoder.ReadUint32())
	experimenter.Subtype = uint32(decoder.ReadUint32())

	switch experimenter.Experimenter {
	case 8992:
		return decodeNiciraHeader(experimenter, decoder)
	case 6035143:
		return decodeBsnHeader(experimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Experimenter'", experimenter.Experimenter)
	}
}

func NewExperimenter(_experimenter uint32) *Experimenter {
	return &Experimenter{
		Experimenter: _experimenter,
		Header:       NewHeader(4),
	}
}

type BsnHeader struct {
	*Experimenter
}

type IBsnHeader interface {
	IExperimenter
}

func (self *BsnHeader) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Experimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodeBsnHeader(parent *Experimenter, decoder *goloxi.Decoder) (IBsnHeader, error) {
	bsnheader := &BsnHeader{Experimenter: parent}

	switch bsnheader.Subtype {
	case 3:
		return decodeBsnSetMirroring(bsnheader, decoder)
	case 4:
		return decodeBsnGetMirroringRequest(bsnheader, decoder)
	case 5:
		return decodeBsnGetMirroringReply(bsnheader, decoder)
	case 9:
		return decodeBsnGetInterfacesRequest(bsnheader, decoder)
	case 10:
		return decodeBsnGetInterfacesReply(bsnheader, decoder)
	case 11:
		return decodeBsnSetPktinSuppressionRequest(bsnheader, decoder)
	case 15:
		return decodeBsnVirtualPortCreateRequest(bsnheader, decoder)
	case 16:
		return decodeBsnVirtualPortCreateReply(bsnheader, decoder)
	case 17:
		return decodeBsnVirtualPortRemoveRequest(bsnheader, decoder)
	case 18:
		return decodeBsnBwEnableSetRequest(bsnheader, decoder)
	case 19:
		return decodeBsnBwEnableGetRequest(bsnheader, decoder)
	case 20:
		return decodeBsnBwEnableGetReply(bsnheader, decoder)
	case 21:
		return decodeBsnBwClearDataRequest(bsnheader, decoder)
	case 22:
		return decodeBsnBwClearDataReply(bsnheader, decoder)
	case 23:
		return decodeBsnBwEnableSetReply(bsnheader, decoder)
	case 25:
		return decodeBsnSetPktinSuppressionReply(bsnheader, decoder)
	case 26:
		return decodeBsnVirtualPortRemoveReply(bsnheader, decoder)
	case 31:
		return decodeBsnPduTxRequest(bsnheader, decoder)
	case 32:
		return decodeBsnPduTxReply(bsnheader, decoder)
	case 33:
		return decodeBsnPduRxRequest(bsnheader, decoder)
	case 34:
		return decodeBsnPduRxReply(bsnheader, decoder)
	case 35:
		return decodeBsnPduRxTimeout(bsnheader, decoder)
	case 36:
		return decodeBsnFlowIdleEnableSetRequest(bsnheader, decoder)
	case 37:
		return decodeBsnFlowIdleEnableSetReply(bsnheader, decoder)
	case 38:
		return decodeBsnFlowIdleEnableGetRequest(bsnheader, decoder)
	case 39:
		return decodeBsnFlowIdleEnableGetReply(bsnheader, decoder)
	case 40:
		return decodeBsnFlowIdle(bsnheader, decoder)
	case 41:
		return decodeBsnSetLacpRequest(bsnheader, decoder)
	case 42:
		return decodeBsnSetLacpReply(bsnheader, decoder)
	case 43:
		return decodeBsnLacpConvergenceNotif(bsnheader, decoder)
	case 44:
		return decodeBsnTimeRequest(bsnheader, decoder)
	case 45:
		return decodeBsnTimeReply(bsnheader, decoder)
	case 46:
		return decodeBsnGentableEntryAdd(bsnheader, decoder)
	case 47:
		return decodeBsnGentableEntryDelete(bsnheader, decoder)
	case 48:
		return decodeBsnGentableClearRequest(bsnheader, decoder)
	case 49:
		return decodeBsnGentableClearReply(bsnheader, decoder)
	case 50:
		return decodeBsnGentableSetBucketsSize(bsnheader, decoder)
	case 51:
		return decodeBsnGetSwitchPipelineRequest(bsnheader, decoder)
	case 52:
		return decodeBsnGetSwitchPipelineReply(bsnheader, decoder)
	case 53:
		return decodeBsnSetSwitchPipelineRequest(bsnheader, decoder)
	case 54:
		return decodeBsnSetSwitchPipelineReply(bsnheader, decoder)
	case 56:
		return decodeBsnControllerConnectionsRequest(bsnheader, decoder)
	case 57:
		return decodeBsnControllerConnectionsReply(bsnheader, decoder)
	case 58:
		return decodeBsnSetAuxCxnsRequest(bsnheader, decoder)
	case 59:
		return decodeBsnSetAuxCxnsReply(bsnheader, decoder)
	case 60:
		return decodeBsnArpIdle(bsnheader, decoder)
	case 61:
		return decodeBsnTableSetBucketsSize(bsnheader, decoder)
	case 63:
		return decodeBsnLog(bsnheader, decoder)
	case 64:
		return decodeBsnLuaUpload(bsnheader, decoder)
	case 65:
		return decodeBsnLuaCommandRequest(bsnheader, decoder)
	case 66:
		return decodeBsnLuaCommandReply(bsnheader, decoder)
	case 67:
		return decodeBsnLuaNotification(bsnheader, decoder)
	case 68:
		return decodeBsnGenericAsync(bsnheader, decoder)
	case 69:
		return decodeBsnTakeover(bsnheader, decoder)
	case 70:
		return decodeBsnVlanCounterClear(bsnheader, decoder)
	case 71:
		return decodeBsnGenericCommand(bsnheader, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnHeader'", bsnheader.Subtype)
	}
}

func NewBsnHeader(_subtype uint32) *BsnHeader {
	return &BsnHeader{
		Subtype:      _subtype,
		Experimenter: NewExperimenter(6035143),
	}
}

type BsnArpIdle struct {
	*BsnHeader
	VlanVid  uint16
	Ipv4Addr net.IP
}

func (self *BsnArpIdle) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.VlanVid))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.Ipv4Addr.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnArpIdle(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnArpIdle, error) {
	bsnarpidle := &BsnArpIdle{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnArpIdle packet too short: %d < 8", decoder.Length())
	}
	bsnarpidle.VlanVid = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsnarpidle.Ipv4Addr = net.IP(decoder.Read(4))
	return bsnarpidle, nil
}

func NewBsnArpIdle() *BsnArpIdle {
	return &BsnArpIdle{
		BsnHeader: NewBsnHeader(60),
	}
}

type ExperimenterErrorMsg struct {
	*ErrorMsg
	Subtype      uint16
	Experimenter uint32
}

type IExperimenterErrorMsg interface {
	IErrorMsg
	GetSubtype() uint16
	GetExperimenter() uint32
}

func (self *ExperimenterErrorMsg) GetSubtype() uint16 {
	return self.Subtype
}

func (self *ExperimenterErrorMsg) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ExperimenterErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Subtype))
	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeExperimenterErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (IExperimenterErrorMsg, error) {
	experimentererrormsg := &ExperimenterErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("ExperimenterErrorMsg packet too short: %d < 6", decoder.Length())
	}
	experimentererrormsg.Subtype = uint16(decoder.ReadUint16())
	experimentererrormsg.Experimenter = uint32(decoder.ReadUint32())

	switch experimentererrormsg.Experimenter {
	case 6035143:
		return decodeBsnBaseError(experimentererrormsg, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ExperimenterErrorMsg'", experimentererrormsg.Experimenter)
	}
}

func NewExperimenterErrorMsg(_experimenter uint32) *ExperimenterErrorMsg {
	return &ExperimenterErrorMsg{
		Experimenter: _experimenter,
		ErrorMsg:     NewErrorMsg(65535),
	}
}

type BsnBaseError struct {
	*ExperimenterErrorMsg
	ErrMsg string
}

type IBsnBaseError interface {
	IExperimenterErrorMsg
	GetErrMsg() string
}

func (self *BsnBaseError) GetErrMsg() string {
	return self.ErrMsg
}

func (self *BsnBaseError) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.ErrMsg))

	return nil
}

func decodeBsnBaseError(parent *ExperimenterErrorMsg, decoder *goloxi.Decoder) (IBsnBaseError, error) {
	bsnbaseerror := &BsnBaseError{ExperimenterErrorMsg: parent}
	if decoder.Length() < 256 {
		return nil, fmt.Errorf("BsnBaseError packet too short: %d < 256", decoder.Length())
	}
	bsnbaseerror.ErrMsg = string(bytes.Trim(decoder.Read(256), "\x00"))

	switch bsnbaseerror.Subtype {
	case 1:
		return decodeBsnError(bsnbaseerror, decoder)
	case 2:
		return decodeBsnGentableError(bsnbaseerror, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnBaseError'", bsnbaseerror.Subtype)
	}
}

func NewBsnBaseError(_subtype uint16) *BsnBaseError {
	return &BsnBaseError{
		Subtype:              _subtype,
		ExperimenterErrorMsg: NewExperimenterErrorMsg(6035143),
	}
}

type BsnBwClearDataReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnBwClearDataReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwClearDataReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwClearDataReply, error) {
	bsnbwcleardatareply := &BsnBwClearDataReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwClearDataReply packet too short: %d < 4", decoder.Length())
	}
	bsnbwcleardatareply.Status = uint32(decoder.ReadUint32())
	return bsnbwcleardatareply, nil
}

func NewBsnBwClearDataReply() *BsnBwClearDataReply {
	return &BsnBwClearDataReply{
		BsnHeader: NewBsnHeader(22),
	}
}

type BsnBwClearDataRequest struct {
	*BsnHeader
}

func (self *BsnBwClearDataRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwClearDataRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwClearDataRequest, error) {
	bsnbwcleardatarequest := &BsnBwClearDataRequest{BsnHeader: parent}
	return bsnbwcleardatarequest, nil
}

func NewBsnBwClearDataRequest() *BsnBwClearDataRequest {
	return &BsnBwClearDataRequest{
		BsnHeader: NewBsnHeader(21),
	}
}

type BsnBwEnableGetReply struct {
	*BsnHeader
	Enabled uint32
}

func (self *BsnBwEnableGetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enabled))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableGetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableGetReply, error) {
	bsnbwenablegetreply := &BsnBwEnableGetReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwEnableGetReply packet too short: %d < 4", decoder.Length())
	}
	bsnbwenablegetreply.Enabled = uint32(decoder.ReadUint32())
	return bsnbwenablegetreply, nil
}

func NewBsnBwEnableGetReply() *BsnBwEnableGetReply {
	return &BsnBwEnableGetReply{
		BsnHeader: NewBsnHeader(20),
	}
}

type BsnBwEnableGetRequest struct {
	*BsnHeader
}

func (self *BsnBwEnableGetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableGetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableGetRequest, error) {
	bsnbwenablegetrequest := &BsnBwEnableGetRequest{BsnHeader: parent}
	return bsnbwenablegetrequest, nil
}

func NewBsnBwEnableGetRequest() *BsnBwEnableGetRequest {
	return &BsnBwEnableGetRequest{
		BsnHeader: NewBsnHeader(19),
	}
}

type BsnBwEnableSetReply struct {
	*BsnHeader
	Enable uint32
	Status uint32
}

func (self *BsnBwEnableSetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))
	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableSetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableSetReply, error) {
	bsnbwenablesetreply := &BsnBwEnableSetReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnBwEnableSetReply packet too short: %d < 8", decoder.Length())
	}
	bsnbwenablesetreply.Enable = uint32(decoder.ReadUint32())
	bsnbwenablesetreply.Status = uint32(decoder.ReadUint32())
	return bsnbwenablesetreply, nil
}

func NewBsnBwEnableSetReply() *BsnBwEnableSetReply {
	return &BsnBwEnableSetReply{
		BsnHeader: NewBsnHeader(23),
	}
}

type BsnBwEnableSetRequest struct {
	*BsnHeader
	Enable uint32
}

func (self *BsnBwEnableSetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnBwEnableSetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnBwEnableSetRequest, error) {
	bsnbwenablesetrequest := &BsnBwEnableSetRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnBwEnableSetRequest packet too short: %d < 4", decoder.Length())
	}
	bsnbwenablesetrequest.Enable = uint32(decoder.ReadUint32())
	return bsnbwenablesetrequest, nil
}

func NewBsnBwEnableSetRequest() *BsnBwEnableSetRequest {
	return &BsnBwEnableSetRequest{
		BsnHeader: NewBsnHeader(18),
	}
}

type BsnControllerConnectionsReply struct {
	*BsnHeader
	Connections []*BsnControllerConnection
}

func (self *BsnControllerConnectionsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Connections {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnControllerConnectionsReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnControllerConnectionsReply, error) {
	bsncontrollerconnectionsreply := &BsnControllerConnectionsReply{BsnHeader: parent}

	for decoder.Length() >= 264 {
		item, err := decodeBsnControllerConnection(decoder)
		if err != nil {
			return nil, err
		}
		bsncontrollerconnectionsreply.Connections = append(bsncontrollerconnectionsreply.Connections, item)
	}
	return bsncontrollerconnectionsreply, nil
}

func NewBsnControllerConnectionsReply() *BsnControllerConnectionsReply {
	return &BsnControllerConnectionsReply{
		BsnHeader: NewBsnHeader(57),
	}
}

type BsnControllerConnectionsRequest struct {
	*BsnHeader
}

func (self *BsnControllerConnectionsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnControllerConnectionsRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnControllerConnectionsRequest, error) {
	bsncontrollerconnectionsrequest := &BsnControllerConnectionsRequest{BsnHeader: parent}
	return bsncontrollerconnectionsrequest, nil
}

func NewBsnControllerConnectionsRequest() *BsnControllerConnectionsRequest {
	return &BsnControllerConnectionsRequest{
		BsnHeader: NewBsnHeader(56),
	}
}

type ExperimenterStatsReply struct {
	*StatsReply
	Experimenter uint32
	Subtype      uint32
}

type IExperimenterStatsReply interface {
	IStatsReply
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *ExperimenterStatsReply) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ExperimenterStatsReply) GetSubtype() uint32 {
	return self.Subtype
}

func (self *ExperimenterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeExperimenterStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (IExperimenterStatsReply, error) {
	experimenterstatsreply := &ExperimenterStatsReply{StatsReply: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("ExperimenterStatsReply packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	experimenterstatsreply.Experimenter = uint32(decoder.ReadUint32())
	experimenterstatsreply.Subtype = uint32(decoder.ReadUint32())

	switch experimenterstatsreply.Experimenter {
	case 8992:
		return decodeNiciraStatsReply(experimenterstatsreply, decoder)
	case 6035143:
		return decodeBsnStatsReply(experimenterstatsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ExperimenterStatsReply'", experimenterstatsreply.Experimenter)
	}
}

func NewExperimenterStatsReply(_experimenter uint32) *ExperimenterStatsReply {
	return &ExperimenterStatsReply{
		Experimenter: _experimenter,
		StatsReply:   NewStatsReply(65535),
	}
}

type BsnStatsReply struct {
	*ExperimenterStatsReply
}

type IBsnStatsReply interface {
	IExperimenterStatsReply
}

func (self *BsnStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func decodeBsnStatsReply(parent *ExperimenterStatsReply, decoder *goloxi.Decoder) (IBsnStatsReply, error) {
	bsnstatsreply := &BsnStatsReply{ExperimenterStatsReply: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnStatsReply packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)

	switch bsnstatsreply.Subtype {
	case 1:
		return decodeBsnLacpStatsReply(bsnstatsreply, decoder)
	case 2:
		return decodeBsnGentableEntryDescStatsReply(bsnstatsreply, decoder)
	case 3:
		return decodeBsnGentableEntryStatsReply(bsnstatsreply, decoder)
	case 4:
		return decodeBsnGentableDescStatsReply(bsnstatsreply, decoder)
	case 5:
		return decodeBsnGentableBucketStatsReply(bsnstatsreply, decoder)
	case 6:
		return decodeBsnSwitchPipelineStatsReply(bsnstatsreply, decoder)
	case 7:
		return decodeBsnGentableStatsReply(bsnstatsreply, decoder)
	case 8:
		return decodeBsnPortCounterStatsReply(bsnstatsreply, decoder)
	case 9:
		return decodeBsnVlanCounterStatsReply(bsnstatsreply, decoder)
	case 10:
		return decodeBsnFlowChecksumBucketStatsReply(bsnstatsreply, decoder)
	case 11:
		return decodeBsnTableChecksumStatsReply(bsnstatsreply, decoder)
	case 12:
		return decodeBsnDebugCounterStatsReply(bsnstatsreply, decoder)
	case 13:
		return decodeBsnDebugCounterDescStatsReply(bsnstatsreply, decoder)
	case 14:
		return decodeBsnImageDescStatsReply(bsnstatsreply, decoder)
	case 15:
		return decodeBsnVrfCounterStatsReply(bsnstatsreply, decoder)
	case 16:
		return decodeBsnGenericStatsReply(bsnstatsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnStatsReply'", bsnstatsreply.Subtype)
	}
}

func NewBsnStatsReply(_subtype uint32) *BsnStatsReply {
	return &BsnStatsReply{
		Subtype:                _subtype,
		ExperimenterStatsReply: NewExperimenterStatsReply(6035143),
	}
}

type BsnDebugCounterDescStatsReply struct {
	*BsnStatsReply
	Entries []*BsnDebugCounterDescStatsEntry
}

func (self *BsnDebugCounterDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnDebugCounterDescStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnDebugCounterDescStatsReply, error) {
	bsndebugcounterdescstatsreply := &BsnDebugCounterDescStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 328 {
		item, err := decodeBsnDebugCounterDescStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsndebugcounterdescstatsreply.Entries = append(bsndebugcounterdescstatsreply.Entries, item)
	}
	return bsndebugcounterdescstatsreply, nil
}

func NewBsnDebugCounterDescStatsReply() *BsnDebugCounterDescStatsReply {
	return &BsnDebugCounterDescStatsReply{
		BsnStatsReply: NewBsnStatsReply(13),
	}
}

type ExperimenterStatsRequest struct {
	*StatsRequest
	Experimenter uint32
	Subtype      uint32
}

type IExperimenterStatsRequest interface {
	IStatsRequest
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *ExperimenterStatsRequest) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ExperimenterStatsRequest) GetSubtype() uint32 {
	return self.Subtype
}

func (self *ExperimenterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeExperimenterStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (IExperimenterStatsRequest, error) {
	experimenterstatsrequest := &ExperimenterStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("ExperimenterStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	experimenterstatsrequest.Experimenter = uint32(decoder.ReadUint32())
	experimenterstatsrequest.Subtype = uint32(decoder.ReadUint32())

	switch experimenterstatsrequest.Experimenter {
	case 8992:
		return decodeNiciraFlowStatsRequest(experimenterstatsrequest, decoder)
	case 6035143:
		return decodeBsnStatsRequest(experimenterstatsrequest, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ExperimenterStatsRequest'", experimenterstatsrequest.Experimenter)
	}
}

func NewExperimenterStatsRequest(_experimenter uint32) *ExperimenterStatsRequest {
	return &ExperimenterStatsRequest{
		Experimenter: _experimenter,
		StatsRequest: NewStatsRequest(65535),
	}
}

type BsnStatsRequest struct {
	*ExperimenterStatsRequest
}

type IBsnStatsRequest interface {
	IExperimenterStatsRequest
}

func (self *BsnStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func decodeBsnStatsRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (IBsnStatsRequest, error) {
	bsnstatsrequest := &BsnStatsRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)

	switch bsnstatsrequest.Subtype {
	case 1:
		return decodeBsnLacpStatsRequest(bsnstatsrequest, decoder)
	case 2:
		return decodeBsnGentableEntryDescStatsRequest(bsnstatsrequest, decoder)
	case 3:
		return decodeBsnGentableEntryStatsRequest(bsnstatsrequest, decoder)
	case 4:
		return decodeBsnGentableDescStatsRequest(bsnstatsrequest, decoder)
	case 5:
		return decodeBsnGentableBucketStatsRequest(bsnstatsrequest, decoder)
	case 6:
		return decodeBsnSwitchPipelineStatsRequest(bsnstatsrequest, decoder)
	case 7:
		return decodeBsnGentableStatsRequest(bsnstatsrequest, decoder)
	case 8:
		return decodeBsnPortCounterStatsRequest(bsnstatsrequest, decoder)
	case 9:
		return decodeBsnVlanCounterStatsRequest(bsnstatsrequest, decoder)
	case 10:
		return decodeBsnFlowChecksumBucketStatsRequest(bsnstatsrequest, decoder)
	case 11:
		return decodeBsnTableChecksumStatsRequest(bsnstatsrequest, decoder)
	case 12:
		return decodeBsnDebugCounterStatsRequest(bsnstatsrequest, decoder)
	case 13:
		return decodeBsnDebugCounterDescStatsRequest(bsnstatsrequest, decoder)
	case 14:
		return decodeBsnImageDescStatsRequest(bsnstatsrequest, decoder)
	case 15:
		return decodeBsnVrfCounterStatsRequest(bsnstatsrequest, decoder)
	case 16:
		return decodeBsnGenericStatsRequest(bsnstatsrequest, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnStatsRequest'", bsnstatsrequest.Subtype)
	}
}

func NewBsnStatsRequest(_subtype uint32) *BsnStatsRequest {
	return &BsnStatsRequest{
		Subtype:                  _subtype,
		ExperimenterStatsRequest: NewExperimenterStatsRequest(6035143),
	}
}

type BsnDebugCounterDescStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnDebugCounterDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnDebugCounterDescStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnDebugCounterDescStatsRequest, error) {
	bsndebugcounterdescstatsrequest := &BsnDebugCounterDescStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnDebugCounterDescStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsndebugcounterdescstatsrequest, nil
}

func NewBsnDebugCounterDescStatsRequest() *BsnDebugCounterDescStatsRequest {
	return &BsnDebugCounterDescStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(13),
	}
}

type BsnDebugCounterStatsReply struct {
	*BsnStatsReply
	Entries []*BsnDebugCounterStatsEntry
}

func (self *BsnDebugCounterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnDebugCounterStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnDebugCounterStatsReply, error) {
	bsndebugcounterstatsreply := &BsnDebugCounterStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 16 {
		item, err := decodeBsnDebugCounterStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsndebugcounterstatsreply.Entries = append(bsndebugcounterstatsreply.Entries, item)
	}
	return bsndebugcounterstatsreply, nil
}

func NewBsnDebugCounterStatsReply() *BsnDebugCounterStatsReply {
	return &BsnDebugCounterStatsReply{
		BsnStatsReply: NewBsnStatsReply(12),
	}
}

type BsnDebugCounterStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnDebugCounterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnDebugCounterStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnDebugCounterStatsRequest, error) {
	bsndebugcounterstatsrequest := &BsnDebugCounterStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnDebugCounterStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsndebugcounterstatsrequest, nil
}

func NewBsnDebugCounterStatsRequest() *BsnDebugCounterStatsRequest {
	return &BsnDebugCounterStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(12),
	}
}

type BsnError struct {
	*BsnBaseError
}

func (self *BsnError) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnBaseError.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnError(parent *BsnBaseError, decoder *goloxi.Decoder) (*BsnError, error) {
	bsnerror := &BsnError{BsnBaseError: parent}
	return bsnerror, nil
}

func NewBsnError() *BsnError {
	return &BsnError{
		BsnBaseError: NewBsnBaseError(1),
	}
}

type BsnFlowChecksumBucketStatsReply struct {
	*BsnStatsReply
	Entries []*BsnFlowChecksumBucketStatsEntry
}

func (self *BsnFlowChecksumBucketStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowChecksumBucketStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnFlowChecksumBucketStatsReply, error) {
	bsnflowchecksumbucketstatsreply := &BsnFlowChecksumBucketStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeBsnFlowChecksumBucketStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnflowchecksumbucketstatsreply.Entries = append(bsnflowchecksumbucketstatsreply.Entries, item)
	}
	return bsnflowchecksumbucketstatsreply, nil
}

func NewBsnFlowChecksumBucketStatsReply() *BsnFlowChecksumBucketStatsReply {
	return &BsnFlowChecksumBucketStatsReply{
		BsnStatsReply: NewBsnStatsReply(10),
	}
}

type BsnFlowChecksumBucketStatsRequest struct {
	*BsnStatsRequest
	TableId uint8
}

func (self *BsnFlowChecksumBucketStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint8(uint8(self.TableId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowChecksumBucketStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnFlowChecksumBucketStatsRequest, error) {
	bsnflowchecksumbucketstatsrequest := &BsnFlowChecksumBucketStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnFlowChecksumBucketStatsRequest packet too short: %d < 1", decoder.Length())
	}
	decoder.Skip(4)
	bsnflowchecksumbucketstatsrequest.TableId = uint8(decoder.ReadByte())
	return bsnflowchecksumbucketstatsrequest, nil
}

func NewBsnFlowChecksumBucketStatsRequest() *BsnFlowChecksumBucketStatsRequest {
	return &BsnFlowChecksumBucketStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(10),
	}
}

type BsnFlowIdle struct {
	*BsnHeader
	Cookie   uint64
	Priority uint16
	TableId  uint8
	Match    Match
}

func (self *BsnFlowIdle) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 5))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowIdle(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnFlowIdle, error) {
	bsnflowidle := &BsnFlowIdle{BsnHeader: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnFlowIdle packet too short: %d < 24", decoder.Length())
	}
	bsnflowidle.Cookie = uint64(decoder.ReadUint64())
	bsnflowidle.Priority = uint16(decoder.ReadUint16())
	bsnflowidle.TableId = uint8(decoder.ReadByte())
	decoder.Skip(5)
	if err := bsnflowidle.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return bsnflowidle, nil
}

func NewBsnFlowIdle() *BsnFlowIdle {
	return &BsnFlowIdle{
		BsnHeader: NewBsnHeader(40),
	}
}

type BsnFlowIdleEnableGetReply struct {
	*BsnHeader
	Enabled uint32
}

func (self *BsnFlowIdleEnableGetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enabled))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowIdleEnableGetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnFlowIdleEnableGetReply, error) {
	bsnflowidleenablegetreply := &BsnFlowIdleEnableGetReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnFlowIdleEnableGetReply packet too short: %d < 4", decoder.Length())
	}
	bsnflowidleenablegetreply.Enabled = uint32(decoder.ReadUint32())
	return bsnflowidleenablegetreply, nil
}

func NewBsnFlowIdleEnableGetReply() *BsnFlowIdleEnableGetReply {
	return &BsnFlowIdleEnableGetReply{
		BsnHeader: NewBsnHeader(39),
	}
}

type BsnFlowIdleEnableGetRequest struct {
	*BsnHeader
}

func (self *BsnFlowIdleEnableGetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowIdleEnableGetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnFlowIdleEnableGetRequest, error) {
	bsnflowidleenablegetrequest := &BsnFlowIdleEnableGetRequest{BsnHeader: parent}
	return bsnflowidleenablegetrequest, nil
}

func NewBsnFlowIdleEnableGetRequest() *BsnFlowIdleEnableGetRequest {
	return &BsnFlowIdleEnableGetRequest{
		BsnHeader: NewBsnHeader(38),
	}
}

type BsnFlowIdleEnableSetReply struct {
	*BsnHeader
	Enable uint32
	Status uint32
}

func (self *BsnFlowIdleEnableSetReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))
	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowIdleEnableSetReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnFlowIdleEnableSetReply, error) {
	bsnflowidleenablesetreply := &BsnFlowIdleEnableSetReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnFlowIdleEnableSetReply packet too short: %d < 8", decoder.Length())
	}
	bsnflowidleenablesetreply.Enable = uint32(decoder.ReadUint32())
	bsnflowidleenablesetreply.Status = uint32(decoder.ReadUint32())
	return bsnflowidleenablesetreply, nil
}

func NewBsnFlowIdleEnableSetReply() *BsnFlowIdleEnableSetReply {
	return &BsnFlowIdleEnableSetReply{
		BsnHeader: NewBsnHeader(37),
	}
}

type BsnFlowIdleEnableSetRequest struct {
	*BsnHeader
	Enable uint32
}

func (self *BsnFlowIdleEnableSetRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Enable))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnFlowIdleEnableSetRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnFlowIdleEnableSetRequest, error) {
	bsnflowidleenablesetrequest := &BsnFlowIdleEnableSetRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnFlowIdleEnableSetRequest packet too short: %d < 4", decoder.Length())
	}
	bsnflowidleenablesetrequest.Enable = uint32(decoder.ReadUint32())
	return bsnflowidleenablesetrequest, nil
}

func NewBsnFlowIdleEnableSetRequest() *BsnFlowIdleEnableSetRequest {
	return &BsnFlowIdleEnableSetRequest{
		BsnHeader: NewBsnHeader(36),
	}
}

type BsnGenericAsync struct {
	*BsnHeader
	Name string
	Tlvs []IBsnTlv
}

func (self *BsnGenericAsync) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.Name))
	for _, obj := range self.Tlvs {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGenericAsync(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGenericAsync, error) {
	bsngenericasync := &BsnGenericAsync{BsnHeader: parent}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("BsnGenericAsync packet too short: %d < 64", decoder.Length())
	}
	bsngenericasync.Name = string(bytes.Trim(decoder.Read(64), "\x00"))

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngenericasync.Tlvs = append(bsngenericasync.Tlvs, item)
	}
	return bsngenericasync, nil
}

func NewBsnGenericAsync() *BsnGenericAsync {
	return &BsnGenericAsync{
		BsnHeader: NewBsnHeader(68),
	}
}

type BsnGenericCommand struct {
	*BsnHeader
	Name string
	Tlvs []IBsnTlv
}

func (self *BsnGenericCommand) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.Name))
	for _, obj := range self.Tlvs {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGenericCommand(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGenericCommand, error) {
	bsngenericcommand := &BsnGenericCommand{BsnHeader: parent}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("BsnGenericCommand packet too short: %d < 64", decoder.Length())
	}
	bsngenericcommand.Name = string(bytes.Trim(decoder.Read(64), "\x00"))

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngenericcommand.Tlvs = append(bsngenericcommand.Tlvs, item)
	}
	return bsngenericcommand, nil
}

func NewBsnGenericCommand() *BsnGenericCommand {
	return &BsnGenericCommand{
		BsnHeader: NewBsnHeader(71),
	}
}

type BsnGenericStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGenericStatsEntry
}

func (self *BsnGenericStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGenericStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGenericStatsReply, error) {
	bsngenericstatsreply := &BsnGenericStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 2 {
		item, err := decodeBsnGenericStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngenericstatsreply.Entries = append(bsngenericstatsreply.Entries, item)
	}
	return bsngenericstatsreply, nil
}

func NewBsnGenericStatsReply() *BsnGenericStatsReply {
	return &BsnGenericStatsReply{
		BsnStatsReply: NewBsnStatsReply(16),
	}
}

type BsnGenericStatsRequest struct {
	*BsnStatsRequest
	Name string
	Tlvs []IBsnTlv
}

func (self *BsnGenericStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write([]byte(self.Name))
	for _, obj := range self.Tlvs {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGenericStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGenericStatsRequest, error) {
	bsngenericstatsrequest := &BsnGenericStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("BsnGenericStatsRequest packet too short: %d < 64", decoder.Length())
	}
	decoder.Skip(4)
	bsngenericstatsrequest.Name = string(bytes.Trim(decoder.Read(64), "\x00"))

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngenericstatsrequest.Tlvs = append(bsngenericstatsrequest.Tlvs, item)
	}
	return bsngenericstatsrequest, nil
}

func NewBsnGenericStatsRequest() *BsnGenericStatsRequest {
	return &BsnGenericStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(16),
	}
}

type BsnGentableBucketStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGentableBucketStatsEntry
}

func (self *BsnGentableBucketStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableBucketStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGentableBucketStatsReply, error) {
	bsngentablebucketstatsreply := &BsnGentableBucketStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 16 {
		item, err := decodeBsnGentableBucketStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngentablebucketstatsreply.Entries = append(bsngentablebucketstatsreply.Entries, item)
	}
	return bsngentablebucketstatsreply, nil
}

func NewBsnGentableBucketStatsReply() *BsnGentableBucketStatsReply {
	return &BsnGentableBucketStatsReply{
		BsnStatsReply: NewBsnStatsReply(5),
	}
}

type BsnGentableBucketStatsRequest struct {
	*BsnStatsRequest
	TableId uint16
}

func (self *BsnGentableBucketStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.TableId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableBucketStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGentableBucketStatsRequest, error) {
	bsngentablebucketstatsrequest := &BsnGentableBucketStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnGentableBucketStatsRequest packet too short: %d < 2", decoder.Length())
	}
	decoder.Skip(4)
	bsngentablebucketstatsrequest.TableId = uint16(decoder.ReadUint16())
	return bsngentablebucketstatsrequest, nil
}

func NewBsnGentableBucketStatsRequest() *BsnGentableBucketStatsRequest {
	return &BsnGentableBucketStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(5),
	}
}

type BsnGentableClearReply struct {
	*BsnHeader
	TableId      uint16
	DeletedCount uint32
	ErrorCount   uint32
}

func (self *BsnGentableClearReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.DeletedCount))
	encoder.PutUint32(uint32(self.ErrorCount))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableClearReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGentableClearReply, error) {
	bsngentableclearreply := &BsnGentableClearReply{BsnHeader: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("BsnGentableClearReply packet too short: %d < 12", decoder.Length())
	}
	bsngentableclearreply.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentableclearreply.DeletedCount = uint32(decoder.ReadUint32())
	bsngentableclearreply.ErrorCount = uint32(decoder.ReadUint32())
	return bsngentableclearreply, nil
}

func NewBsnGentableClearReply() *BsnGentableClearReply {
	return &BsnGentableClearReply{
		BsnHeader: NewBsnHeader(49),
	}
}

type BsnGentableClearRequest struct {
	*BsnHeader
	TableId      uint16
	Checksum     Checksum128
	ChecksumMask Checksum128
}

func (self *BsnGentableClearRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.Checksum.Serialize(encoder)
	self.ChecksumMask.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableClearRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGentableClearRequest, error) {
	bsngentableclearrequest := &BsnGentableClearRequest{BsnHeader: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnGentableClearRequest packet too short: %d < 36", decoder.Length())
	}
	bsngentableclearrequest.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentableclearrequest.Checksum.Decode(decoder)
	bsngentableclearrequest.ChecksumMask.Decode(decoder)
	return bsngentableclearrequest, nil
}

func NewBsnGentableClearRequest() *BsnGentableClearRequest {
	return &BsnGentableClearRequest{
		BsnHeader: NewBsnHeader(48),
	}
}

type BsnGentableDescStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGentableDescStatsEntry
}

func (self *BsnGentableDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableDescStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGentableDescStatsReply, error) {
	bsngentabledescstatsreply := &BsnGentableDescStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 48 {
		item, err := decodeBsnGentableDescStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngentabledescstatsreply.Entries = append(bsngentabledescstatsreply.Entries, item)
	}
	return bsngentabledescstatsreply, nil
}

func NewBsnGentableDescStatsReply() *BsnGentableDescStatsReply {
	return &BsnGentableDescStatsReply{
		BsnStatsReply: NewBsnStatsReply(4),
	}
}

type BsnGentableDescStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnGentableDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableDescStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGentableDescStatsRequest, error) {
	bsngentabledescstatsrequest := &BsnGentableDescStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnGentableDescStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsngentabledescstatsrequest, nil
}

func NewBsnGentableDescStatsRequest() *BsnGentableDescStatsRequest {
	return &BsnGentableDescStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(4),
	}
}

type BsnGentableEntryAdd struct {
	*BsnHeader
	TableId   uint16
	KeyLength uint16
	Checksum  Checksum128
	Key       []IBsnTlv
	Value     []IBsnTlv
}

func (self *BsnGentableEntryAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	encoder.PutUint16(uint16(self.KeyLength))
	self.Checksum.Serialize(encoder)
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryAdd(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGentableEntryAdd, error) {
	bsngentableentryadd := &BsnGentableEntryAdd{BsnHeader: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("BsnGentableEntryAdd packet too short: %d < 20", decoder.Length())
	}
	bsngentableentryadd.TableId = uint16(decoder.ReadUint16())
	bsngentableentryadd.KeyLength = uint16(decoder.ReadUint16())
	bsngentableentryadd.Checksum.Decode(decoder)

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentryadd.Key = append(bsngentableentryadd.Key, item)
	}

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentryadd.Value = append(bsngentableentryadd.Value, item)
	}
	return bsngentableentryadd, nil
}

func NewBsnGentableEntryAdd() *BsnGentableEntryAdd {
	return &BsnGentableEntryAdd{
		BsnHeader: NewBsnHeader(46),
	}
}

type BsnGentableEntryDelete struct {
	*BsnHeader
	TableId uint16
	Key     []IBsnTlv
}

func (self *BsnGentableEntryDelete) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryDelete(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGentableEntryDelete, error) {
	bsngentableentrydelete := &BsnGentableEntryDelete{BsnHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnGentableEntryDelete packet too short: %d < 2", decoder.Length())
	}
	bsngentableentrydelete.TableId = uint16(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrydelete.Key = append(bsngentableentrydelete.Key, item)
	}
	return bsngentableentrydelete, nil
}

func NewBsnGentableEntryDelete() *BsnGentableEntryDelete {
	return &BsnGentableEntryDelete{
		BsnHeader: NewBsnHeader(47),
	}
}

type BsnGentableEntryDescStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGentableEntryDescStatsEntry
}

func (self *BsnGentableEntryDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryDescStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGentableEntryDescStatsReply, error) {
	bsngentableentrydescstatsreply := &BsnGentableEntryDescStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 20 {
		item, err := decodeBsnGentableEntryDescStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrydescstatsreply.Entries = append(bsngentableentrydescstatsreply.Entries, item)
	}
	return bsngentableentrydescstatsreply, nil
}

func NewBsnGentableEntryDescStatsReply() *BsnGentableEntryDescStatsReply {
	return &BsnGentableEntryDescStatsReply{
		BsnStatsReply: NewBsnStatsReply(2),
	}
}

type BsnGentableEntryDescStatsRequest struct {
	*BsnStatsRequest
	TableId      uint16
	Checksum     Checksum128
	ChecksumMask Checksum128
}

func (self *BsnGentableEntryDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.Checksum.Serialize(encoder)
	self.ChecksumMask.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryDescStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGentableEntryDescStatsRequest, error) {
	bsngentableentrydescstatsrequest := &BsnGentableEntryDescStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnGentableEntryDescStatsRequest packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	bsngentableentrydescstatsrequest.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentableentrydescstatsrequest.Checksum.Decode(decoder)
	bsngentableentrydescstatsrequest.ChecksumMask.Decode(decoder)
	return bsngentableentrydescstatsrequest, nil
}

func NewBsnGentableEntryDescStatsRequest() *BsnGentableEntryDescStatsRequest {
	return &BsnGentableEntryDescStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(2),
	}
}

type BsnGentableEntryStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGentableEntryStatsEntry
}

func (self *BsnGentableEntryStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGentableEntryStatsReply, error) {
	bsngentableentrystatsreply := &BsnGentableEntryStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 4 {
		item, err := decodeBsnGentableEntryStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrystatsreply.Entries = append(bsngentableentrystatsreply.Entries, item)
	}
	return bsngentableentrystatsreply, nil
}

func NewBsnGentableEntryStatsReply() *BsnGentableEntryStatsReply {
	return &BsnGentableEntryStatsReply{
		BsnStatsReply: NewBsnStatsReply(3),
	}
}

type BsnGentableEntryStatsRequest struct {
	*BsnStatsRequest
	TableId      uint16
	Checksum     Checksum128
	ChecksumMask Checksum128
}

func (self *BsnGentableEntryStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.Checksum.Serialize(encoder)
	self.ChecksumMask.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGentableEntryStatsRequest, error) {
	bsngentableentrystatsrequest := &BsnGentableEntryStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnGentableEntryStatsRequest packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	bsngentableentrystatsrequest.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentableentrystatsrequest.Checksum.Decode(decoder)
	bsngentableentrystatsrequest.ChecksumMask.Decode(decoder)
	return bsngentableentrystatsrequest, nil
}

func NewBsnGentableEntryStatsRequest() *BsnGentableEntryStatsRequest {
	return &BsnGentableEntryStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(3),
	}
}

type BsnGentableError struct {
	*BsnBaseError
	ErrorCode BsnGentableErrorCode
	TableId   uint16
}

func (self *BsnGentableError) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnBaseError.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.ErrorCode))
	encoder.PutUint16(uint16(self.TableId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableError(parent *BsnBaseError, decoder *goloxi.Decoder) (*BsnGentableError, error) {
	bsngentableerror := &BsnGentableError{BsnBaseError: parent}
	if decoder.Length() < 260 {
		return nil, fmt.Errorf("BsnGentableError packet too short: %d < 260", decoder.Length())
	}
	bsngentableerror.ErrorCode = BsnGentableErrorCode(decoder.ReadUint16())
	bsngentableerror.TableId = uint16(decoder.ReadUint16())
	return bsngentableerror, nil
}

func NewBsnGentableError() *BsnGentableError {
	return &BsnGentableError{
		BsnBaseError: NewBsnBaseError(2),
	}
}

type BsnGentableSetBucketsSize struct {
	*BsnHeader
	TableId     uint16
	BucketsSize uint32
}

func (self *BsnGentableSetBucketsSize) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.BucketsSize))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableSetBucketsSize(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGentableSetBucketsSize, error) {
	bsngentablesetbucketssize := &BsnGentableSetBucketsSize{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnGentableSetBucketsSize packet too short: %d < 8", decoder.Length())
	}
	bsngentablesetbucketssize.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentablesetbucketssize.BucketsSize = uint32(decoder.ReadUint32())
	return bsngentablesetbucketssize, nil
}

func NewBsnGentableSetBucketsSize() *BsnGentableSetBucketsSize {
	return &BsnGentableSetBucketsSize{
		BsnHeader: NewBsnHeader(50),
	}
}

type BsnGentableStatsReply struct {
	*BsnStatsReply
	Entries []*BsnGentableStatsEntry
}

func (self *BsnGentableStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnGentableStatsReply, error) {
	bsngentablestatsreply := &BsnGentableStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 24 {
		item, err := decodeBsnGentableStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsngentablestatsreply.Entries = append(bsngentablestatsreply.Entries, item)
	}
	return bsngentablestatsreply, nil
}

func NewBsnGentableStatsReply() *BsnGentableStatsReply {
	return &BsnGentableStatsReply{
		BsnStatsReply: NewBsnStatsReply(7),
	}
}

type BsnGentableStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnGentableStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnGentableStatsRequest, error) {
	bsngentablestatsrequest := &BsnGentableStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnGentableStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsngentablestatsrequest, nil
}

func NewBsnGentableStatsRequest() *BsnGentableStatsRequest {
	return &BsnGentableStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(7),
	}
}

type BsnGetInterfacesReply struct {
	*BsnHeader
	Interfaces []*BsnInterface
}

func (self *BsnGetInterfacesReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Interfaces {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetInterfacesReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetInterfacesReply, error) {
	bsngetinterfacesreply := &BsnGetInterfacesReply{BsnHeader: parent}

	for decoder.Length() >= 32 {
		item, err := decodeBsnInterface(decoder)
		if err != nil {
			return nil, err
		}
		bsngetinterfacesreply.Interfaces = append(bsngetinterfacesreply.Interfaces, item)
	}
	return bsngetinterfacesreply, nil
}

func NewBsnGetInterfacesReply() *BsnGetInterfacesReply {
	return &BsnGetInterfacesReply{
		BsnHeader: NewBsnHeader(10),
	}
}

type BsnGetInterfacesRequest struct {
	*BsnHeader
}

func (self *BsnGetInterfacesRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetInterfacesRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetInterfacesRequest, error) {
	bsngetinterfacesrequest := &BsnGetInterfacesRequest{BsnHeader: parent}
	return bsngetinterfacesrequest, nil
}

func NewBsnGetInterfacesRequest() *BsnGetInterfacesRequest {
	return &BsnGetInterfacesRequest{
		BsnHeader: NewBsnHeader(9),
	}
}

type BsnGetMirroringReply struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnGetMirroringReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetMirroringReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetMirroringReply, error) {
	bsngetmirroringreply := &BsnGetMirroringReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGetMirroringReply packet too short: %d < 4", decoder.Length())
	}
	bsngetmirroringreply.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsngetmirroringreply, nil
}

func NewBsnGetMirroringReply() *BsnGetMirroringReply {
	return &BsnGetMirroringReply{
		BsnHeader: NewBsnHeader(5),
	}
}

type BsnGetMirroringRequest struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnGetMirroringRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetMirroringRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetMirroringRequest, error) {
	bsngetmirroringrequest := &BsnGetMirroringRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGetMirroringRequest packet too short: %d < 4", decoder.Length())
	}
	bsngetmirroringrequest.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsngetmirroringrequest, nil
}

func NewBsnGetMirroringRequest() *BsnGetMirroringRequest {
	return &BsnGetMirroringRequest{
		BsnHeader: NewBsnHeader(4),
	}
}

type BsnGetSwitchPipelineReply struct {
	*BsnHeader
	Pipeline string
}

func (self *BsnGetSwitchPipelineReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.Pipeline))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetSwitchPipelineReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetSwitchPipelineReply, error) {
	bsngetswitchpipelinereply := &BsnGetSwitchPipelineReply{BsnHeader: parent}
	if decoder.Length() < 256 {
		return nil, fmt.Errorf("BsnGetSwitchPipelineReply packet too short: %d < 256", decoder.Length())
	}
	bsngetswitchpipelinereply.Pipeline = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsngetswitchpipelinereply, nil
}

func NewBsnGetSwitchPipelineReply() *BsnGetSwitchPipelineReply {
	return &BsnGetSwitchPipelineReply{
		BsnHeader: NewBsnHeader(52),
	}
}

type BsnGetSwitchPipelineRequest struct {
	*BsnHeader
}

func (self *BsnGetSwitchPipelineRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGetSwitchPipelineRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnGetSwitchPipelineRequest, error) {
	bsngetswitchpipelinerequest := &BsnGetSwitchPipelineRequest{BsnHeader: parent}
	return bsngetswitchpipelinerequest, nil
}

func NewBsnGetSwitchPipelineRequest() *BsnGetSwitchPipelineRequest {
	return &BsnGetSwitchPipelineRequest{
		BsnHeader: NewBsnHeader(51),
	}
}

type BsnImageDescStatsReply struct {
	*BsnStatsReply
	ImageChecksum         string
	StartupConfigChecksum string
}

func (self *BsnImageDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write([]byte(self.ImageChecksum))
	encoder.Write([]byte(self.StartupConfigChecksum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnImageDescStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnImageDescStatsReply, error) {
	bsnimagedescstatsreply := &BsnImageDescStatsReply{BsnStatsReply: parent}
	if decoder.Length() < 512 {
		return nil, fmt.Errorf("BsnImageDescStatsReply packet too short: %d < 512", decoder.Length())
	}
	decoder.Skip(4)
	bsnimagedescstatsreply.ImageChecksum = string(bytes.Trim(decoder.Read(256), "\x00"))
	bsnimagedescstatsreply.StartupConfigChecksum = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsnimagedescstatsreply, nil
}

func NewBsnImageDescStatsReply() *BsnImageDescStatsReply {
	return &BsnImageDescStatsReply{
		BsnStatsReply: NewBsnStatsReply(14),
	}
}

type BsnImageDescStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnImageDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnImageDescStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnImageDescStatsRequest, error) {
	bsnimagedescstatsrequest := &BsnImageDescStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnImageDescStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsnimagedescstatsrequest, nil
}

func NewBsnImageDescStatsRequest() *BsnImageDescStatsRequest {
	return &BsnImageDescStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(14),
	}
}

type BsnLacpConvergenceNotif struct {
	*BsnHeader
	ConvergenceStatus   uint8
	PortNo              PortNo
	ActorSysPriority    uint16
	ActorSysMac         net.HardwareAddr
	ActorPortPriority   uint16
	ActorPortNum        uint16
	ActorKey            uint16
	PartnerSysPriority  uint16
	PartnerSysMac       net.HardwareAddr
	PartnerPortPriority uint16
	PartnerPortNum      uint16
	PartnerKey          uint16
}

func (self *BsnLacpConvergenceNotif) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ConvergenceStatus))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActorSysPriority))
	encoder.Write(self.ActorSysMac)
	encoder.PutUint16(uint16(self.ActorPortPriority))
	encoder.PutUint16(uint16(self.ActorPortNum))
	encoder.PutUint16(uint16(self.ActorKey))
	encoder.PutUint16(uint16(self.PartnerSysPriority))
	encoder.Write(self.PartnerSysMac)
	encoder.PutUint16(uint16(self.PartnerPortPriority))
	encoder.PutUint16(uint16(self.PartnerPortNum))
	encoder.PutUint16(uint16(self.PartnerKey))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLacpConvergenceNotif(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLacpConvergenceNotif, error) {
	bsnlacpconvergencenotif := &BsnLacpConvergenceNotif{BsnHeader: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnLacpConvergenceNotif packet too short: %d < 36", decoder.Length())
	}
	bsnlacpconvergencenotif.ConvergenceStatus = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnlacpconvergencenotif.PortNo.Decode(decoder)
	bsnlacpconvergencenotif.ActorSysPriority = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.ActorSysMac = net.HardwareAddr(decoder.Read(6))
	bsnlacpconvergencenotif.ActorPortPriority = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.ActorPortNum = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.ActorKey = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.PartnerSysPriority = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.PartnerSysMac = net.HardwareAddr(decoder.Read(6))
	bsnlacpconvergencenotif.PartnerPortPriority = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.PartnerPortNum = uint16(decoder.ReadUint16())
	bsnlacpconvergencenotif.PartnerKey = uint16(decoder.ReadUint16())
	return bsnlacpconvergencenotif, nil
}

func NewBsnLacpConvergenceNotif() *BsnLacpConvergenceNotif {
	return &BsnLacpConvergenceNotif{
		BsnHeader: NewBsnHeader(43),
	}
}

type BsnLacpStatsReply struct {
	*BsnStatsReply
	Entries []*BsnLacpStatsEntry
}

func (self *BsnLacpStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLacpStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnLacpStatsReply, error) {
	bsnlacpstatsreply := &BsnLacpStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 36 {
		item, err := decodeBsnLacpStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnlacpstatsreply.Entries = append(bsnlacpstatsreply.Entries, item)
	}
	return bsnlacpstatsreply, nil
}

func NewBsnLacpStatsReply() *BsnLacpStatsReply {
	return &BsnLacpStatsReply{
		BsnStatsReply: NewBsnStatsReply(1),
	}
}

type BsnLacpStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnLacpStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLacpStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnLacpStatsRequest, error) {
	bsnlacpstatsrequest := &BsnLacpStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnLacpStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsnlacpstatsrequest, nil
}

func NewBsnLacpStatsRequest() *BsnLacpStatsRequest {
	return &BsnLacpStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(1),
	}
}

type BsnLog struct {
	*BsnHeader
	Loglevel BsnLoglevel
	Data     []byte
}

func (self *BsnLog) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Loglevel))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLog(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLog, error) {
	bsnlog := &BsnLog{BsnHeader: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnLog packet too short: %d < 1", decoder.Length())
	}
	bsnlog.Loglevel = BsnLoglevel(decoder.ReadByte())
	bsnlog.Data = decoder.Read(decoder.Length())
	return bsnlog, nil
}

func NewBsnLog() *BsnLog {
	return &BsnLog{
		BsnHeader: NewBsnHeader(63),
	}
}

type BsnLuaCommandReply struct {
	*BsnHeader
	Data []byte
}

func (self *BsnLuaCommandReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLuaCommandReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLuaCommandReply, error) {
	bsnluacommandreply := &BsnLuaCommandReply{BsnHeader: parent}
	bsnluacommandreply.Data = decoder.Read(decoder.Length())
	return bsnluacommandreply, nil
}

func NewBsnLuaCommandReply() *BsnLuaCommandReply {
	return &BsnLuaCommandReply{
		BsnHeader: NewBsnHeader(66),
	}
}

type BsnLuaCommandRequest struct {
	*BsnHeader
	Data []byte
}

func (self *BsnLuaCommandRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLuaCommandRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLuaCommandRequest, error) {
	bsnluacommandrequest := &BsnLuaCommandRequest{BsnHeader: parent}
	bsnluacommandrequest.Data = decoder.Read(decoder.Length())
	return bsnluacommandrequest, nil
}

func NewBsnLuaCommandRequest() *BsnLuaCommandRequest {
	return &BsnLuaCommandRequest{
		BsnHeader: NewBsnHeader(65),
	}
}

type BsnLuaNotification struct {
	*BsnHeader
	Data []byte
}

func (self *BsnLuaNotification) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLuaNotification(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLuaNotification, error) {
	bsnluanotification := &BsnLuaNotification{BsnHeader: parent}
	bsnluanotification.Data = decoder.Read(decoder.Length())
	return bsnluanotification, nil
}

func NewBsnLuaNotification() *BsnLuaNotification {
	return &BsnLuaNotification{
		BsnHeader: NewBsnHeader(67),
	}
}

type BsnLuaUpload struct {
	*BsnHeader
	Flags    BsnLuaUploadFlags
	Filename string
	Data     []byte
}

func (self *BsnLuaUpload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))
	encoder.Write([]byte(self.Filename))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnLuaUpload(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnLuaUpload, error) {
	bsnluaupload := &BsnLuaUpload{BsnHeader: parent}
	if decoder.Length() < 66 {
		return nil, fmt.Errorf("BsnLuaUpload packet too short: %d < 66", decoder.Length())
	}
	bsnluaupload.Flags = BsnLuaUploadFlags(decoder.ReadUint16())
	bsnluaupload.Filename = string(bytes.Trim(decoder.Read(64), "\x00"))
	bsnluaupload.Data = decoder.Read(decoder.Length())
	return bsnluaupload, nil
}

func NewBsnLuaUpload() *BsnLuaUpload {
	return &BsnLuaUpload{
		BsnHeader: NewBsnHeader(64),
	}
}

type BsnPduRxReply struct {
	*BsnHeader
	Status  uint32
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduRxReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxReply, error) {
	bsnpdurxreply := &BsnPduRxReply{BsnHeader: parent}
	if decoder.Length() < 9 {
		return nil, fmt.Errorf("BsnPduRxReply packet too short: %d < 9", decoder.Length())
	}
	bsnpdurxreply.Status = uint32(decoder.ReadUint32())
	bsnpdurxreply.PortNo.Decode(decoder)
	bsnpdurxreply.SlotNum = uint8(decoder.ReadByte())
	return bsnpdurxreply, nil
}

func NewBsnPduRxReply() *BsnPduRxReply {
	return &BsnPduRxReply{
		BsnHeader: NewBsnHeader(34),
	}
}

type BsnPduRxRequest struct {
	*BsnHeader
	TimeoutMs uint32
	PortNo    PortNo
	SlotNum   uint8
	Data      []byte
}

func (self *BsnPduRxRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.TimeoutMs))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxRequest, error) {
	bsnpdurxrequest := &BsnPduRxRequest{BsnHeader: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("BsnPduRxRequest packet too short: %d < 12", decoder.Length())
	}
	bsnpdurxrequest.TimeoutMs = uint32(decoder.ReadUint32())
	bsnpdurxrequest.PortNo.Decode(decoder)
	bsnpdurxrequest.SlotNum = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnpdurxrequest.Data = decoder.Read(decoder.Length())
	return bsnpdurxrequest, nil
}

func NewBsnPduRxRequest() *BsnPduRxRequest {
	return &BsnPduRxRequest{
		BsnHeader: NewBsnHeader(33),
	}
}

type BsnPduRxTimeout struct {
	*BsnHeader
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduRxTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduRxTimeout(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduRxTimeout, error) {
	bsnpdurxtimeout := &BsnPduRxTimeout{BsnHeader: parent}
	if decoder.Length() < 5 {
		return nil, fmt.Errorf("BsnPduRxTimeout packet too short: %d < 5", decoder.Length())
	}
	bsnpdurxtimeout.PortNo.Decode(decoder)
	bsnpdurxtimeout.SlotNum = uint8(decoder.ReadByte())
	return bsnpdurxtimeout, nil
}

func NewBsnPduRxTimeout() *BsnPduRxTimeout {
	return &BsnPduRxTimeout{
		BsnHeader: NewBsnHeader(35),
	}
}

type BsnPduTxReply struct {
	*BsnHeader
	Status  uint32
	PortNo  PortNo
	SlotNum uint8
}

func (self *BsnPduTxReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduTxReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduTxReply, error) {
	bsnpdutxreply := &BsnPduTxReply{BsnHeader: parent}
	if decoder.Length() < 9 {
		return nil, fmt.Errorf("BsnPduTxReply packet too short: %d < 9", decoder.Length())
	}
	bsnpdutxreply.Status = uint32(decoder.ReadUint32())
	bsnpdutxreply.PortNo.Decode(decoder)
	bsnpdutxreply.SlotNum = uint8(decoder.ReadByte())
	return bsnpdutxreply, nil
}

func NewBsnPduTxReply() *BsnPduTxReply {
	return &BsnPduTxReply{
		BsnHeader: NewBsnHeader(32),
	}
}

type BsnPduTxRequest struct {
	*BsnHeader
	TxIntervalMs uint32
	PortNo       PortNo
	SlotNum      uint8
	Data         []byte
}

func (self *BsnPduTxRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.TxIntervalMs))
	self.PortNo.Serialize(encoder)
	encoder.PutUint8(uint8(self.SlotNum))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPduTxRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnPduTxRequest, error) {
	bsnpdutxrequest := &BsnPduTxRequest{BsnHeader: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("BsnPduTxRequest packet too short: %d < 12", decoder.Length())
	}
	bsnpdutxrequest.TxIntervalMs = uint32(decoder.ReadUint32())
	bsnpdutxrequest.PortNo.Decode(decoder)
	bsnpdutxrequest.SlotNum = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnpdutxrequest.Data = decoder.Read(decoder.Length())
	return bsnpdutxrequest, nil
}

func NewBsnPduTxRequest() *BsnPduTxRequest {
	return &BsnPduTxRequest{
		BsnHeader: NewBsnHeader(31),
	}
}

type BsnPortCounterStatsReply struct {
	*BsnStatsReply
	Entries []*BsnPortCounterStatsEntry
}

func (self *BsnPortCounterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPortCounterStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnPortCounterStatsReply, error) {
	bsnportcounterstatsreply := &BsnPortCounterStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeBsnPortCounterStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnportcounterstatsreply.Entries = append(bsnportcounterstatsreply.Entries, item)
	}
	return bsnportcounterstatsreply, nil
}

func NewBsnPortCounterStatsReply() *BsnPortCounterStatsReply {
	return &BsnPortCounterStatsReply{
		BsnStatsReply: NewBsnStatsReply(8),
	}
}

type BsnPortCounterStatsRequest struct {
	*BsnStatsRequest
	PortNo PortNo
}

func (self *BsnPortCounterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.PortNo.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPortCounterStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnPortCounterStatsRequest, error) {
	bsnportcounterstatsrequest := &BsnPortCounterStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnPortCounterStatsRequest packet too short: %d < 4", decoder.Length())
	}
	decoder.Skip(4)
	bsnportcounterstatsrequest.PortNo.Decode(decoder)
	return bsnportcounterstatsrequest, nil
}

func NewBsnPortCounterStatsRequest() *BsnPortCounterStatsRequest {
	return &BsnPortCounterStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(8),
	}
}

type BsnSetAuxCxnsReply struct {
	*BsnHeader
	NumAux uint32
	Status uint32
}

func (self *BsnSetAuxCxnsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.NumAux))
	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetAuxCxnsReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetAuxCxnsReply, error) {
	bsnsetauxcxnsreply := &BsnSetAuxCxnsReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnSetAuxCxnsReply packet too short: %d < 8", decoder.Length())
	}
	bsnsetauxcxnsreply.NumAux = uint32(decoder.ReadUint32())
	bsnsetauxcxnsreply.Status = uint32(decoder.ReadUint32())
	return bsnsetauxcxnsreply, nil
}

func NewBsnSetAuxCxnsReply() *BsnSetAuxCxnsReply {
	return &BsnSetAuxCxnsReply{
		BsnHeader: NewBsnHeader(59),
	}
}

type BsnSetAuxCxnsRequest struct {
	*BsnHeader
	NumAux uint32
}

func (self *BsnSetAuxCxnsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.NumAux))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetAuxCxnsRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetAuxCxnsRequest, error) {
	bsnsetauxcxnsrequest := &BsnSetAuxCxnsRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetAuxCxnsRequest packet too short: %d < 4", decoder.Length())
	}
	bsnsetauxcxnsrequest.NumAux = uint32(decoder.ReadUint32())
	return bsnsetauxcxnsrequest, nil
}

func NewBsnSetAuxCxnsRequest() *BsnSetAuxCxnsRequest {
	return &BsnSetAuxCxnsRequest{
		BsnHeader: NewBsnHeader(58),
	}
}

type BsnSetLacpReply struct {
	*BsnHeader
	Status uint32
	PortNo PortNo
}

func (self *BsnSetLacpReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	self.PortNo.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetLacpReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetLacpReply, error) {
	bsnsetlacpreply := &BsnSetLacpReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnSetLacpReply packet too short: %d < 8", decoder.Length())
	}
	bsnsetlacpreply.Status = uint32(decoder.ReadUint32())
	bsnsetlacpreply.PortNo.Decode(decoder)
	return bsnsetlacpreply, nil
}

func NewBsnSetLacpReply() *BsnSetLacpReply {
	return &BsnSetLacpReply{
		BsnHeader: NewBsnHeader(42),
	}
}

type BsnSetLacpRequest struct {
	*BsnHeader
	Enabled           uint8
	PortNo            PortNo
	ActorSysPriority  uint16
	ActorSysMac       net.HardwareAddr
	ActorPortPriority uint16
	ActorPortNum      uint16
	ActorKey          uint16
}

func (self *BsnSetLacpRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Enabled))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActorSysPriority))
	encoder.Write(self.ActorSysMac)
	encoder.PutUint16(uint16(self.ActorPortPriority))
	encoder.PutUint16(uint16(self.ActorPortNum))
	encoder.PutUint16(uint16(self.ActorKey))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetLacpRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetLacpRequest, error) {
	bsnsetlacprequest := &BsnSetLacpRequest{BsnHeader: parent}
	if decoder.Length() < 22 {
		return nil, fmt.Errorf("BsnSetLacpRequest packet too short: %d < 22", decoder.Length())
	}
	bsnsetlacprequest.Enabled = uint8(decoder.ReadByte())
	decoder.Skip(3)
	bsnsetlacprequest.PortNo.Decode(decoder)
	bsnsetlacprequest.ActorSysPriority = uint16(decoder.ReadUint16())
	bsnsetlacprequest.ActorSysMac = net.HardwareAddr(decoder.Read(6))
	bsnsetlacprequest.ActorPortPriority = uint16(decoder.ReadUint16())
	bsnsetlacprequest.ActorPortNum = uint16(decoder.ReadUint16())
	bsnsetlacprequest.ActorKey = uint16(decoder.ReadUint16())
	return bsnsetlacprequest, nil
}

func NewBsnSetLacpRequest() *BsnSetLacpRequest {
	return &BsnSetLacpRequest{
		BsnHeader: NewBsnHeader(41),
	}
}

type BsnSetMirroring struct {
	*BsnHeader
	ReportMirrorPorts uint8
}

func (self *BsnSetMirroring) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.ReportMirrorPorts))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetMirroring(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetMirroring, error) {
	bsnsetmirroring := &BsnSetMirroring{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetMirroring packet too short: %d < 4", decoder.Length())
	}
	bsnsetmirroring.ReportMirrorPorts = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return bsnsetmirroring, nil
}

func NewBsnSetMirroring() *BsnSetMirroring {
	return &BsnSetMirroring{
		BsnHeader: NewBsnHeader(3),
	}
}

type BsnSetPktinSuppressionReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnSetPktinSuppressionReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetPktinSuppressionReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetPktinSuppressionReply, error) {
	bsnsetpktinsuppressionreply := &BsnSetPktinSuppressionReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetPktinSuppressionReply packet too short: %d < 4", decoder.Length())
	}
	bsnsetpktinsuppressionreply.Status = uint32(decoder.ReadUint32())
	return bsnsetpktinsuppressionreply, nil
}

func NewBsnSetPktinSuppressionReply() *BsnSetPktinSuppressionReply {
	return &BsnSetPktinSuppressionReply{
		BsnHeader: NewBsnHeader(25),
	}
}

type BsnSetPktinSuppressionRequest struct {
	*BsnHeader
	Enabled     uint8
	IdleTimeout uint16
	HardTimeout uint16
	Priority    uint16
	Cookie      uint64
}

func (self *BsnSetPktinSuppressionRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Enabled))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint64(uint64(self.Cookie))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetPktinSuppressionRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetPktinSuppressionRequest, error) {
	bsnsetpktinsuppressionrequest := &BsnSetPktinSuppressionRequest{BsnHeader: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnSetPktinSuppressionRequest packet too short: %d < 16", decoder.Length())
	}
	bsnsetpktinsuppressionrequest.Enabled = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnsetpktinsuppressionrequest.IdleTimeout = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.HardTimeout = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.Priority = uint16(decoder.ReadUint16())
	bsnsetpktinsuppressionrequest.Cookie = uint64(decoder.ReadUint64())
	return bsnsetpktinsuppressionrequest, nil
}

func NewBsnSetPktinSuppressionRequest() *BsnSetPktinSuppressionRequest {
	return &BsnSetPktinSuppressionRequest{
		BsnHeader: NewBsnHeader(11),
	}
}

type BsnSetSwitchPipelineReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnSetSwitchPipelineReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetSwitchPipelineReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetSwitchPipelineReply, error) {
	bsnsetswitchpipelinereply := &BsnSetSwitchPipelineReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnSetSwitchPipelineReply packet too short: %d < 4", decoder.Length())
	}
	bsnsetswitchpipelinereply.Status = uint32(decoder.ReadUint32())
	return bsnsetswitchpipelinereply, nil
}

func NewBsnSetSwitchPipelineReply() *BsnSetSwitchPipelineReply {
	return &BsnSetSwitchPipelineReply{
		BsnHeader: NewBsnHeader(54),
	}
}

type BsnSetSwitchPipelineRequest struct {
	*BsnHeader
	Pipeline string
}

func (self *BsnSetSwitchPipelineRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write([]byte(self.Pipeline))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSetSwitchPipelineRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnSetSwitchPipelineRequest, error) {
	bsnsetswitchpipelinerequest := &BsnSetSwitchPipelineRequest{BsnHeader: parent}
	if decoder.Length() < 256 {
		return nil, fmt.Errorf("BsnSetSwitchPipelineRequest packet too short: %d < 256", decoder.Length())
	}
	bsnsetswitchpipelinerequest.Pipeline = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsnsetswitchpipelinerequest, nil
}

func NewBsnSetSwitchPipelineRequest() *BsnSetSwitchPipelineRequest {
	return &BsnSetSwitchPipelineRequest{
		BsnHeader: NewBsnHeader(53),
	}
}

type BsnSwitchPipelineStatsReply struct {
	*BsnStatsReply
	Entries []*BsnSwitchPipelineStatsEntry
}

func (self *BsnSwitchPipelineStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSwitchPipelineStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnSwitchPipelineStatsReply, error) {
	bsnswitchpipelinestatsreply := &BsnSwitchPipelineStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 256 {
		item, err := decodeBsnSwitchPipelineStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnswitchpipelinestatsreply.Entries = append(bsnswitchpipelinestatsreply.Entries, item)
	}
	return bsnswitchpipelinestatsreply, nil
}

func NewBsnSwitchPipelineStatsReply() *BsnSwitchPipelineStatsReply {
	return &BsnSwitchPipelineStatsReply{
		BsnStatsReply: NewBsnStatsReply(6),
	}
}

type BsnSwitchPipelineStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnSwitchPipelineStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnSwitchPipelineStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnSwitchPipelineStatsRequest, error) {
	bsnswitchpipelinestatsrequest := &BsnSwitchPipelineStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnSwitchPipelineStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsnswitchpipelinestatsrequest, nil
}

func NewBsnSwitchPipelineStatsRequest() *BsnSwitchPipelineStatsRequest {
	return &BsnSwitchPipelineStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(6),
	}
}

type BsnTableChecksumStatsReply struct {
	*BsnStatsReply
	Entries []*BsnTableChecksumStatsEntry
}

func (self *BsnTableChecksumStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTableChecksumStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnTableChecksumStatsReply, error) {
	bsntablechecksumstatsreply := &BsnTableChecksumStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 9 {
		item, err := decodeBsnTableChecksumStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsntablechecksumstatsreply.Entries = append(bsntablechecksumstatsreply.Entries, item)
	}
	return bsntablechecksumstatsreply, nil
}

func NewBsnTableChecksumStatsReply() *BsnTableChecksumStatsReply {
	return &BsnTableChecksumStatsReply{
		BsnStatsReply: NewBsnStatsReply(11),
	}
}

type BsnTableChecksumStatsRequest struct {
	*BsnStatsRequest
}

func (self *BsnTableChecksumStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTableChecksumStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnTableChecksumStatsRequest, error) {
	bsntablechecksumstatsrequest := &BsnTableChecksumStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnTableChecksumStatsRequest packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	return bsntablechecksumstatsrequest, nil
}

func NewBsnTableChecksumStatsRequest() *BsnTableChecksumStatsRequest {
	return &BsnTableChecksumStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(11),
	}
}

type BsnTableSetBucketsSize struct {
	*BsnHeader
	TableId     uint8
	BucketsSize uint32
}

func (self *BsnTableSetBucketsSize) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.BucketsSize))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTableSetBucketsSize(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnTableSetBucketsSize, error) {
	bsntablesetbucketssize := &BsnTableSetBucketsSize{BsnHeader: parent}
	if decoder.Length() < 7 {
		return nil, fmt.Errorf("BsnTableSetBucketsSize packet too short: %d < 7", decoder.Length())
	}
	decoder.Skip(1)
	bsntablesetbucketssize.TableId = uint8(decoder.ReadByte())
	decoder.Skip(2)
	bsntablesetbucketssize.BucketsSize = uint32(decoder.ReadUint32())
	return bsntablesetbucketssize, nil
}

func NewBsnTableSetBucketsSize() *BsnTableSetBucketsSize {
	return &BsnTableSetBucketsSize{
		BsnHeader: NewBsnHeader(61),
	}
}

type BsnTakeover struct {
	*BsnHeader
}

func (self *BsnTakeover) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTakeover(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnTakeover, error) {
	bsntakeover := &BsnTakeover{BsnHeader: parent}
	return bsntakeover, nil
}

func NewBsnTakeover() *BsnTakeover {
	return &BsnTakeover{
		BsnHeader: NewBsnHeader(69),
	}
}

type BsnTimeReply struct {
	*BsnHeader
	TimeMs uint64
}

func (self *BsnTimeReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.TimeMs))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTimeReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnTimeReply, error) {
	bsntimereply := &BsnTimeReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTimeReply packet too short: %d < 8", decoder.Length())
	}
	bsntimereply.TimeMs = uint64(decoder.ReadUint64())
	return bsntimereply, nil
}

func NewBsnTimeReply() *BsnTimeReply {
	return &BsnTimeReply{
		BsnHeader: NewBsnHeader(45),
	}
}

type BsnTimeRequest struct {
	*BsnHeader
}

func (self *BsnTimeRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTimeRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnTimeRequest, error) {
	bsntimerequest := &BsnTimeRequest{BsnHeader: parent}
	return bsntimerequest, nil
}

func NewBsnTimeRequest() *BsnTimeRequest {
	return &BsnTimeRequest{
		BsnHeader: NewBsnHeader(44),
	}
}

type BsnVirtualPortCreateReply struct {
	*BsnHeader
	Status  uint32
	VportNo uint32
}

func (self *BsnVirtualPortCreateReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))
	encoder.PutUint32(uint32(self.VportNo))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortCreateReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortCreateReply, error) {
	bsnvirtualportcreatereply := &BsnVirtualPortCreateReply{BsnHeader: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVirtualPortCreateReply packet too short: %d < 8", decoder.Length())
	}
	bsnvirtualportcreatereply.Status = uint32(decoder.ReadUint32())
	bsnvirtualportcreatereply.VportNo = uint32(decoder.ReadUint32())
	return bsnvirtualportcreatereply, nil
}

func NewBsnVirtualPortCreateReply() *BsnVirtualPortCreateReply {
	return &BsnVirtualPortCreateReply{
		BsnHeader: NewBsnHeader(16),
	}
}

type BsnVirtualPortCreateRequest struct {
	*BsnHeader
	Vport BSNVport
}

func (self *BsnVirtualPortCreateRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Vport.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortCreateRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortCreateRequest, error) {
	bsnvirtualportcreaterequest := &BsnVirtualPortCreateRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortCreateRequest packet too short: %d < 4", decoder.Length())
	}
	if err := bsnvirtualportcreaterequest.Vport.Decode(decoder); err != nil {
		return nil, err
	}

	return bsnvirtualportcreaterequest, nil
}

func NewBsnVirtualPortCreateRequest() *BsnVirtualPortCreateRequest {
	return &BsnVirtualPortCreateRequest{
		BsnHeader: NewBsnHeader(15),
	}
}

type BsnVirtualPortRemoveReply struct {
	*BsnHeader
	Status uint32
}

func (self *BsnVirtualPortRemoveReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Status))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortRemoveReply(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortRemoveReply, error) {
	bsnvirtualportremovereply := &BsnVirtualPortRemoveReply{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortRemoveReply packet too short: %d < 4", decoder.Length())
	}
	bsnvirtualportremovereply.Status = uint32(decoder.ReadUint32())
	return bsnvirtualportremovereply, nil
}

func NewBsnVirtualPortRemoveReply() *BsnVirtualPortRemoveReply {
	return &BsnVirtualPortRemoveReply{
		BsnHeader: NewBsnHeader(26),
	}
}

type BsnVirtualPortRemoveRequest struct {
	*BsnHeader
	VportNo uint32
}

func (self *BsnVirtualPortRemoveRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.VportNo))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVirtualPortRemoveRequest(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVirtualPortRemoveRequest, error) {
	bsnvirtualportremoverequest := &BsnVirtualPortRemoveRequest{BsnHeader: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVirtualPortRemoveRequest packet too short: %d < 4", decoder.Length())
	}
	bsnvirtualportremoverequest.VportNo = uint32(decoder.ReadUint32())
	return bsnvirtualportremoverequest, nil
}

func NewBsnVirtualPortRemoveRequest() *BsnVirtualPortRemoveRequest {
	return &BsnVirtualPortRemoveRequest{
		BsnHeader: NewBsnHeader(17),
	}
}

type BsnVlanCounterClear struct {
	*BsnHeader
	VlanVid uint16
}

func (self *BsnVlanCounterClear) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.VlanVid))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVlanCounterClear(parent *BsnHeader, decoder *goloxi.Decoder) (*BsnVlanCounterClear, error) {
	bsnvlancounterclear := &BsnVlanCounterClear{BsnHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnVlanCounterClear packet too short: %d < 2", decoder.Length())
	}
	bsnvlancounterclear.VlanVid = uint16(decoder.ReadUint16())
	return bsnvlancounterclear, nil
}

func NewBsnVlanCounterClear() *BsnVlanCounterClear {
	return &BsnVlanCounterClear{
		BsnHeader: NewBsnHeader(70),
	}
}

type BsnVlanCounterStatsReply struct {
	*BsnStatsReply
	Entries []*BsnVlanCounterStatsEntry
}

func (self *BsnVlanCounterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVlanCounterStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnVlanCounterStatsReply, error) {
	bsnvlancounterstatsreply := &BsnVlanCounterStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeBsnVlanCounterStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnvlancounterstatsreply.Entries = append(bsnvlancounterstatsreply.Entries, item)
	}
	return bsnvlancounterstatsreply, nil
}

func NewBsnVlanCounterStatsReply() *BsnVlanCounterStatsReply {
	return &BsnVlanCounterStatsReply{
		BsnStatsReply: NewBsnStatsReply(9),
	}
}

type BsnVlanCounterStatsRequest struct {
	*BsnStatsRequest
	VlanVid uint16
}

func (self *BsnVlanCounterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.VlanVid))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVlanCounterStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnVlanCounterStatsRequest, error) {
	bsnvlancounterstatsrequest := &BsnVlanCounterStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnVlanCounterStatsRequest packet too short: %d < 2", decoder.Length())
	}
	decoder.Skip(4)
	bsnvlancounterstatsrequest.VlanVid = uint16(decoder.ReadUint16())
	return bsnvlancounterstatsrequest, nil
}

func NewBsnVlanCounterStatsRequest() *BsnVlanCounterStatsRequest {
	return &BsnVlanCounterStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(9),
	}
}

type BsnVrfCounterStatsReply struct {
	*BsnStatsReply
	Entries []*BsnVrfCounterStatsEntry
}

func (self *BsnVrfCounterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVrfCounterStatsReply(parent *BsnStatsReply, decoder *goloxi.Decoder) (*BsnVrfCounterStatsReply, error) {
	bsnvrfcounterstatsreply := &BsnVrfCounterStatsReply{BsnStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeBsnVrfCounterStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		bsnvrfcounterstatsreply.Entries = append(bsnvrfcounterstatsreply.Entries, item)
	}
	return bsnvrfcounterstatsreply, nil
}

func NewBsnVrfCounterStatsReply() *BsnVrfCounterStatsReply {
	return &BsnVrfCounterStatsReply{
		BsnStatsReply: NewBsnStatsReply(15),
	}
}

type BsnVrfCounterStatsRequest struct {
	*BsnStatsRequest
	Vrf uint32
}

func (self *BsnVrfCounterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Vrf))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVrfCounterStatsRequest(parent *BsnStatsRequest, decoder *goloxi.Decoder) (*BsnVrfCounterStatsRequest, error) {
	bsnvrfcounterstatsrequest := &BsnVrfCounterStatsRequest{BsnStatsRequest: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnVrfCounterStatsRequest packet too short: %d < 4", decoder.Length())
	}
	decoder.Skip(4)
	bsnvrfcounterstatsrequest.Vrf = uint32(decoder.ReadUint32())
	return bsnvrfcounterstatsrequest, nil
}

func NewBsnVrfCounterStatsRequest() *BsnVrfCounterStatsRequest {
	return &BsnVrfCounterStatsRequest{
		BsnStatsRequest: NewBsnStatsRequest(15),
	}
}

type BundleAddMsg struct {
	*Header
	BundleId uint32
	Flags    BundleFlags
	Data     []byte
}

func (self *BundleAddMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BundleId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint16(uint16(self.Flags))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBundleAddMsg(parent *Header, decoder *goloxi.Decoder) (*BundleAddMsg, error) {
	bundleaddmsg := &BundleAddMsg{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BundleAddMsg packet too short: %d < 8", decoder.Length())
	}
	bundleaddmsg.BundleId = uint32(decoder.ReadUint32())
	decoder.Skip(2)
	bundleaddmsg.Flags = BundleFlags(decoder.ReadUint16())
	bundleaddmsg.Data = decoder.Read(decoder.Length())
	return bundleaddmsg, nil
}

func NewBundleAddMsg() *BundleAddMsg {
	return &BundleAddMsg{
		Header: NewHeader(34),
	}
}

type BundleCtrlMsg struct {
	*Header
	BundleId       uint32
	BundleCtrlType BundleCtrlType
	Flags          BundleFlags
	Properties     []IBundleProp
}

func (self *BundleCtrlMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BundleId))
	encoder.PutUint16(uint16(self.BundleCtrlType))
	encoder.PutUint16(uint16(self.Flags))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBundleCtrlMsg(parent *Header, decoder *goloxi.Decoder) (*BundleCtrlMsg, error) {
	bundlectrlmsg := &BundleCtrlMsg{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BundleCtrlMsg packet too short: %d < 8", decoder.Length())
	}
	bundlectrlmsg.BundleId = uint32(decoder.ReadUint32())
	bundlectrlmsg.BundleCtrlType = BundleCtrlType(decoder.ReadUint16())
	bundlectrlmsg.Flags = BundleFlags(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := decodeBundleProp(decoder)
		if err != nil {
			return nil, err
		}
		bundlectrlmsg.Properties = append(bundlectrlmsg.Properties, item)
	}
	return bundlectrlmsg, nil
}

func NewBundleCtrlMsg() *BundleCtrlMsg {
	return &BundleCtrlMsg{
		Header: NewHeader(33),
	}
}

type BundleFailedErrorMsg struct {
	*ErrorMsg
	Code BundleFailedCode
	Data []byte
}

func (self *BundleFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBundleFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*BundleFailedErrorMsg, error) {
	bundlefailederrormsg := &BundleFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BundleFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	bundlefailederrormsg.Code = BundleFailedCode(decoder.ReadUint16())
	bundlefailederrormsg.Data = decoder.Read(decoder.Length())
	return bundlefailederrormsg, nil
}

func NewBundleFailedErrorMsg() *BundleFailedErrorMsg {
	return &BundleFailedErrorMsg{
		ErrorMsg: NewErrorMsg(17),
	}
}

type DescStatsReply struct {
	*StatsReply
	MfrDesc   string
	HwDesc    string
	SwDesc    string
	SerialNum string
	DpDesc    string
}

func (self *DescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write([]byte(self.MfrDesc))
	encoder.Write([]byte(self.HwDesc))
	encoder.Write([]byte(self.SwDesc))
	encoder.Write([]byte(self.SerialNum))
	encoder.Write([]byte(self.DpDesc))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*DescStatsReply, error) {
	descstatsreply := &DescStatsReply{StatsReply: parent}
	if decoder.Length() < 1056 {
		return nil, fmt.Errorf("DescStatsReply packet too short: %d < 1056", decoder.Length())
	}
	decoder.Skip(4)
	descstatsreply.MfrDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.HwDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.SwDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	descstatsreply.SerialNum = string(bytes.Trim(decoder.Read(32), "\x00"))
	descstatsreply.DpDesc = string(bytes.Trim(decoder.Read(256), "\x00"))
	return descstatsreply, nil
}

func NewDescStatsReply() *DescStatsReply {
	return &DescStatsReply{
		StatsReply: NewStatsReply(0),
	}
}

type DescStatsRequest struct {
	*StatsRequest
}

func (self *DescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*DescStatsRequest, error) {
	descstatsrequest := &DescStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("DescStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return descstatsrequest, nil
}

func NewDescStatsRequest() *DescStatsRequest {
	return &DescStatsRequest{
		StatsRequest: NewStatsRequest(0),
	}
}

type EchoReply struct {
	*Header
	Data []byte
}

func (self *EchoReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeEchoReply(parent *Header, decoder *goloxi.Decoder) (*EchoReply, error) {
	echoreply := &EchoReply{Header: parent}
	echoreply.Data = decoder.Read(decoder.Length())
	return echoreply, nil
}

func NewEchoReply() *EchoReply {
	return &EchoReply{
		Header: NewHeader(3),
	}
}

type EchoRequest struct {
	*Header
	Data []byte
}

func (self *EchoRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeEchoRequest(parent *Header, decoder *goloxi.Decoder) (*EchoRequest, error) {
	echorequest := &EchoRequest{Header: parent}
	echorequest.Data = decoder.Read(decoder.Length())
	return echorequest, nil
}

func NewEchoRequest() *EchoRequest {
	return &EchoRequest{
		Header: NewHeader(2),
	}
}

type FeaturesReply struct {
	*Header
	DatapathId   uint64
	NBuffers     uint32
	NTables      uint8
	AuxiliaryId  uint8
	Capabilities Capabilities
	Reserved     uint32
}

func (self *FeaturesReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.DatapathId))
	encoder.PutUint32(uint32(self.NBuffers))
	encoder.PutUint8(uint8(self.NTables))
	encoder.PutUint8(uint8(self.AuxiliaryId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint32(uint32(self.Reserved))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFeaturesReply(parent *Header, decoder *goloxi.Decoder) (*FeaturesReply, error) {
	featuresreply := &FeaturesReply{Header: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("FeaturesReply packet too short: %d < 24", decoder.Length())
	}
	featuresreply.DatapathId = uint64(decoder.ReadUint64())
	featuresreply.NBuffers = uint32(decoder.ReadUint32())
	featuresreply.NTables = uint8(decoder.ReadByte())
	featuresreply.AuxiliaryId = uint8(decoder.ReadByte())
	decoder.Skip(2)
	featuresreply.Capabilities = Capabilities(decoder.ReadUint32())
	featuresreply.Reserved = uint32(decoder.ReadUint32())
	return featuresreply, nil
}

func NewFeaturesReply() *FeaturesReply {
	return &FeaturesReply{
		Header: NewHeader(6),
	}
}

type FeaturesRequest struct {
	*Header
}

func (self *FeaturesRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFeaturesRequest(parent *Header, decoder *goloxi.Decoder) (*FeaturesRequest, error) {
	featuresrequest := &FeaturesRequest{Header: parent}
	return featuresrequest, nil
}

func NewFeaturesRequest() *FeaturesRequest {
	return &FeaturesRequest{
		Header: NewHeader(5),
	}
}

type FlowMod struct {
	*Header
	Cookie       uint64
	CookieMask   uint64
	TableId      uint8
	Command      FmCmd
	IdleTimeout  uint16
	HardTimeout  uint16
	Priority     uint16
	BufferId     uint32
	OutPort      PortNo
	OutGroup     uint32
	Flags        FlowModFlags
	Match        Match
	Instructions []IInstruction
}

type IFlowMod interface {
	IHeader
	GetCookie() uint64
	GetCookieMask() uint64
	GetTableId() uint8
	GetCommand() FmCmd
	GetIdleTimeout() uint16
	GetHardTimeout() uint16
	GetPriority() uint16
	GetBufferId() uint32
	GetOutPort() PortNo
	GetOutGroup() uint32
	GetFlags() FlowModFlags
	GetMatch() Match
	GetInstructions() []IInstruction
}

func (self *FlowMod) GetCookie() uint64 {
	return self.Cookie
}

func (self *FlowMod) GetCookieMask() uint64 {
	return self.CookieMask
}

func (self *FlowMod) GetTableId() uint8 {
	return self.TableId
}

func (self *FlowMod) GetCommand() FmCmd {
	return self.Command
}

func (self *FlowMod) GetIdleTimeout() uint16 {
	return self.IdleTimeout
}

func (self *FlowMod) GetHardTimeout() uint16 {
	return self.HardTimeout
}

func (self *FlowMod) GetPriority() uint16 {
	return self.Priority
}

func (self *FlowMod) GetBufferId() uint32 {
	return self.BufferId
}

func (self *FlowMod) GetOutPort() PortNo {
	return self.OutPort
}

func (self *FlowMod) GetOutGroup() uint32 {
	return self.OutGroup
}

func (self *FlowMod) GetFlags() FlowModFlags {
	return self.Flags
}

func (self *FlowMod) GetMatch() Match {
	return self.Match
}

func (self *FlowMod) GetInstructions() []IInstruction {
	return self.Instructions
}

func (self *FlowMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.CookieMask))
	encoder.PutUint8(uint8(self.TableId))
	self.Command.Serialize(encoder)
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint32(uint32(self.BufferId))
	self.OutPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.OutGroup))
	encoder.PutUint16(uint16(self.Flags))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}

func decodeFlowMod(parent *Header, decoder *goloxi.Decoder) (IFlowMod, error) {
	flowmod := &FlowMod{Header: parent}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("FlowMod packet too short: %d < 48", decoder.Length())
	}
	flowmod.Cookie = uint64(decoder.ReadUint64())
	flowmod.CookieMask = uint64(decoder.ReadUint64())
	flowmod.TableId = uint8(decoder.ReadByte())
	flowmod.Command.Decode(decoder)
	flowmod.IdleTimeout = uint16(decoder.ReadUint16())
	flowmod.HardTimeout = uint16(decoder.ReadUint16())
	flowmod.Priority = uint16(decoder.ReadUint16())
	flowmod.BufferId = uint32(decoder.ReadUint32())
	flowmod.OutPort.Decode(decoder)
	flowmod.OutGroup = uint32(decoder.ReadUint32())
	flowmod.Flags = FlowModFlags(decoder.ReadUint16())
	decoder.Skip(2)
	if err := flowmod.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		flowmod.Instructions = append(flowmod.Instructions, item)
	}

	switch flowmod.Command {
	case 0:
		return decodeFlowAdd(flowmod, decoder)
	case 1:
		return decodeFlowModify(flowmod, decoder)
	case 2:
		return decodeFlowModifyStrict(flowmod, decoder)
	case 3:
		return decodeFlowDelete(flowmod, decoder)
	case 4:
		return decodeFlowDeleteStrict(flowmod, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'FlowMod'", flowmod.Command)
	}
}

func NewFlowMod(__command FmCmd) *FlowMod {
	return &FlowMod{
		Command: __command,
		Header:  NewHeader(14),
	}
}

type FlowAdd struct {
	*FlowMod
	Importance uint16
}

func (self *FlowAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Importance))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowAdd(parent *FlowMod, decoder *goloxi.Decoder) (*FlowAdd, error) {
	flowadd := &FlowAdd{FlowMod: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("FlowAdd packet too short: %d < 10", decoder.Length())
	}
	flowadd.Importance = uint16(decoder.ReadUint16())
	return flowadd, nil
}

func NewFlowAdd() *FlowAdd {
	return &FlowAdd{
		FlowMod: NewFlowMod(0),
	}
}

type FlowDelete struct {
	*FlowMod
	Importance uint16
}

func (self *FlowDelete) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Importance))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowDelete(parent *FlowMod, decoder *goloxi.Decoder) (*FlowDelete, error) {
	flowdelete := &FlowDelete{FlowMod: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("FlowDelete packet too short: %d < 10", decoder.Length())
	}
	flowdelete.Importance = uint16(decoder.ReadUint16())
	return flowdelete, nil
}

func NewFlowDelete() *FlowDelete {
	return &FlowDelete{
		FlowMod: NewFlowMod(3),
	}
}

type FlowDeleteStrict struct {
	*FlowMod
	Importance uint16
}

func (self *FlowDeleteStrict) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Importance))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowDeleteStrict(parent *FlowMod, decoder *goloxi.Decoder) (*FlowDeleteStrict, error) {
	flowdeletestrict := &FlowDeleteStrict{FlowMod: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("FlowDeleteStrict packet too short: %d < 10", decoder.Length())
	}
	flowdeletestrict.Importance = uint16(decoder.ReadUint16())
	return flowdeletestrict, nil
}

func NewFlowDeleteStrict() *FlowDeleteStrict {
	return &FlowDeleteStrict{
		FlowMod: NewFlowMod(4),
	}
}

type FlowModFailedErrorMsg struct {
	*ErrorMsg
	Code FlowModFailedCode
	Data []byte
}

func (self *FlowModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*FlowModFailedErrorMsg, error) {
	flowmodfailederrormsg := &FlowModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("FlowModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	flowmodfailederrormsg.Code = FlowModFailedCode(decoder.ReadUint16())
	flowmodfailederrormsg.Data = decoder.Read(decoder.Length())
	return flowmodfailederrormsg, nil
}

func NewFlowModFailedErrorMsg() *FlowModFailedErrorMsg {
	return &FlowModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(5),
	}
}

type FlowModify struct {
	*FlowMod
	Importance uint16
}

func (self *FlowModify) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Importance))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModify(parent *FlowMod, decoder *goloxi.Decoder) (*FlowModify, error) {
	flowmodify := &FlowModify{FlowMod: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("FlowModify packet too short: %d < 10", decoder.Length())
	}
	flowmodify.Importance = uint16(decoder.ReadUint16())
	return flowmodify, nil
}

func NewFlowModify() *FlowModify {
	return &FlowModify{
		FlowMod: NewFlowMod(1),
	}
}

type FlowModifyStrict struct {
	*FlowMod
	Importance uint16
}

func (self *FlowModifyStrict) Serialize(encoder *goloxi.Encoder) error {
	if err := self.FlowMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Importance))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowModifyStrict(parent *FlowMod, decoder *goloxi.Decoder) (*FlowModifyStrict, error) {
	flowmodifystrict := &FlowModifyStrict{FlowMod: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("FlowModifyStrict packet too short: %d < 10", decoder.Length())
	}
	flowmodifystrict.Importance = uint16(decoder.ReadUint16())
	return flowmodifystrict, nil
}

func NewFlowModifyStrict() *FlowModifyStrict {
	return &FlowModifyStrict{
		FlowMod: NewFlowMod(2),
	}
}

type FlowMonitorFailedErrorMsg struct {
	*ErrorMsg
	Code FlowMonitorFailedCode
	Data []byte
}

func (self *FlowMonitorFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowMonitorFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*FlowMonitorFailedErrorMsg, error) {
	flowmonitorfailederrormsg := &FlowMonitorFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("FlowMonitorFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	flowmonitorfailederrormsg.Code = FlowMonitorFailedCode(decoder.ReadUint16())
	flowmonitorfailederrormsg.Data = decoder.Read(decoder.Length())
	return flowmonitorfailederrormsg, nil
}

func NewFlowMonitorFailedErrorMsg() *FlowMonitorFailedErrorMsg {
	return &FlowMonitorFailedErrorMsg{
		ErrorMsg: NewErrorMsg(16),
	}
}

type FlowRemoved struct {
	*Header
	Cookie       uint64
	Priority     uint16
	Reason       FlowRemovedReason
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	IdleTimeout  uint16
	HardTimeout  uint16
	PacketCount  uint64
	ByteCount    uint64
	Match        Match
}

func (self *FlowRemoved) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowRemoved(parent *Header, decoder *goloxi.Decoder) (*FlowRemoved, error) {
	flowremoved := &FlowRemoved{Header: parent}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("FlowRemoved packet too short: %d < 48", decoder.Length())
	}
	flowremoved.Cookie = uint64(decoder.ReadUint64())
	flowremoved.Priority = uint16(decoder.ReadUint16())
	flowremoved.Reason = FlowRemovedReason(decoder.ReadByte())
	flowremoved.TableId = uint8(decoder.ReadByte())
	flowremoved.DurationSec = uint32(decoder.ReadUint32())
	flowremoved.DurationNsec = uint32(decoder.ReadUint32())
	flowremoved.IdleTimeout = uint16(decoder.ReadUint16())
	flowremoved.HardTimeout = uint16(decoder.ReadUint16())
	flowremoved.PacketCount = uint64(decoder.ReadUint64())
	flowremoved.ByteCount = uint64(decoder.ReadUint64())
	if err := flowremoved.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return flowremoved, nil
}

func NewFlowRemoved() *FlowRemoved {
	return &FlowRemoved{
		Header: NewHeader(11),
	}
}

type FlowStatsReply struct {
	*StatsReply
	Entries []*FlowStatsEntry
}

func (self *FlowStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*FlowStatsReply, error) {
	flowstatsreply := &FlowStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 56 {
		item, err := decodeFlowStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		flowstatsreply.Entries = append(flowstatsreply.Entries, item)
	}
	return flowstatsreply, nil
}

func NewFlowStatsReply() *FlowStatsReply {
	return &FlowStatsReply{
		StatsReply: NewStatsReply(1),
	}
}

type FlowStatsRequest struct {
	*StatsRequest
	TableId    uint8
	OutPort    PortNo
	OutGroup   uint32
	Cookie     uint64
	CookieMask uint64
	Match      Match
}

func (self *FlowStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	self.OutPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.OutGroup))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.CookieMask))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*FlowStatsRequest, error) {
	flowstatsrequest := &FlowStatsRequest{StatsRequest: parent}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("FlowStatsRequest packet too short: %d < 40", decoder.Length())
	}
	decoder.Skip(4)
	flowstatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	flowstatsrequest.OutPort.Decode(decoder)
	flowstatsrequest.OutGroup = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	flowstatsrequest.Cookie = uint64(decoder.ReadUint64())
	flowstatsrequest.CookieMask = uint64(decoder.ReadUint64())
	if err := flowstatsrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return flowstatsrequest, nil
}

func NewFlowStatsRequest() *FlowStatsRequest {
	return &FlowStatsRequest{
		StatsRequest: NewStatsRequest(1),
	}
}

type GetConfigReply struct {
	*Header
	Flags       ConfigFlags
	MissSendLen uint16
}

func (self *GetConfigReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.MissSendLen))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGetConfigReply(parent *Header, decoder *goloxi.Decoder) (*GetConfigReply, error) {
	getconfigreply := &GetConfigReply{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GetConfigReply packet too short: %d < 4", decoder.Length())
	}
	getconfigreply.Flags = ConfigFlags(decoder.ReadUint16())
	getconfigreply.MissSendLen = uint16(decoder.ReadUint16())
	return getconfigreply, nil
}

func NewGetConfigReply() *GetConfigReply {
	return &GetConfigReply{
		Header: NewHeader(8),
	}
}

type GetConfigRequest struct {
	*Header
}

func (self *GetConfigRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGetConfigRequest(parent *Header, decoder *goloxi.Decoder) (*GetConfigRequest, error) {
	getconfigrequest := &GetConfigRequest{Header: parent}
	return getconfigrequest, nil
}

func NewGetConfigRequest() *GetConfigRequest {
	return &GetConfigRequest{
		Header: NewHeader(7),
	}
}

type GroupMod struct {
	*Header
	Command   GroupModCommand
	GroupType GroupType
	GroupId   uint32
	Buckets   []*Bucket
}

type IGroupMod interface {
	IHeader
	GetCommand() GroupModCommand
	GetGroupType() GroupType
	GetGroupId() uint32
	GetBuckets() []*Bucket
}

func (self *GroupMod) GetCommand() GroupModCommand {
	return self.Command
}

func (self *GroupMod) GetGroupType() GroupType {
	return self.GroupType
}

func (self *GroupMod) GetGroupId() uint32 {
	return self.GroupId
}

func (self *GroupMod) GetBuckets() []*Bucket {
	return self.Buckets
}

func (self *GroupMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Command))
	encoder.PutUint8(uint8(self.GroupType))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.GroupId))
	for _, obj := range self.Buckets {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}

func decodeGroupMod(parent *Header, decoder *goloxi.Decoder) (IGroupMod, error) {
	groupmod := &GroupMod{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupMod packet too short: %d < 8", decoder.Length())
	}
	groupmod.Command = GroupModCommand(decoder.ReadUint16())
	groupmod.GroupType = GroupType(decoder.ReadByte())
	decoder.Skip(1)
	groupmod.GroupId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := decodeBucket(decoder)
		if err != nil {
			return nil, err
		}
		groupmod.Buckets = append(groupmod.Buckets, item)
	}

	switch groupmod.Command {
	case 0:
		return decodeGroupAdd(groupmod, decoder)
	case 1:
		return decodeGroupModify(groupmod, decoder)
	case 2:
		return decodeGroupDelete(groupmod, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'GroupMod'", groupmod.Command)
	}
}

func NewGroupMod(_command ofp_group_mod_comma) *GroupMod {
	return &GroupMod{
		Command: _command,
		Header:  NewHeader(15),
	}
}

type GroupAdd struct {
	*GroupMod
}

func (self *GroupAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 1))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupAdd(parent *GroupMod, decoder *goloxi.Decoder) (*GroupAdd, error) {
	groupadd := &GroupAdd{GroupMod: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupAdd packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(1)
	return groupadd, nil
}

func NewGroupAdd() *GroupAdd {
	return &GroupAdd{
		GroupMod: NewGroupMod(0),
	}
}

type GroupDelete struct {
	*GroupMod
}

func (self *GroupDelete) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 1))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupDelete(parent *GroupMod, decoder *goloxi.Decoder) (*GroupDelete, error) {
	groupdelete := &GroupDelete{GroupMod: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupDelete packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(1)
	return groupdelete, nil
}

func NewGroupDelete() *GroupDelete {
	return &GroupDelete{
		GroupMod: NewGroupMod(2),
	}
}

type GroupDescStatsReply struct {
	*StatsReply
	Entries []*GroupDescStatsEntry
}

func (self *GroupDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*GroupDescStatsReply, error) {
	groupdescstatsreply := &GroupDescStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeGroupDescStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		groupdescstatsreply.Entries = append(groupdescstatsreply.Entries, item)
	}
	return groupdescstatsreply, nil
}

func NewGroupDescStatsReply() *GroupDescStatsReply {
	return &GroupDescStatsReply{
		StatsReply: NewStatsReply(7),
	}
}

type GroupDescStatsRequest struct {
	*StatsRequest
}

func (self *GroupDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*GroupDescStatsRequest, error) {
	groupdescstatsrequest := &GroupDescStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupDescStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return groupdescstatsrequest, nil
}

func NewGroupDescStatsRequest() *GroupDescStatsRequest {
	return &GroupDescStatsRequest{
		StatsRequest: NewStatsRequest(7),
	}
}

type GroupFeaturesStatsReply struct {
	*StatsReply
	Types             uint32
	Capabilities      GroupCapabilities
	MaxGroupsAll      uint32
	MaxGroupsSelect   uint32
	MaxGroupsIndirect uint32
	MaxGroupsFf       uint32
	ActionsAll        uint32
	ActionsSelect     uint32
	ActionsIndirect   uint32
	ActionsFf         uint32
}

func (self *GroupFeaturesStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Types))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint32(uint32(self.MaxGroupsAll))
	encoder.PutUint32(uint32(self.MaxGroupsSelect))
	encoder.PutUint32(uint32(self.MaxGroupsIndirect))
	encoder.PutUint32(uint32(self.MaxGroupsFf))
	encoder.PutUint32(uint32(self.ActionsAll))
	encoder.PutUint32(uint32(self.ActionsSelect))
	encoder.PutUint32(uint32(self.ActionsIndirect))
	encoder.PutUint32(uint32(self.ActionsFf))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupFeaturesStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*GroupFeaturesStatsReply, error) {
	groupfeaturesstatsreply := &GroupFeaturesStatsReply{StatsReply: parent}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("GroupFeaturesStatsReply packet too short: %d < 40", decoder.Length())
	}
	decoder.Skip(4)
	groupfeaturesstatsreply.Types = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.Capabilities = GroupCapabilities(decoder.ReadUint32())
	groupfeaturesstatsreply.MaxGroupsAll = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.MaxGroupsSelect = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.MaxGroupsIndirect = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.MaxGroupsFf = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.ActionsAll = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.ActionsSelect = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.ActionsIndirect = uint32(decoder.ReadUint32())
	groupfeaturesstatsreply.ActionsFf = uint32(decoder.ReadUint32())
	return groupfeaturesstatsreply, nil
}

func NewGroupFeaturesStatsReply() *GroupFeaturesStatsReply {
	return &GroupFeaturesStatsReply{
		StatsReply: NewStatsReply(8),
	}
}

type GroupFeaturesStatsRequest struct {
	*StatsRequest
}

func (self *GroupFeaturesStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupFeaturesStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*GroupFeaturesStatsRequest, error) {
	groupfeaturesstatsrequest := &GroupFeaturesStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupFeaturesStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return groupfeaturesstatsrequest, nil
}

func NewGroupFeaturesStatsRequest() *GroupFeaturesStatsRequest {
	return &GroupFeaturesStatsRequest{
		StatsRequest: NewStatsRequest(8),
	}
}

type GroupModFailedErrorMsg struct {
	*ErrorMsg
	Code GroupModFailedCode
	Data []byte
}

func (self *GroupModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*GroupModFailedErrorMsg, error) {
	groupmodfailederrormsg := &GroupModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("GroupModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	groupmodfailederrormsg.Code = GroupModFailedCode(decoder.ReadUint16())
	groupmodfailederrormsg.Data = decoder.Read(decoder.Length())
	return groupmodfailederrormsg, nil
}

func NewGroupModFailedErrorMsg() *GroupModFailedErrorMsg {
	return &GroupModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(6),
	}
}

type GroupModify struct {
	*GroupMod
}

func (self *GroupModify) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupMod.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 1))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupModify(parent *GroupMod, decoder *goloxi.Decoder) (*GroupModify, error) {
	groupmodify := &GroupModify{GroupMod: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupModify packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(1)
	return groupmodify, nil
}

func NewGroupModify() *GroupModify {
	return &GroupModify{
		GroupMod: NewGroupMod(1),
	}
}

type GroupStatsReply struct {
	*StatsReply
	Entries []*GroupStatsEntry
}

func (self *GroupStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*GroupStatsReply, error) {
	groupstatsreply := &GroupStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 40 {
		item, err := decodeGroupStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		groupstatsreply.Entries = append(groupstatsreply.Entries, item)
	}
	return groupstatsreply, nil
}

func NewGroupStatsReply() *GroupStatsReply {
	return &GroupStatsReply{
		StatsReply: NewStatsReply(6),
	}
}

type GroupStatsRequest struct {
	*StatsRequest
	GroupId uint32
}

func (self *GroupStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*GroupStatsRequest, error) {
	groupstatsrequest := &GroupStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	groupstatsrequest.GroupId = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return groupstatsrequest, nil
}

func NewGroupStatsRequest() *GroupStatsRequest {
	return &GroupStatsRequest{
		StatsRequest: NewStatsRequest(6),
	}
}

type Hello struct {
	*Header
	Elements []IHelloElem
}

func (self *Hello) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Elements {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeHello(parent *Header, decoder *goloxi.Decoder) (*Hello, error) {
	hello := &Hello{Header: parent}

	for decoder.Length() >= 4 {
		item, err := decodeHelloElem(decoder)
		if err != nil {
			return nil, err
		}
		hello.Elements = append(hello.Elements, item)
	}
	return hello, nil
}

func NewHello() *Hello {
	return &Hello{
		Header: NewHeader(0),
	}
}

type HelloFailedErrorMsg struct {
	*ErrorMsg
	Code HelloFailedCode
	Data []byte
}

func (self *HelloFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeHelloFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*HelloFailedErrorMsg, error) {
	hellofailederrormsg := &HelloFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("HelloFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	hellofailederrormsg.Code = HelloFailedCode(decoder.ReadUint16())
	hellofailederrormsg.Data = decoder.Read(decoder.Length())
	return hellofailederrormsg, nil
}

func NewHelloFailedErrorMsg() *HelloFailedErrorMsg {
	return &HelloFailedErrorMsg{
		ErrorMsg: NewErrorMsg(0),
	}
}

type MeterConfigStatsReply struct {
	*StatsReply
	Entries []*MeterConfig
}

func (self *MeterConfigStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterConfigStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*MeterConfigStatsReply, error) {
	meterconfigstatsreply := &MeterConfigStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeMeterConfig(decoder)
		if err != nil {
			return nil, err
		}
		meterconfigstatsreply.Entries = append(meterconfigstatsreply.Entries, item)
	}
	return meterconfigstatsreply, nil
}

func NewMeterConfigStatsReply() *MeterConfigStatsReply {
	return &MeterConfigStatsReply{
		StatsReply: NewStatsReply(10),
	}
}

type MeterConfigStatsRequest struct {
	*StatsRequest
	MeterId uint32
}

func (self *MeterConfigStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.MeterId))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterConfigStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*MeterConfigStatsRequest, error) {
	meterconfigstatsrequest := &MeterConfigStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("MeterConfigStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	meterconfigstatsrequest.MeterId = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return meterconfigstatsrequest, nil
}

func NewMeterConfigStatsRequest() *MeterConfigStatsRequest {
	return &MeterConfigStatsRequest{
		StatsRequest: NewStatsRequest(10),
	}
}

type MeterFeaturesStatsReply struct {
	*StatsReply
	Features MeterFeatures
}

func (self *MeterFeaturesStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	if err := self.Features.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterFeaturesStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*MeterFeaturesStatsReply, error) {
	meterfeaturesstatsreply := &MeterFeaturesStatsReply{StatsReply: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("MeterFeaturesStatsReply packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	if err := meterfeaturesstatsreply.Features.Decode(decoder); err != nil {
		return nil, err
	}

	return meterfeaturesstatsreply, nil
}

func NewMeterFeaturesStatsReply() *MeterFeaturesStatsReply {
	return &MeterFeaturesStatsReply{
		StatsReply: NewStatsReply(11),
	}
}

type MeterFeaturesStatsRequest struct {
	*StatsRequest
}

func (self *MeterFeaturesStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterFeaturesStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*MeterFeaturesStatsRequest, error) {
	meterfeaturesstatsrequest := &MeterFeaturesStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("MeterFeaturesStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return meterfeaturesstatsrequest, nil
}

func NewMeterFeaturesStatsRequest() *MeterFeaturesStatsRequest {
	return &MeterFeaturesStatsRequest{
		StatsRequest: NewStatsRequest(11),
	}
}

type MeterMod struct {
	*Header
	Command MeterModCommand
	Flags   MeterFlags
	MeterId uint32
	Bands   []IMeterBand
}

func (self *MeterMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Command))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint32(uint32(self.MeterId))
	for _, obj := range self.Bands {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterMod(parent *Header, decoder *goloxi.Decoder) (*MeterMod, error) {
	metermod := &MeterMod{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("MeterMod packet too short: %d < 8", decoder.Length())
	}
	metermod.Command = MeterModCommand(decoder.ReadUint16())
	metermod.Flags = MeterFlags(decoder.ReadUint16())
	metermod.MeterId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeMeterBand(decoder)
		if err != nil {
			return nil, err
		}
		metermod.Bands = append(metermod.Bands, item)
	}
	return metermod, nil
}

func NewMeterMod() *MeterMod {
	return &MeterMod{
		Header: NewHeader(29),
	}
}

type MeterModFailedErrorMsg struct {
	*ErrorMsg
	Code MeterModFailedCode
	Data []byte
}

func (self *MeterModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*MeterModFailedErrorMsg, error) {
	metermodfailederrormsg := &MeterModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("MeterModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	metermodfailederrormsg.Code = MeterModFailedCode(decoder.ReadUint16())
	metermodfailederrormsg.Data = decoder.Read(decoder.Length())
	return metermodfailederrormsg, nil
}

func NewMeterModFailedErrorMsg() *MeterModFailedErrorMsg {
	return &MeterModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(12),
	}
}

type MeterStatsReply struct {
	*StatsReply
	Entries []*MeterStats
}

func (self *MeterStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*MeterStatsReply, error) {
	meterstatsreply := &MeterStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 40 {
		item, err := decodeMeterStats(decoder)
		if err != nil {
			return nil, err
		}
		meterstatsreply.Entries = append(meterstatsreply.Entries, item)
	}
	return meterstatsreply, nil
}

func NewMeterStatsReply() *MeterStatsReply {
	return &MeterStatsReply{
		StatsReply: NewStatsReply(9),
	}
}

type MeterStatsRequest struct {
	*StatsRequest
	MeterId uint32
}

func (self *MeterStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.MeterId))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*MeterStatsRequest, error) {
	meterstatsrequest := &MeterStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("MeterStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	meterstatsrequest.MeterId = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return meterstatsrequest, nil
}

func NewMeterStatsRequest() *MeterStatsRequest {
	return &MeterStatsRequest{
		StatsRequest: NewStatsRequest(9),
	}
}

type NiciraStatsReply struct {
	*ExperimenterStatsReply
}

type INiciraStatsReply interface {
	IExperimenterStatsReply
}

func (self *NiciraStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsReply.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodeNiciraStatsReply(parent *ExperimenterStatsReply, decoder *goloxi.Decoder) (INiciraStatsReply, error) {
	nicirastatsreply := &NiciraStatsReply{ExperimenterStatsReply: parent}
	if decoder.Length() < -4 {
		return nil, fmt.Errorf("NiciraStatsReply packet too short: %d < -4", decoder.Length())
	}

	switch nicirastatsreply.Subtype {
	case 0:
		return decodeNiciraFlowStatsReply(nicirastatsreply, decoder)
	case 2:
		return decodeNiciraFlowMonitorReply(nicirastatsreply, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraStatsReply'", nicirastatsreply.Subtype)
	}
}

func NewNiciraStatsReply(_subtype uint32) *NiciraStatsReply {
	return &NiciraStatsReply{
		Subtype:                _subtype,
		ExperimenterStatsReply: NewExperimenterStatsReply(8992),
	}
}

type NiciraFlowMonitorReply struct {
	*NiciraStatsReply
	Updates []INiciraFlowUpdateEvent
}

func (self *NiciraFlowMonitorReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Updates {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowMonitorReply(parent *NiciraStatsReply, decoder *goloxi.Decoder) (*NiciraFlowMonitorReply, error) {
	niciraflowmonitorreply := &NiciraFlowMonitorReply{NiciraStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 4 {
		item, err := decodeNiciraFlowUpdateEvent(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowmonitorreply.Updates = append(niciraflowmonitorreply.Updates, item)
	}
	return niciraflowmonitorreply, nil
}

func NewNiciraFlowMonitorReply() *NiciraFlowMonitorReply {
	return &NiciraFlowMonitorReply{
		NiciraStatsReply: NewNiciraStatsReply(2),
	}
}

type NiciraFlowMonitorRequest struct {
	*ExperimenterStatsRequest
	MonitorId    uint32
	MonitorFlags NxFlowMonitorFlags
	OutPort      PortNo
	MatchLen     uint16
	TableId      uint8
	Match        NiciraMatch
}

func (self *NiciraFlowMonitorRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.MonitorId))
	encoder.PutUint16(uint16(self.MonitorFlags))
	self.OutPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 5))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowMonitorRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (*NiciraFlowMonitorRequest, error) {
	niciraflowmonitorrequest := &NiciraFlowMonitorRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 18 {
		return nil, fmt.Errorf("NiciraFlowMonitorRequest packet too short: %d < 18", decoder.Length())
	}
	decoder.Skip(4)
	niciraflowmonitorrequest.MonitorId = uint32(decoder.ReadUint32())
	niciraflowmonitorrequest.MonitorFlags = NxFlowMonitorFlags(decoder.ReadUint16())
	niciraflowmonitorrequest.OutPort.Decode(decoder)
	niciraflowmonitorrequest.MatchLen = uint16(decoder.ReadUint16())
	niciraflowmonitorrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(5)
	if err := niciraflowmonitorrequest.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return niciraflowmonitorrequest, nil
}

func NewNiciraFlowMonitorRequest() *NiciraFlowMonitorRequest {
	return &NiciraFlowMonitorRequest{
		ExperimenterStatsRequest: NewExperimenterStatsRequest(8992),
	}
}

type NiciraFlowStatsReply struct {
	*NiciraStatsReply
	Stats []*NiciraFlowStats
}

func (self *NiciraFlowStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraStatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Stats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStatsReply(parent *NiciraStatsReply, decoder *goloxi.Decoder) (*NiciraFlowStatsReply, error) {
	niciraflowstatsreply := &NiciraFlowStatsReply{NiciraStatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 48 {
		item, err := decodeNiciraFlowStats(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowstatsreply.Stats = append(niciraflowstatsreply.Stats, item)
	}
	return niciraflowstatsreply, nil
}

func NewNiciraFlowStatsReply() *NiciraFlowStatsReply {
	return &NiciraFlowStatsReply{
		NiciraStatsReply: NewNiciraStatsReply(0),
	}
}

type NiciraFlowStatsRequest struct {
	*ExperimenterStatsRequest
	OutPort  PortNo
	MatchLen uint16
	TableId  uint8
}

func (self *NiciraFlowStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ExperimenterStatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.OutPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStatsRequest(parent *ExperimenterStatsRequest, decoder *goloxi.Decoder) (*NiciraFlowStatsRequest, error) {
	niciraflowstatsrequest := &NiciraFlowStatsRequest{ExperimenterStatsRequest: parent}
	if decoder.Length() < 10 {
		return nil, fmt.Errorf("NiciraFlowStatsRequest packet too short: %d < 10", decoder.Length())
	}
	decoder.Skip(4)
	niciraflowstatsrequest.OutPort.Decode(decoder)
	niciraflowstatsrequest.MatchLen = uint16(decoder.ReadUint16())
	niciraflowstatsrequest.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return niciraflowstatsrequest, nil
}

func NewNiciraFlowStatsRequest() *NiciraFlowStatsRequest {
	return &NiciraFlowStatsRequest{
		ExperimenterStatsRequest: NewExperimenterStatsRequest(8992),
	}
}

type NiciraHeader struct {
	*Experimenter
}

type INiciraHeader interface {
	IExperimenter
}

func (self *NiciraHeader) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Experimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodeNiciraHeader(parent *Experimenter, decoder *goloxi.Decoder) (INiciraHeader, error) {
	niciraheader := &NiciraHeader{Experimenter: parent}
	return niciraheader, nil
}

func NewNiciraHeader(_subtype uint32) *NiciraHeader {
	return &NiciraHeader{
		Subtype:      _subtype,
		Experimenter: NewExperimenter(8992),
	}
}

type PacketIn struct {
	*Header
	BufferId uint32
	TotalLen uint16
	Reason   uint8
	TableId  uint8
	Cookie   uint64
	Match    Match
	Data     []byte
}

func (self *PacketIn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BufferId))
	encoder.PutUint16(uint16(self.TotalLen))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketIn(parent *Header, decoder *goloxi.Decoder) (*PacketIn, error) {
	packetin := &PacketIn{Header: parent}
	if decoder.Length() < 26 {
		return nil, fmt.Errorf("PacketIn packet too short: %d < 26", decoder.Length())
	}
	packetin.BufferId = uint32(decoder.ReadUint32())
	packetin.TotalLen = uint16(decoder.ReadUint16())
	packetin.Reason = uint8(decoder.ReadByte())
	packetin.TableId = uint8(decoder.ReadByte())
	packetin.Cookie = uint64(decoder.ReadUint64())
	if err := packetin.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	decoder.Skip(2)
	packetin.Data = decoder.Read(decoder.Length())
	return packetin, nil
}

func NewPacketIn() *PacketIn {
	return &PacketIn{
		Header: NewHeader(10),
	}
}

type PacketOut struct {
	*Header
	BufferId   uint32
	InPort     PortNo
	ActionsLen uint16
	Actions    []IAction
	Data       []byte
}

func (self *PacketOut) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.BufferId))
	self.InPort.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActionsLen))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketOut(parent *Header, decoder *goloxi.Decoder) (*PacketOut, error) {
	packetout := &PacketOut{Header: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PacketOut packet too short: %d < 16", decoder.Length())
	}
	packetout.BufferId = uint32(decoder.ReadUint32())
	packetout.InPort.Decode(decoder)
	packetout.ActionsLen = uint16(decoder.ReadUint16())
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		packetout.Actions = append(packetout.Actions, item)
	}
	packetout.Data = decoder.Read(decoder.Length())
	return packetout, nil
}

func NewPacketOut() *PacketOut {
	return &PacketOut{
		Header: NewHeader(13),
	}
}

type PortDescStatsReply struct {
	*StatsReply
	Entries []*PortDesc
}

func (self *PortDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*PortDescStatsReply, error) {
	portdescstatsreply := &PortDescStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 40 {
		item := &PortDesc{}
		if err := item.Decode(decoder); err != nil {
			return nil, err
		}
		portdescstatsreply.Entries = append(portdescstatsreply.Entries, item)
	}
	return portdescstatsreply, nil
}

func NewPortDescStatsReply() *PortDescStatsReply {
	return &PortDescStatsReply{
		StatsReply: NewStatsReply(13),
	}
}

type PortDescStatsRequest struct {
	*StatsRequest
}

func (self *PortDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*PortDescStatsRequest, error) {
	portdescstatsrequest := &PortDescStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PortDescStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return portdescstatsrequest, nil
}

func NewPortDescStatsRequest() *PortDescStatsRequest {
	return &PortDescStatsRequest{
		StatsRequest: NewStatsRequest(13),
	}
}

type PortMod struct {
	*Header
	PortNo     PortNo
	HwAddr     net.HardwareAddr
	Config     PortConfig
	Mask       PortConfig
	Properties []IPortModProp
}

func (self *PortMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.Mask))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortMod(parent *Header, decoder *goloxi.Decoder) (*PortMod, error) {
	portmod := &PortMod{Header: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortMod packet too short: %d < 24", decoder.Length())
	}
	portmod.PortNo.Decode(decoder)
	decoder.Skip(4)
	portmod.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	portmod.Config = PortConfig(decoder.ReadUint32())
	portmod.Mask = PortConfig(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodePortModProp(decoder)
		if err != nil {
			return nil, err
		}
		portmod.Properties = append(portmod.Properties, item)
	}
	return portmod, nil
}

func NewPortMod() *PortMod {
	return &PortMod{
		Header: NewHeader(16),
	}
}

type PortModFailedErrorMsg struct {
	*ErrorMsg
	Code PortModFailedCode
	Data []byte
}

func (self *PortModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*PortModFailedErrorMsg, error) {
	portmodfailederrormsg := &PortModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("PortModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	portmodfailederrormsg.Code = PortModFailedCode(decoder.ReadUint16())
	portmodfailederrormsg.Data = decoder.Read(decoder.Length())
	return portmodfailederrormsg, nil
}

func NewPortModFailedErrorMsg() *PortModFailedErrorMsg {
	return &PortModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(7),
	}
}

type PortStatsReply struct {
	*StatsReply
	Entries []*PortStatsEntry
}

func (self *PortStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*PortStatsReply, error) {
	portstatsreply := &PortStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 80 {
		item, err := decodePortStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		portstatsreply.Entries = append(portstatsreply.Entries, item)
	}
	return portstatsreply, nil
}

func NewPortStatsReply() *PortStatsReply {
	return &PortStatsReply{
		StatsReply: NewStatsReply(4),
	}
}

type PortStatsRequest struct {
	*StatsRequest
	PortNo PortNo
}

func (self *PortStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*PortStatsRequest, error) {
	portstatsrequest := &PortStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	portstatsrequest.PortNo.Decode(decoder)
	decoder.Skip(4)
	return portstatsrequest, nil
}

func NewPortStatsRequest() *PortStatsRequest {
	return &PortStatsRequest{
		StatsRequest: NewStatsRequest(4),
	}
}

type PortStatus struct {
	*Header
	Reason PortReason
	Desc   PortDesc
}

func (self *PortStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 7))
	if err := self.Desc.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatus(parent *Header, decoder *goloxi.Decoder) (*PortStatus, error) {
	portstatus := &PortStatus{Header: parent}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("PortStatus packet too short: %d < 48", decoder.Length())
	}
	portstatus.Reason = PortReason(decoder.ReadByte())
	decoder.Skip(7)
	if err := portstatus.Desc.Decode(decoder); err != nil {
		return nil, err
	}

	return portstatus, nil
}

func NewPortStatus() *PortStatus {
	return &PortStatus{
		Header: NewHeader(12),
	}
}

type QueueDescStatsReply struct {
	*StatsReply
	Entries []*QueueDesc
}

func (self *QueueDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*QueueDescStatsReply, error) {
	queuedescstatsreply := &QueueDescStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 16 {
		item, err := decodeQueueDesc(decoder)
		if err != nil {
			return nil, err
		}
		queuedescstatsreply.Entries = append(queuedescstatsreply.Entries, item)
	}
	return queuedescstatsreply, nil
}

func NewQueueDescStatsReply() *QueueDescStatsReply {
	return &QueueDescStatsReply{
		StatsReply: NewStatsReply(15),
	}
}

type QueueDescStatsRequest struct {
	*StatsRequest
	PortNo  PortNo
	QueueId uint32
}

func (self *QueueDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*QueueDescStatsRequest, error) {
	queuedescstatsrequest := &QueueDescStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueDescStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuedescstatsrequest.PortNo.Decode(decoder)
	queuedescstatsrequest.QueueId = uint32(decoder.ReadUint32())
	return queuedescstatsrequest, nil
}

func NewQueueDescStatsRequest() *QueueDescStatsRequest {
	return &QueueDescStatsRequest{
		StatsRequest: NewStatsRequest(15),
	}
}

type QueueOpFailedErrorMsg struct {
	*ErrorMsg
	Code QueueOpFailedCode
	Data []byte
}

func (self *QueueOpFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueOpFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*QueueOpFailedErrorMsg, error) {
	queueopfailederrormsg := &QueueOpFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("QueueOpFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	queueopfailederrormsg.Code = QueueOpFailedCode(decoder.ReadUint16())
	queueopfailederrormsg.Data = decoder.Read(decoder.Length())
	return queueopfailederrormsg, nil
}

func NewQueueOpFailedErrorMsg() *QueueOpFailedErrorMsg {
	return &QueueOpFailedErrorMsg{
		ErrorMsg: NewErrorMsg(9),
	}
}

type QueueStatsReply struct {
	*StatsReply
	Entries []*QueueStatsEntry
}

func (self *QueueStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*QueueStatsReply, error) {
	queuestatsreply := &QueueStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 48 {
		item, err := decodeQueueStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		queuestatsreply.Entries = append(queuestatsreply.Entries, item)
	}
	return queuestatsreply, nil
}

func NewQueueStatsReply() *QueueStatsReply {
	return &QueueStatsReply{
		StatsReply: NewStatsReply(5),
	}
}

type QueueStatsRequest struct {
	*StatsRequest
	PortNo  PortNo
	QueueId uint32
}

func (self *QueueStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*QueueStatsRequest, error) {
	queuestatsrequest := &QueueStatsRequest{StatsRequest: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueStatsRequest packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuestatsrequest.PortNo.Decode(decoder)
	queuestatsrequest.QueueId = uint32(decoder.ReadUint32())
	return queuestatsrequest, nil
}

func NewQueueStatsRequest() *QueueStatsRequest {
	return &QueueStatsRequest{
		StatsRequest: NewStatsRequest(5),
	}
}

type Requestforward struct {
	*Header
	Role uint32
	Data []byte
}

func (self *Requestforward) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRequestforward(parent *Header, decoder *goloxi.Decoder) (*Requestforward, error) {
	requestforward := &Requestforward{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Requestforward packet too short: %d < 4", decoder.Length())
	}
	requestforward.Role = uint32(decoder.ReadUint32())
	requestforward.Data = decoder.Read(decoder.Length())
	return requestforward, nil
}

func NewRequestforward() *Requestforward {
	return &Requestforward{
		Header: NewHeader(32),
	}
}

type RoleReply struct {
	*Header
	Role         ControllerRole
	GenerationId uint64
}

func (self *RoleReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.GenerationId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRoleReply(parent *Header, decoder *goloxi.Decoder) (*RoleReply, error) {
	rolereply := &RoleReply{Header: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("RoleReply packet too short: %d < 16", decoder.Length())
	}
	rolereply.Role = ControllerRole(decoder.ReadUint32())
	decoder.Skip(4)
	rolereply.GenerationId = uint64(decoder.ReadUint64())
	return rolereply, nil
}

func NewRoleReply() *RoleReply {
	return &RoleReply{
		Header: NewHeader(25),
	}
}

type RoleRequest struct {
	*Header
	Role         ControllerRole
	GenerationId uint64
}

func (self *RoleRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.GenerationId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRoleRequest(parent *Header, decoder *goloxi.Decoder) (*RoleRequest, error) {
	rolerequest := &RoleRequest{Header: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("RoleRequest packet too short: %d < 16", decoder.Length())
	}
	rolerequest.Role = ControllerRole(decoder.ReadUint32())
	decoder.Skip(4)
	rolerequest.GenerationId = uint64(decoder.ReadUint64())
	return rolerequest, nil
}

func NewRoleRequest() *RoleRequest {
	return &RoleRequest{
		Header: NewHeader(24),
	}
}

type RoleRequestFailedErrorMsg struct {
	*ErrorMsg
	Code RoleRequestFailedCode
	Data []byte
}

func (self *RoleRequestFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRoleRequestFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*RoleRequestFailedErrorMsg, error) {
	rolerequestfailederrormsg := &RoleRequestFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("RoleRequestFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	rolerequestfailederrormsg.Code = RoleRequestFailedCode(decoder.ReadUint16())
	rolerequestfailederrormsg.Data = decoder.Read(decoder.Length())
	return rolerequestfailederrormsg, nil
}

func NewRoleRequestFailedErrorMsg() *RoleRequestFailedErrorMsg {
	return &RoleRequestFailedErrorMsg{
		ErrorMsg: NewErrorMsg(11),
	}
}

type RoleStatus struct {
	*Header
	Role         ControllerRole
	Reason       ControllerRoleReason
	GenerationId uint64
	Properties   []IRoleProp
}

func (self *RoleStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))
	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint64(uint64(self.GenerationId))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRoleStatus(parent *Header, decoder *goloxi.Decoder) (*RoleStatus, error) {
	rolestatus := &RoleStatus{Header: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("RoleStatus packet too short: %d < 16", decoder.Length())
	}
	rolestatus.Role = ControllerRole(decoder.ReadUint32())
	rolestatus.Reason = ControllerRoleReason(decoder.ReadByte())
	decoder.Skip(3)
	rolestatus.GenerationId = uint64(decoder.ReadUint64())

	for decoder.Length() >= 4 {
		item, err := decodeRoleProp(decoder)
		if err != nil {
			return nil, err
		}
		rolestatus.Properties = append(rolestatus.Properties, item)
	}
	return rolestatus, nil
}

func NewRoleStatus() *RoleStatus {
	return &RoleStatus{
		Header: NewHeader(30),
	}
}

type SetConfig struct {
	*Header
	Flags       ConfigFlags
	MissSendLen uint16
}

func (self *SetConfig) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.MissSendLen))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeSetConfig(parent *Header, decoder *goloxi.Decoder) (*SetConfig, error) {
	setconfig := &SetConfig{Header: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("SetConfig packet too short: %d < 4", decoder.Length())
	}
	setconfig.Flags = ConfigFlags(decoder.ReadUint16())
	setconfig.MissSendLen = uint16(decoder.ReadUint16())
	return setconfig, nil
}

func NewSetConfig() *SetConfig {
	return &SetConfig{
		Header: NewHeader(9),
	}
}

type SwitchConfigFailedErrorMsg struct {
	*ErrorMsg
	Code SwitchConfigFailedCode
	Data []byte
}

func (self *SwitchConfigFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeSwitchConfigFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*SwitchConfigFailedErrorMsg, error) {
	switchconfigfailederrormsg := &SwitchConfigFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("SwitchConfigFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	switchconfigfailederrormsg.Code = SwitchConfigFailedCode(decoder.ReadUint16())
	switchconfigfailederrormsg.Data = decoder.Read(decoder.Length())
	return switchconfigfailederrormsg, nil
}

func NewSwitchConfigFailedErrorMsg() *SwitchConfigFailedErrorMsg {
	return &SwitchConfigFailedErrorMsg{
		ErrorMsg: NewErrorMsg(10),
	}
}

type TableDescStatsReply struct {
	*StatsReply
	Entries []*TableDesc
}

func (self *TableDescStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableDescStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*TableDescStatsReply, error) {
	tabledescstatsreply := &TableDescStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item := &TableDesc{}
		if err := item.Decode(decoder); err != nil {
			return nil, err
		}
		tabledescstatsreply.Entries = append(tabledescstatsreply.Entries, item)
	}
	return tabledescstatsreply, nil
}

func NewTableDescStatsReply() *TableDescStatsReply {
	return &TableDescStatsReply{
		StatsReply: NewStatsReply(14),
	}
}

type TableDescStatsRequest struct {
	*StatsRequest
}

func (self *TableDescStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableDescStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*TableDescStatsRequest, error) {
	tabledescstatsrequest := &TableDescStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("TableDescStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return tabledescstatsrequest, nil
}

func NewTableDescStatsRequest() *TableDescStatsRequest {
	return &TableDescStatsRequest{
		StatsRequest: NewStatsRequest(14),
	}
}

type TableFeaturesFailedErrorMsg struct {
	*ErrorMsg
	Code TableFeaturesFailedCode
	Data []byte
}

func (self *TableFeaturesFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturesFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*TableFeaturesFailedErrorMsg, error) {
	tablefeaturesfailederrormsg := &TableFeaturesFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("TableFeaturesFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	tablefeaturesfailederrormsg.Code = TableFeaturesFailedCode(decoder.ReadUint16())
	tablefeaturesfailederrormsg.Data = decoder.Read(decoder.Length())
	return tablefeaturesfailederrormsg, nil
}

func NewTableFeaturesFailedErrorMsg() *TableFeaturesFailedErrorMsg {
	return &TableFeaturesFailedErrorMsg{
		ErrorMsg: NewErrorMsg(13),
	}
}

type TableFeaturesStatsReply struct {
	*StatsReply
	Entries []*TableFeatures
}

func (self *TableFeaturesStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturesStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*TableFeaturesStatsReply, error) {
	tablefeaturesstatsreply := &TableFeaturesStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 64 {
		item, err := decodeTableFeatures(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturesstatsreply.Entries = append(tablefeaturesstatsreply.Entries, item)
	}
	return tablefeaturesstatsreply, nil
}

func NewTableFeaturesStatsReply() *TableFeaturesStatsReply {
	return &TableFeaturesStatsReply{
		StatsReply: NewStatsReply(12),
	}
}

type TableFeaturesStatsRequest struct {
	*StatsRequest
	Entries []*TableFeatures
}

func (self *TableFeaturesStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturesStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*TableFeaturesStatsRequest, error) {
	tablefeaturesstatsrequest := &TableFeaturesStatsRequest{StatsRequest: parent}
	decoder.Skip(4)

	for decoder.Length() >= 64 {
		item, err := decodeTableFeatures(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturesstatsrequest.Entries = append(tablefeaturesstatsrequest.Entries, item)
	}
	return tablefeaturesstatsrequest, nil
}

func NewTableFeaturesStatsRequest() *TableFeaturesStatsRequest {
	return &TableFeaturesStatsRequest{
		StatsRequest: NewStatsRequest(12),
	}
}

type TableMod struct {
	*Header
	TableId    uint8
	Config     uint32
	Properties []ITableModProp
}

func (self *TableMod) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.Config))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableMod(parent *Header, decoder *goloxi.Decoder) (*TableMod, error) {
	tablemod := &TableMod{Header: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableMod packet too short: %d < 8", decoder.Length())
	}
	tablemod.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	tablemod.Config = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeTableModProp(decoder)
		if err != nil {
			return nil, err
		}
		tablemod.Properties = append(tablemod.Properties, item)
	}
	return tablemod, nil
}

func NewTableMod() *TableMod {
	return &TableMod{
		Header: NewHeader(17),
	}
}

type TableModFailedErrorMsg struct {
	*ErrorMsg
	Code TableModFailedCode
	Data []byte
}

func (self *TableModFailedErrorMsg) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ErrorMsg.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Code))
	encoder.Write(self.Data)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableModFailedErrorMsg(parent *ErrorMsg, decoder *goloxi.Decoder) (*TableModFailedErrorMsg, error) {
	tablemodfailederrormsg := &TableModFailedErrorMsg{ErrorMsg: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("TableModFailedErrorMsg packet too short: %d < 2", decoder.Length())
	}
	tablemodfailederrormsg.Code = TableModFailedCode(decoder.ReadUint16())
	tablemodfailederrormsg.Data = decoder.Read(decoder.Length())
	return tablemodfailederrormsg, nil
}

func NewTableModFailedErrorMsg() *TableModFailedErrorMsg {
	return &TableModFailedErrorMsg{
		ErrorMsg: NewErrorMsg(8),
	}
}

type TableStatsReply struct {
	*StatsReply
	Entries []*TableStatsEntry
}

func (self *TableStatsReply) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsReply.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableStatsReply(parent *StatsReply, decoder *goloxi.Decoder) (*TableStatsReply, error) {
	tablestatsreply := &TableStatsReply{StatsReply: parent}
	decoder.Skip(4)

	for decoder.Length() >= 24 {
		item, err := decodeTableStatsEntry(decoder)
		if err != nil {
			return nil, err
		}
		tablestatsreply.Entries = append(tablestatsreply.Entries, item)
	}
	return tablestatsreply, nil
}

func NewTableStatsReply() *TableStatsReply {
	return &TableStatsReply{
		StatsReply: NewStatsReply(3),
	}
}

type TableStatsRequest struct {
	*StatsRequest
}

func (self *TableStatsRequest) Serialize(encoder *goloxi.Encoder) error {
	if err := self.StatsRequest.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableStatsRequest(parent *StatsRequest, decoder *goloxi.Decoder) (*TableStatsRequest, error) {
	tablestatsrequest := &TableStatsRequest{StatsRequest: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("TableStatsRequest packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return tablestatsrequest, nil
}

func NewTableStatsRequest() *TableStatsRequest {
	return &TableStatsRequest{
		StatsRequest: NewStatsRequest(3),
	}
}

type TableStatus struct {
	*Header
	Role   uint32
	Reason TableReason
	Table  TableDesc
}

func (self *TableStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Header.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Role))
	encoder.PutUint8(uint8(self.Reason))
	encoder.Write(bytes.Repeat([]byte{0}, 7))
	if err := self.Table.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableStatus(parent *Header, decoder *goloxi.Decoder) (*TableStatus, error) {
	tablestatus := &TableStatus{Header: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("TableStatus packet too short: %d < 20", decoder.Length())
	}
	tablestatus.Role = uint32(decoder.ReadUint32())
	tablestatus.Reason = TableReason(decoder.ReadByte())
	decoder.Skip(7)
	if err := tablestatus.Table.Decode(decoder); err != nil {
		return nil, err
	}

	return tablestatus, nil
}

func NewTableStatus() *TableStatus {
	return &TableStatus{
		Header: NewHeader(31),
	}
}
