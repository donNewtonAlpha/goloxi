/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of14

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/skydive-project/goloxi"
)

type Instruction struct {
	Type uint16
	Len  uint16
}

type IInstruction interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *Instruction) GetType() uint16 {
	return self.Type
}

func (self *Instruction) GetLen() uint16 {
	return self.Len
}

func (self *Instruction) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeInstruction(decoder *goloxi.Decoder) (IInstruction, error) {
	instruction := &Instruction{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Instruction packet too short: %d < 4", decoder.Length())
	}
	instruction.Type = uint16(decoder.ReadUint16())
	instruction.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(instruction.Len), 2+2)

	switch instruction.Type {
	case 1:
		return decodeInstructionGotoTable(instruction, decoder)
	case 2:
		return decodeInstructionWriteMetadata(instruction, decoder)
	case 3:
		return decodeInstructionWriteActions(instruction, decoder)
	case 4:
		return decodeInstructionApplyActions(instruction, decoder)
	case 5:
		return decodeInstructionClearActions(instruction, decoder)
	case 6:
		return decodeInstructionMeter(instruction, decoder)
	case 65535:
		return decodeInstructionExperimenter(instruction, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Instruction'", instruction.Type)
	}
}

func NewInstruction(_type uint16) *Instruction {
	return &Instruction{
		Type: _type,
	}
}

type InstructionApplyActions struct {
	*Instruction
	Actions []IAction
}

func (self *InstructionApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionApplyActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionApplyActions, error) {
	instructionapplyactions := &InstructionApplyActions{Instruction: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		instructionapplyactions.Actions = append(instructionapplyactions.Actions, item)
	}
	return instructionapplyactions, nil
}

func NewInstructionApplyActions() *InstructionApplyActions {
	return &InstructionApplyActions{
		Instruction: NewInstruction(4),
	}
}

type InstructionExperimenter struct {
	*Instruction
	Experimenter uint32
}

type IInstructionExperimenter interface {
	IInstruction
	GetExperimenter() uint32
}

func (self *InstructionExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *InstructionExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeInstructionExperimenter(parent *Instruction, decoder *goloxi.Decoder) (IInstructionExperimenter, error) {
	instructionexperimenter := &InstructionExperimenter{Instruction: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionExperimenter packet too short: %d < 4", decoder.Length())
	}
	instructionexperimenter.Experimenter = uint32(decoder.ReadUint32())

	switch instructionexperimenter.Experimenter {
	case 6035143:
		return decodeInstructionBsn(instructionexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionExperimenter'", instructionexperimenter.Experimenter)
	}
}

func NewInstructionExperimenter(_experimenter uint32) *InstructionExperimenter {
	return &InstructionExperimenter{
		Experimenter: _experimenter,
		Instruction:  NewInstruction(65535),
	}
}

type InstructionBsn struct {
	*InstructionExperimenter
	Subtype uint32
}

type IInstructionBsn interface {
	IInstructionExperimenter
	GetSubtype() uint32
}

func (self *InstructionBsn) GetSubtype() uint32 {
	return self.Subtype
}

func (self *InstructionBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeInstructionBsn(parent *InstructionExperimenter, decoder *goloxi.Decoder) (IInstructionBsn, error) {
	instructionbsn := &InstructionBsn{InstructionExperimenter: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionBsn packet too short: %d < 4", decoder.Length())
	}
	instructionbsn.Subtype = uint32(decoder.ReadUint32())

	switch instructionbsn.Subtype {
	case 0:
		return decodeInstructionBsnDisableSrcMacCheck(instructionbsn, decoder)
	case 1:
		return decodeInstructionBsnArpOffload(instructionbsn, decoder)
	case 2:
		return decodeInstructionBsnDhcpOffload(instructionbsn, decoder)
	case 4:
		return decodeInstructionBsnPermit(instructionbsn, decoder)
	case 5:
		return decodeInstructionBsnDeny(instructionbsn, decoder)
	case 6:
		return decodeInstructionBsnPacketOfDeath(instructionbsn, decoder)
	case 7:
		return decodeInstructionBsnPrioritizePdus(instructionbsn, decoder)
	case 8:
		return decodeInstructionBsnRequireVlanXlate(instructionbsn, decoder)
	case 9:
		return decodeInstructionBsnDisableVlanCounters(instructionbsn, decoder)
	case 10:
		return decodeInstructionBsnSpanDestination(instructionbsn, decoder)
	case 11:
		return decodeInstructionBsnAutoNegotiation(instructionbsn, decoder)
	case 12:
		return decodeInstructionBsnInternalPriority(instructionbsn, decoder)
	case 13:
		return decodeInstructionBsnDisableL3(instructionbsn, decoder)
	case 14:
		return decodeInstructionBsnNdpOffload(instructionbsn, decoder)
	case 15:
		return decodeInstructionBsnHashSelect(instructionbsn, decoder)
	case 16:
		return decodeInstructionBsnDirectedBroadcast(instructionbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionBsn'", instructionbsn.Subtype)
	}
}

func NewInstructionBsn(_subtype uint32) *InstructionBsn {
	return &InstructionBsn{
		Subtype:                 _subtype,
		InstructionExperimenter: NewInstructionExperimenter(6035143),
	}
}

type InstructionBsnArpOffload struct {
	*InstructionBsn
}

func (self *InstructionBsnArpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnArpOffload(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnArpOffload, error) {
	instructionbsnarpoffload := &InstructionBsnArpOffload{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnArpOffload packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnarpoffload, nil
}

func NewInstructionBsnArpOffload() *InstructionBsnArpOffload {
	return &InstructionBsnArpOffload{
		InstructionBsn: NewInstructionBsn(1),
	}
}

type InstructionBsnAutoNegotiation struct {
	*InstructionBsn
}

func (self *InstructionBsnAutoNegotiation) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnAutoNegotiation(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnAutoNegotiation, error) {
	instructionbsnautonegotiation := &InstructionBsnAutoNegotiation{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnAutoNegotiation packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnautonegotiation, nil
}

func NewInstructionBsnAutoNegotiation() *InstructionBsnAutoNegotiation {
	return &InstructionBsnAutoNegotiation{
		InstructionBsn: NewInstructionBsn(11),
	}
}

type InstructionBsnDeny struct {
	*InstructionBsn
}

func (self *InstructionBsnDeny) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDeny(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDeny, error) {
	instructionbsndeny := &InstructionBsnDeny{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDeny packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndeny, nil
}

func NewInstructionBsnDeny() *InstructionBsnDeny {
	return &InstructionBsnDeny{
		InstructionBsn: NewInstructionBsn(5),
	}
}

type InstructionBsnDhcpOffload struct {
	*InstructionBsn
}

func (self *InstructionBsnDhcpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDhcpOffload(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDhcpOffload, error) {
	instructionbsndhcpoffload := &InstructionBsnDhcpOffload{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDhcpOffload packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndhcpoffload, nil
}

func NewInstructionBsnDhcpOffload() *InstructionBsnDhcpOffload {
	return &InstructionBsnDhcpOffload{
		InstructionBsn: NewInstructionBsn(2),
	}
}

type InstructionBsnDirectedBroadcast struct {
	*InstructionBsn
}

func (self *InstructionBsnDirectedBroadcast) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDirectedBroadcast(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDirectedBroadcast, error) {
	instructionbsndirectedbroadcast := &InstructionBsnDirectedBroadcast{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDirectedBroadcast packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndirectedbroadcast, nil
}

func NewInstructionBsnDirectedBroadcast() *InstructionBsnDirectedBroadcast {
	return &InstructionBsnDirectedBroadcast{
		InstructionBsn: NewInstructionBsn(16),
	}
}

type InstructionBsnDisableL3 struct {
	*InstructionBsn
}

func (self *InstructionBsnDisableL3) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDisableL3(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDisableL3, error) {
	instructionbsndisablel3 := &InstructionBsnDisableL3{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDisableL3 packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndisablel3, nil
}

func NewInstructionBsnDisableL3() *InstructionBsnDisableL3 {
	return &InstructionBsnDisableL3{
		InstructionBsn: NewInstructionBsn(13),
	}
}

type InstructionBsnDisableSrcMacCheck struct {
	*InstructionBsn
}

func (self *InstructionBsnDisableSrcMacCheck) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDisableSrcMacCheck(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDisableSrcMacCheck, error) {
	instructionbsndisablesrcmaccheck := &InstructionBsnDisableSrcMacCheck{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDisableSrcMacCheck packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndisablesrcmaccheck, nil
}

func NewInstructionBsnDisableSrcMacCheck() *InstructionBsnDisableSrcMacCheck {
	return &InstructionBsnDisableSrcMacCheck{
		InstructionBsn: NewInstructionBsn(0),
	}
}

type InstructionBsnDisableVlanCounters struct {
	*InstructionBsn
}

func (self *InstructionBsnDisableVlanCounters) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnDisableVlanCounters(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnDisableVlanCounters, error) {
	instructionbsndisablevlancounters := &InstructionBsnDisableVlanCounters{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnDisableVlanCounters packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsndisablevlancounters, nil
}

func NewInstructionBsnDisableVlanCounters() *InstructionBsnDisableVlanCounters {
	return &InstructionBsnDisableVlanCounters{
		InstructionBsn: NewInstructionBsn(9),
	}
}

type InstructionBsnHashSelect struct {
	*InstructionBsn
	Flags BsnHashSelectFlags
}

func (self *InstructionBsnHashSelect) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnHashSelect(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnHashSelect, error) {
	instructionbsnhashselect := &InstructionBsnHashSelect{InstructionBsn: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionBsnHashSelect packet too short: %d < 4", decoder.Length())
	}
	instructionbsnhashselect.Flags = BsnHashSelectFlags(decoder.ReadUint32())
	return instructionbsnhashselect, nil
}

func NewInstructionBsnHashSelect() *InstructionBsnHashSelect {
	return &InstructionBsnHashSelect{
		InstructionBsn: NewInstructionBsn(15),
	}
}

type InstructionBsnInternalPriority struct {
	*InstructionBsn
	Value uint32
}

func (self *InstructionBsnInternalPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnInternalPriority(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnInternalPriority, error) {
	instructionbsninternalpriority := &InstructionBsnInternalPriority{InstructionBsn: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionBsnInternalPriority packet too short: %d < 4", decoder.Length())
	}
	instructionbsninternalpriority.Value = uint32(decoder.ReadUint32())
	return instructionbsninternalpriority, nil
}

func NewInstructionBsnInternalPriority() *InstructionBsnInternalPriority {
	return &InstructionBsnInternalPriority{
		InstructionBsn: NewInstructionBsn(12),
	}
}

type InstructionBsnNdpOffload struct {
	*InstructionBsn
}

func (self *InstructionBsnNdpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnNdpOffload(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnNdpOffload, error) {
	instructionbsnndpoffload := &InstructionBsnNdpOffload{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnNdpOffload packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnndpoffload, nil
}

func NewInstructionBsnNdpOffload() *InstructionBsnNdpOffload {
	return &InstructionBsnNdpOffload{
		InstructionBsn: NewInstructionBsn(14),
	}
}

type InstructionBsnPacketOfDeath struct {
	*InstructionBsn
}

func (self *InstructionBsnPacketOfDeath) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnPacketOfDeath(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnPacketOfDeath, error) {
	instructionbsnpacketofdeath := &InstructionBsnPacketOfDeath{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnPacketOfDeath packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnpacketofdeath, nil
}

func NewInstructionBsnPacketOfDeath() *InstructionBsnPacketOfDeath {
	return &InstructionBsnPacketOfDeath{
		InstructionBsn: NewInstructionBsn(6),
	}
}

type InstructionBsnPermit struct {
	*InstructionBsn
}

func (self *InstructionBsnPermit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnPermit(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnPermit, error) {
	instructionbsnpermit := &InstructionBsnPermit{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnPermit packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnpermit, nil
}

func NewInstructionBsnPermit() *InstructionBsnPermit {
	return &InstructionBsnPermit{
		InstructionBsn: NewInstructionBsn(4),
	}
}

type InstructionBsnPrioritizePdus struct {
	*InstructionBsn
}

func (self *InstructionBsnPrioritizePdus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnPrioritizePdus(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnPrioritizePdus, error) {
	instructionbsnprioritizepdus := &InstructionBsnPrioritizePdus{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnPrioritizePdus packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnprioritizepdus, nil
}

func NewInstructionBsnPrioritizePdus() *InstructionBsnPrioritizePdus {
	return &InstructionBsnPrioritizePdus{
		InstructionBsn: NewInstructionBsn(7),
	}
}

type InstructionBsnRequireVlanXlate struct {
	*InstructionBsn
}

func (self *InstructionBsnRequireVlanXlate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnRequireVlanXlate(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnRequireVlanXlate, error) {
	instructionbsnrequirevlanxlate := &InstructionBsnRequireVlanXlate{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnRequireVlanXlate packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnrequirevlanxlate, nil
}

func NewInstructionBsnRequireVlanXlate() *InstructionBsnRequireVlanXlate {
	return &InstructionBsnRequireVlanXlate{
		InstructionBsn: NewInstructionBsn(8),
	}
}

type InstructionBsnSpanDestination struct {
	*InstructionBsn
}

func (self *InstructionBsnSpanDestination) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionBsnSpanDestination(parent *InstructionBsn, decoder *goloxi.Decoder) (*InstructionBsnSpanDestination, error) {
	instructionbsnspandestination := &InstructionBsnSpanDestination{InstructionBsn: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionBsnSpanDestination packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	return instructionbsnspandestination, nil
}

func NewInstructionBsnSpanDestination() *InstructionBsnSpanDestination {
	return &InstructionBsnSpanDestination{
		InstructionBsn: NewInstructionBsn(10),
	}
}

type InstructionClearActions struct {
	*Instruction
}

func (self *InstructionClearActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionClearActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionClearActions, error) {
	instructionclearactions := &InstructionClearActions{Instruction: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("InstructionClearActions packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	return instructionclearactions, nil
}

func NewInstructionClearActions() *InstructionClearActions {
	return &InstructionClearActions{
		Instruction: NewInstruction(5),
	}
}

type InstructionGotoTable struct {
	*Instruction
	TableId uint8
}

func (self *InstructionGotoTable) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionGotoTable(parent *Instruction, decoder *goloxi.Decoder) (*InstructionGotoTable, error) {
	instructiongototable := &InstructionGotoTable{Instruction: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionGotoTable packet too short: %d < 4", decoder.Length())
	}
	instructiongototable.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return instructiongototable, nil
}

func NewInstructionGotoTable() *InstructionGotoTable {
	return &InstructionGotoTable{
		Instruction: NewInstruction(1),
	}
}

type InstructionMeter struct {
	*Instruction
	MeterId uint32
}

func (self *InstructionMeter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.MeterId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionMeter(parent *Instruction, decoder *goloxi.Decoder) (*InstructionMeter, error) {
	instructionmeter := &InstructionMeter{Instruction: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionMeter packet too short: %d < 4", decoder.Length())
	}
	instructionmeter.MeterId = uint32(decoder.ReadUint32())
	return instructionmeter, nil
}

func NewInstructionMeter() *InstructionMeter {
	return &InstructionMeter{
		Instruction: NewInstruction(6),
	}
}

type InstructionWriteActions struct {
	*Instruction
	Actions []IAction
}

func (self *InstructionWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionWriteActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionWriteActions, error) {
	instructionwriteactions := &InstructionWriteActions{Instruction: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		instructionwriteactions.Actions = append(instructionwriteactions.Actions, item)
	}
	return instructionwriteactions, nil
}

func NewInstructionWriteActions() *InstructionWriteActions {
	return &InstructionWriteActions{
		Instruction: NewInstruction(3),
	}
}

type InstructionWriteMetadata struct {
	*Instruction
	Metadata     uint64
	MetadataMask uint64
}

func (self *InstructionWriteMetadata) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Metadata))
	encoder.PutUint64(uint64(self.MetadataMask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionWriteMetadata(parent *Instruction, decoder *goloxi.Decoder) (*InstructionWriteMetadata, error) {
	instructionwritemetadata := &InstructionWriteMetadata{Instruction: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionWriteMetadata packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	instructionwritemetadata.Metadata = uint64(decoder.ReadUint64())
	instructionwritemetadata.MetadataMask = uint64(decoder.ReadUint64())
	return instructionwritemetadata, nil
}

func NewInstructionWriteMetadata() *InstructionWriteMetadata {
	return &InstructionWriteMetadata{
		Instruction: NewInstruction(2),
	}
}
