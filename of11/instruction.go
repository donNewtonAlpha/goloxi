/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of11

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/skydive-project/goloxi"
)

type Instruction struct {
	Type uint16
	Len  uint16
}

type IInstruction interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *Instruction) GetType() uint16 {
	return self.Type
}

func (self *Instruction) GetLen() uint16 {
	return self.Len
}

func (self *Instruction) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeInstruction(decoder *goloxi.Decoder) (IInstruction, error) {
	instruction := &Instruction{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Instruction packet too short: %d < 4", decoder.Length())
	}
	instruction.Type = uint16(decoder.ReadUint16())
	instruction.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(instruction.Len), 2+2)

	switch instruction.Type {
	case 1:
		return decodeInstructionGotoTable(instruction, decoder)
	case 2:
		return decodeInstructionWriteMetadata(instruction, decoder)
	case 3:
		return decodeInstructionWriteActions(instruction, decoder)
	case 4:
		return decodeInstructionApplyActions(instruction, decoder)
	case 5:
		return decodeInstructionClearActions(instruction, decoder)
	case 65535:
		return decodeInstructionExperimenter(instruction, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'Instruction'", instruction.Type)
	}
}

func NewInstruction(_type uint16) *Instruction {
	return &Instruction{
		Type: _type,
	}
}

type InstructionApplyActions struct {
	*Instruction
	Actions []IAction
}

func (self *InstructionApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionApplyActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionApplyActions, error) {
	instructionapplyactions := &InstructionApplyActions{Instruction: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		instructionapplyactions.Actions = append(instructionapplyactions.Actions, item)
	}
	return instructionapplyactions, nil
}

func NewInstructionApplyActions() *InstructionApplyActions {
	return &InstructionApplyActions{
		Instruction: NewInstruction(4),
	}
}

type InstructionClearActions struct {
	*Instruction
}

func (self *InstructionClearActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionClearActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionClearActions, error) {
	instructionclearactions := &InstructionClearActions{Instruction: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("InstructionClearActions packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	return instructionclearactions, nil
}

func NewInstructionClearActions() *InstructionClearActions {
	return &InstructionClearActions{
		Instruction: NewInstruction(5),
	}
}

type InstructionExperimenter struct {
	*Instruction
	Experimenter uint32
}

type IInstructionExperimenter interface {
	IInstruction
	GetExperimenter() uint32
}

func (self *InstructionExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *InstructionExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeInstructionExperimenter(parent *Instruction, decoder *goloxi.Decoder) (IInstructionExperimenter, error) {
	instructionexperimenter := &InstructionExperimenter{Instruction: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionExperimenter packet too short: %d < 4", decoder.Length())
	}
	instructionexperimenter.Experimenter = uint32(decoder.ReadUint32())
	return instructionexperimenter, nil
}

func NewInstructionExperimenter(_experimenter uint32) *InstructionExperimenter {
	return &InstructionExperimenter{
		Experimenter: _experimenter,
		Instruction:  NewInstruction(65535),
	}
}

type InstructionGotoTable struct {
	*Instruction
	TableId uint8
}

func (self *InstructionGotoTable) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionGotoTable(parent *Instruction, decoder *goloxi.Decoder) (*InstructionGotoTable, error) {
	instructiongototable := &InstructionGotoTable{Instruction: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionGotoTable packet too short: %d < 4", decoder.Length())
	}
	instructiongototable.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return instructiongototable, nil
}

func NewInstructionGotoTable() *InstructionGotoTable {
	return &InstructionGotoTable{
		Instruction: NewInstruction(1),
	}
}

type InstructionWriteActions struct {
	*Instruction
	Actions []IAction
}

func (self *InstructionWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionWriteActions(parent *Instruction, decoder *goloxi.Decoder) (*InstructionWriteActions, error) {
	instructionwriteactions := &InstructionWriteActions{Instruction: parent}
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		instructionwriteactions.Actions = append(instructionwriteactions.Actions, item)
	}
	return instructionwriteactions, nil
}

func NewInstructionWriteActions() *InstructionWriteActions {
	return &InstructionWriteActions{
		Instruction: NewInstruction(3),
	}
}

type InstructionWriteMetadata struct {
	*Instruction
	Metadata     uint64
	MetadataMask uint64
}

func (self *InstructionWriteMetadata) Serialize(encoder *goloxi.Encoder) error {
	if err := self.Instruction.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Metadata))
	encoder.PutUint64(uint64(self.MetadataMask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionWriteMetadata(parent *Instruction, decoder *goloxi.Decoder) (*InstructionWriteMetadata, error) {
	instructionwritemetadata := &InstructionWriteMetadata{Instruction: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("InstructionWriteMetadata packet too short: %d < 16", decoder.Length())
	}
	decoder.Skip(4)
	instructionwritemetadata.Metadata = uint64(decoder.ReadUint64())
	instructionwritemetadata.MetadataMask = uint64(decoder.ReadUint64())
	return instructionwritemetadata, nil
}

func NewInstructionWriteMetadata() *InstructionWriteMetadata {
	return &InstructionWriteMetadata{
		Instruction: NewInstruction(2),
	}
}
