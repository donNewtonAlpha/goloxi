/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of12

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func DecodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	_bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	_bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	_bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	_bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	_bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return _bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	obj := &BsnInterface{}
	return obj
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	obj := &BsnVport{}
	obj.Type = _type
	return obj
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	_bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 60 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 60", decoder.Length())
	}
	_bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	_bsnvportl2gre.PortNo.Decode(decoder)
	_bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	_bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	_bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	_bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	_bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	_bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	_bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	_bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	obj := &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
	return obj
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	_bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	_bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	_bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	_bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	_bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return _bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	obj := &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
	return obj
}

type Bucket struct {
	Len        uint16
	Weight     uint16
	WatchPort  PortNo
	WatchGroup uint32
	Actions    []IAction
}

func (self *Bucket) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Len))
	encoder.PutUint16(uint16(self.Weight))
	self.WatchPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.WatchGroup))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeBucket(decoder *goloxi.Decoder) (*Bucket, error) {
	_bucket := &Bucket{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("Bucket packet too short: %d < 16", decoder.Length())
	}
	_bucket.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_bucket.Len), 2+0)
	_bucket.Weight = uint16(decoder.ReadUint16())
	_bucket.WatchPort.Decode(decoder)
	_bucket.WatchGroup = uint32(decoder.ReadUint32())
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_bucket.Actions = append(_bucket.Actions, item)
	}
	return _bucket, nil
}

func NewBucket() *Bucket {
	obj := &Bucket{}
	return obj
}

type BucketCounter struct {
	PacketCount uint64
	ByteCount   uint64
}

func (self *BucketCounter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))

	return nil
}

func DecodeBucketCounter(decoder *goloxi.Decoder) (*BucketCounter, error) {
	_bucketcounter := &BucketCounter{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BucketCounter packet too short: %d < 16", decoder.Length())
	}
	_bucketcounter.PacketCount = uint64(decoder.ReadUint64())
	_bucketcounter.ByteCount = uint64(decoder.ReadUint64())
	return _bucketcounter, nil
}

func NewBucketCounter() *BucketCounter {
	obj := &BucketCounter{}
	return obj
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	_flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 56", decoder.Length())
	}
	_flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_flowstatsentry.Length), 2+0)
	_flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_flowstatsentry.DurationSec = uint32(decoder.ReadUint32())
	_flowstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	_flowstatsentry.Priority = uint16(decoder.ReadUint16())
	_flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	_flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	_flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	_flowstatsentry.PacketCount = uint64(decoder.ReadUint64())
	_flowstatsentry.ByteCount = uint64(decoder.ReadUint64())
	if err := _flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		_flowstatsentry.Instructions = append(_flowstatsentry.Instructions, item)
	}
	return _flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	obj := &FlowStatsEntry{}
	return obj
}

type GroupDescStatsEntry struct {
	Length    uint16
	GroupType GroupType
	GroupId   uint32
	Buckets   []*Bucket
}

func (self *GroupDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.GroupType))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.GroupId))
	for _, obj := range self.Buckets {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeGroupDescStatsEntry(decoder *goloxi.Decoder) (*GroupDescStatsEntry, error) {
	_groupdescstatsentry := &GroupDescStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupDescStatsEntry packet too short: %d < 8", decoder.Length())
	}
	_groupdescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_groupdescstatsentry.Length), 2+0)
	_groupdescstatsentry.GroupType = GroupType(decoder.ReadByte())
	decoder.Skip(1)
	_groupdescstatsentry.GroupId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := DecodeBucket(decoder)
		if err != nil {
			return nil, err
		}
		_groupdescstatsentry.Buckets = append(_groupdescstatsentry.Buckets, item)
	}
	return _groupdescstatsentry, nil
}

func NewGroupDescStatsEntry() *GroupDescStatsEntry {
	obj := &GroupDescStatsEntry{}
	return obj
}

type GroupStatsEntry struct {
	Length      uint16
	GroupId     uint32
	RefCount    uint32
	PacketCount uint64
	ByteCount   uint64
	BucketStats []*BucketCounter
}

func (self *GroupStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.PutUint32(uint32(self.RefCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	for _, obj := range self.BucketStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeGroupStatsEntry(decoder *goloxi.Decoder) (*GroupStatsEntry, error) {
	_groupstatsentry := &GroupStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("GroupStatsEntry packet too short: %d < 32", decoder.Length())
	}
	_groupstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_groupstatsentry.Length), 2+0)
	decoder.Skip(2)
	_groupstatsentry.GroupId = uint32(decoder.ReadUint32())
	_groupstatsentry.RefCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	_groupstatsentry.PacketCount = uint64(decoder.ReadUint64())
	_groupstatsentry.ByteCount = uint64(decoder.ReadUint64())

	for decoder.Length() >= 16 {
		item, err := DecodeBucketCounter(decoder)
		if err != nil {
			return nil, err
		}
		_groupstatsentry.BucketStats = append(_groupstatsentry.BucketStats, item)
	}
	return _groupstatsentry, nil
}

func NewGroupStatsEntry() *GroupStatsEntry {
	obj := &GroupStatsEntry{}
	return obj
}

type MatchV3 struct {
	Type    uint16
	Length  uint16
	OxmList []IOxm
}

func (self *MatchV3) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.OxmList {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}
func (self *MatchV3) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("MatchV3 packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	// if self.Type != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", self.Type)
	// }
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	for decoder.Length() >= 4 {
		item, err := DecodeOxm(decoder)
		if err != nil {
			return err
		}
		self.OxmList = append(self.OxmList, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewMatchV3() *MatchV3 {
	obj := &MatchV3{}
	return obj
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	encoder.SkipAlign()

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := DecodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	obj := &NiciraMatch{}
	return obj
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	_niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	_niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowstats.Length), 2+0)
	_niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	_niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	_niciraflowstats.Priority = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	_niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	_niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	_niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	_niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := _niciraflowstats.Match.Decode(decoder.SliceDecoder(int(_niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowstats.Actions = append(_niciraflowstats.Actions, item)
	}
	return _niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	obj := &NiciraFlowStats{}
	return obj
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func DecodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	_niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	_niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_niciraflowupdateevent.Length), 2+0)
	_niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch _niciraflowupdateevent.Event {
	case 0:
		return DecodeNiciraFlowUpdateFullAdd(_niciraflowupdateevent, decoder)
	case 1:
		return DecodeNiciraFlowUpdateFullDeleted(_niciraflowupdateevent, decoder)
	case 2:
		return DecodeNiciraFlowUpdateFullModified(_niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", _niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	obj := &NiciraFlowUpdateEvent{}
	obj.Event = _event
	return obj
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	_niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulladd.Actions = append(_niciraflowupdatefulladd.Actions, item)
	}
	return _niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	obj := &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
	return obj
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	_niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefulldeleted.Actions = append(_niciraflowupdatefulldeleted.Actions, item)
	}
	return _niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	obj := &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
	return obj
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	_niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	_niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	_niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	_niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := _niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(_niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := DecodeAction(decoder)
		if err != nil {
			return nil, err
		}
		_niciraflowupdatefullmodified.Actions = append(_niciraflowupdatefullmodified.Actions, item)
	}
	return _niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	obj := &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
	return obj
}

type PacketQueue struct {
	QueueId    uint32
	Port       PortNo
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	self.Port.Serialize(encoder)
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func DecodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	_packetqueue := &PacketQueue{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 16", decoder.Length())
	}
	_packetqueue.QueueId = uint32(decoder.ReadUint32())
	_packetqueue.Port.Decode(decoder)
	_packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_packetqueue.Len), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := DecodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		_packetqueue.Properties = append(_packetqueue.Properties, item)
	}
	return _packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	obj := &PacketQueue{}
	return obj
}

type PortDesc struct {
	PortNo     PortNo
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Curr       PortFeatures
	Advertised PortFeatures
	Supported  PortFeatures
	Peer       PortFeatures
	CurrSpeed  uint32
	MaxSpeed   uint32
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))
	encoder.PutUint32(uint32(self.CurrSpeed))
	encoder.PutUint32(uint32(self.MaxSpeed))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 64 {
		return fmt.Errorf("PortDesc packet too short: %d < 64", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	decoder.Skip(4)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())
	self.Curr = PortFeatures(decoder.ReadUint32())
	self.Advertised = PortFeatures(decoder.ReadUint32())
	self.Supported = PortFeatures(decoder.ReadUint32())
	self.Peer = PortFeatures(decoder.ReadUint32())
	self.CurrSpeed = uint32(decoder.ReadUint32())
	self.MaxSpeed = uint32(decoder.ReadUint32())

	return nil
}

func NewPortDesc() *PortDesc {
	obj := &PortDesc{}
	return obj
}

type PortStatsEntry struct {
	PortNo     PortNo
	RxPackets  uint64
	TxPackets  uint64
	RxBytes    uint64
	TxBytes    uint64
	RxDropped  uint64
	TxDropped  uint64
	RxErrors   uint64
	TxErrors   uint64
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	return nil
}

func DecodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	_portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 104 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 104", decoder.Length())
	}
	_portstatsentry.PortNo.Decode(decoder)
	decoder.Skip(4)
	_portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	_portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	_portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	_portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	_portstatsentry.TxErrors = uint64(decoder.ReadUint64())
	_portstatsentry.RxFrameErr = uint64(decoder.ReadUint64())
	_portstatsentry.RxOverErr = uint64(decoder.ReadUint64())
	_portstatsentry.RxCrcErr = uint64(decoder.ReadUint64())
	_portstatsentry.Collisions = uint64(decoder.ReadUint64())
	return _portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	obj := &PortStatsEntry{}
	return obj
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func DecodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	_queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	_queueprop.Type = uint16(decoder.ReadUint16())
	_queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(_queueprop.Len), 2+2)

	switch _queueprop.Type {
	case 1:
		return DecodeQueuePropMinRate(_queueprop, decoder)
	case 2:
		return DecodeQueuePropMaxRate(_queueprop, decoder)
	case 65535:
		return DecodeQueuePropExperimenter(_queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", _queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	obj := &QueueProp{}
	obj.Type = _type
	return obj
}

type QueuePropExperimenter struct {
	*QueueProp
	Experimenter uint32
}

type IQueuePropExperimenter interface {
	IQueueProp
	GetExperimenter() uint32
}

func (self *QueuePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueuePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func DecodeQueuePropExperimenter(parent *QueueProp, decoder *goloxi.Decoder) (IQueuePropExperimenter, error) {
	_queuepropexperimenter := &QueuePropExperimenter{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return _queuepropexperimenter, nil
}

func NewQueuePropExperimenter(_experimenter uint32) *QueuePropExperimenter {
	obj := &QueuePropExperimenter{
		QueueProp: NewQueueProp(65535),
	}
	obj.Experimenter = _experimenter
	return obj
}

type QueuePropMaxRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueuePropMaxRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMaxRate, error) {
	_queuepropmaxrate := &QueuePropMaxRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMaxRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return _queuepropmaxrate, nil
}

func NewQueuePropMaxRate() *QueuePropMaxRate {
	obj := &QueuePropMaxRate{
		QueueProp: NewQueueProp(2),
	}
	return obj
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func DecodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	_queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	_queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return _queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	obj := &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
	return obj
}

type QueueStatsEntry struct {
	PortNo    PortNo
	QueueId   uint32
	TxBytes   uint64
	TxPackets uint64
	TxErrors  uint64
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))

	return nil
}

func DecodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	_queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 32", decoder.Length())
	}
	_queuestatsentry.PortNo.Decode(decoder)
	_queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	_queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	_queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	_queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	return _queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	obj := &QueueStatsEntry{}
	return obj
}

type TableStatsEntry struct {
	TableId        uint8
	Name           string
	Match          MatchBmap
	Wildcards      WcBmap
	WriteActions   uint32
	ApplyActions   uint32
	WriteSetfields uint64
	ApplySetfields uint64
	MetadataMatch  uint64
	MetadataWrite  uint64
	Instructions   uint32
	Config         uint32
	MaxEntries     uint32
	ActiveCount    uint32
	LookupCount    uint64
	MatchedCount   uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 7))
	encoder.Write([]byte(self.Name))
	self.Match.Serialize(encoder)
	self.Wildcards.Serialize(encoder)
	encoder.PutUint32(uint32(self.WriteActions))
	encoder.PutUint32(uint32(self.ApplyActions))
	encoder.PutUint64(uint64(self.WriteSetfields))
	encoder.PutUint64(uint64(self.ApplySetfields))
	encoder.PutUint64(uint64(self.MetadataMatch))
	encoder.PutUint64(uint64(self.MetadataWrite))
	encoder.PutUint32(uint32(self.Instructions))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func DecodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	_tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 128 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 128", decoder.Length())
	}
	_tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(7)
	_tablestatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	_tablestatsentry.Match.Decode(decoder)
	_tablestatsentry.Wildcards.Decode(decoder)
	_tablestatsentry.WriteActions = uint32(decoder.ReadUint32())
	_tablestatsentry.ApplyActions = uint32(decoder.ReadUint32())
	_tablestatsentry.WriteSetfields = uint64(decoder.ReadUint64())
	_tablestatsentry.ApplySetfields = uint64(decoder.ReadUint64())
	_tablestatsentry.MetadataMatch = uint64(decoder.ReadUint64())
	_tablestatsentry.MetadataWrite = uint64(decoder.ReadUint64())
	_tablestatsentry.Instructions = uint32(decoder.ReadUint32())
	_tablestatsentry.Config = uint32(decoder.ReadUint32())
	_tablestatsentry.MaxEntries = uint32(decoder.ReadUint32())
	_tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	_tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	_tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return _tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	obj := &TableStatsEntry{}
	return obj
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	obj := &EdPropHeader{}
	obj.PropClass = _prop_class
	return obj
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func DecodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	_edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	_edpropnsh.Type = uint8(decoder.ReadByte())
	_edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(_edpropnsh.Len), 1+3)

	switch _edpropnsh.Type {
	case 1:
		return DecodeEdPropNshMdType(_edpropnsh, decoder)
	case 2:
		return DecodeEdPropNshTlv(_edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", _edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	obj := &EdPropNsh{
		EdPropHeader: NewEdPropHeader(4),
	}
	obj.Type = _type
	return obj
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	_edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	_edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return _edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	obj := &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
	return obj
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func DecodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	_edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	_edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	_edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	_edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return _edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	obj := &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
	return obj
}
