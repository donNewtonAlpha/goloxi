/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of12

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func decodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	return &BsnInterface{}
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	return &BsnVport{
		Type: _type,
	}
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 60 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 60", decoder.Length())
	}
	bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	bsnvportl2gre.PortNo.Decode(decoder)
	bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	return &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	return &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
}

type Bucket struct {
	Len        uint16
	Weight     uint16
	WatchPort  PortNo
	WatchGroup uint32
	Actions    []IAction
}

func (self *Bucket) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Len))
	encoder.PutUint16(uint16(self.Weight))
	self.WatchPort.Serialize(encoder)
	encoder.PutUint32(uint32(self.WatchGroup))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBucket(decoder *goloxi.Decoder) (*Bucket, error) {
	bucket := &Bucket{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("Bucket packet too short: %d < 16", decoder.Length())
	}
	bucket.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bucket.Len), 2+0)
	bucket.Weight = uint16(decoder.ReadUint16())
	bucket.WatchPort.Decode(decoder)
	bucket.WatchGroup = uint32(decoder.ReadUint32())
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		bucket.Actions = append(bucket.Actions, item)
	}
	return bucket, nil
}

func NewBucket() *Bucket {
	return &Bucket{}
}

type BucketCounter struct {
	PacketCount uint64
	ByteCount   uint64
}

func (self *BucketCounter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))

	return nil
}

func decodeBucketCounter(decoder *goloxi.Decoder) (*BucketCounter, error) {
	bucketcounter := &BucketCounter{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BucketCounter packet too short: %d < 16", decoder.Length())
	}
	bucketcounter.PacketCount = uint64(decoder.ReadUint64())
	bucketcounter.ByteCount = uint64(decoder.ReadUint64())
	return bucketcounter, nil
}

func NewBucketCounter() *BucketCounter {
	return &BucketCounter{}
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        Match
	Instructions []IInstruction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 56 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 56", decoder.Length())
	}
	flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(flowstatsentry.Length), 2+0)
	flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	flowstatsentry.DurationSec = uint32(decoder.ReadUint32())
	flowstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	flowstatsentry.Priority = uint16(decoder.ReadUint16())
	flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	flowstatsentry.PacketCount = uint64(decoder.ReadUint64())
	flowstatsentry.ByteCount = uint64(decoder.ReadUint64())
	if err := flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		flowstatsentry.Instructions = append(flowstatsentry.Instructions, item)
	}
	return flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	return &FlowStatsEntry{}
}

type GroupDescStatsEntry struct {
	Length    uint16
	GroupType GroupType
	GroupId   uint32
	Buckets   []*Bucket
}

func (self *GroupDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.GroupType))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.GroupId))
	for _, obj := range self.Buckets {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupDescStatsEntry(decoder *goloxi.Decoder) (*GroupDescStatsEntry, error) {
	groupdescstatsentry := &GroupDescStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupDescStatsEntry packet too short: %d < 8", decoder.Length())
	}
	groupdescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupdescstatsentry.Length), 2+0)
	groupdescstatsentry.GroupType = GroupType(decoder.ReadByte())
	decoder.Skip(1)
	groupdescstatsentry.GroupId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := decodeBucket(decoder)
		if err != nil {
			return nil, err
		}
		groupdescstatsentry.Buckets = append(groupdescstatsentry.Buckets, item)
	}
	return groupdescstatsentry, nil
}

func NewGroupDescStatsEntry() *GroupDescStatsEntry {
	return &GroupDescStatsEntry{}
}

type GroupStatsEntry struct {
	Length      uint16
	GroupId     uint32
	RefCount    uint32
	PacketCount uint64
	ByteCount   uint64
	BucketStats []*BucketCounter
}

func (self *GroupStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.PutUint32(uint32(self.RefCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	for _, obj := range self.BucketStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupStatsEntry(decoder *goloxi.Decoder) (*GroupStatsEntry, error) {
	groupstatsentry := &GroupStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("GroupStatsEntry packet too short: %d < 32", decoder.Length())
	}
	groupstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupstatsentry.Length), 2+0)
	decoder.Skip(2)
	groupstatsentry.GroupId = uint32(decoder.ReadUint32())
	groupstatsentry.RefCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	groupstatsentry.PacketCount = uint64(decoder.ReadUint64())
	groupstatsentry.ByteCount = uint64(decoder.ReadUint64())

	for decoder.Length() >= 16 {
		item, err := decodeBucketCounter(decoder)
		if err != nil {
			return nil, err
		}
		groupstatsentry.BucketStats = append(groupstatsentry.BucketStats, item)
	}
	return groupstatsentry, nil
}

func NewGroupStatsEntry() *GroupStatsEntry {
	return &GroupStatsEntry{}
}

type MatchV3 struct {
	Type    uint16
	Length  uint16
	OxmList []IOxm
}

func (self *MatchV3) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.OxmList {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}
func (self *MatchV3) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("MatchV3 packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	// if self.Type != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", self.Type)
	// }
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return err
		}
		self.OxmList = append(self.OxmList, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewMatchV3() *MatchV3 {
	return &MatchV3{}
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	return &NiciraMatch{}
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowstats.Length), 2+0)
	niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	niciraflowstats.Priority = uint16(decoder.ReadUint16())
	niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := niciraflowstats.Match.Decode(decoder.SliceDecoder(int(niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowstats.Actions = append(niciraflowstats.Actions, item)
	}
	return niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	return &NiciraFlowStats{}
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func decodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowupdateevent.Length), 2+0)
	niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch niciraflowupdateevent.Event {
	case 0:
		return decodeNiciraFlowUpdateFullAdd(niciraflowupdateevent, decoder)
	case 1:
		return decodeNiciraFlowUpdateFullDeleted(niciraflowupdateevent, decoder)
	case 2:
		return decodeNiciraFlowUpdateFullModified(niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	return &NiciraFlowUpdateEvent{
		Event: _event,
	}
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulladd.Actions = append(niciraflowupdatefulladd.Actions, item)
	}
	return niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	return &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulldeleted.Actions = append(niciraflowupdatefulldeleted.Actions, item)
	}
	return niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	return &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 8 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefullmodified.Actions = append(niciraflowupdatefullmodified.Actions, item)
	}
	return niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	return &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
}

type PacketQueue struct {
	QueueId    uint32
	Port       PortNo
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	self.Port.Serialize(encoder)
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	packetqueue := &PacketQueue{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 16", decoder.Length())
	}
	packetqueue.QueueId = uint32(decoder.ReadUint32())
	packetqueue.Port.Decode(decoder)
	packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(packetqueue.Len), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := decodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		packetqueue.Properties = append(packetqueue.Properties, item)
	}
	return packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	return &PacketQueue{}
}

type PortDesc struct {
	PortNo     PortNo
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Curr       PortFeatures
	Advertised PortFeatures
	Supported  PortFeatures
	Peer       PortFeatures
	CurrSpeed  uint32
	MaxSpeed   uint32
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))
	encoder.PutUint32(uint32(self.CurrSpeed))
	encoder.PutUint32(uint32(self.MaxSpeed))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 64 {
		return fmt.Errorf("PortDesc packet too short: %d < 64", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	decoder.Skip(4)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())
	self.Curr = PortFeatures(decoder.ReadUint32())
	self.Advertised = PortFeatures(decoder.ReadUint32())
	self.Supported = PortFeatures(decoder.ReadUint32())
	self.Peer = PortFeatures(decoder.ReadUint32())
	self.CurrSpeed = uint32(decoder.ReadUint32())
	self.MaxSpeed = uint32(decoder.ReadUint32())

	return nil
}

func NewPortDesc() *PortDesc {
	return &PortDesc{}
}

type PortStatsEntry struct {
	PortNo     PortNo
	RxPackets  uint64
	TxPackets  uint64
	RxBytes    uint64
	TxBytes    uint64
	RxDropped  uint64
	TxDropped  uint64
	RxErrors   uint64
	TxErrors   uint64
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	return nil
}

func decodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 104 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 104", decoder.Length())
	}
	portstatsentry.PortNo.Decode(decoder)
	decoder.Skip(4)
	portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	portstatsentry.TxErrors = uint64(decoder.ReadUint64())
	portstatsentry.RxFrameErr = uint64(decoder.ReadUint64())
	portstatsentry.RxOverErr = uint64(decoder.ReadUint64())
	portstatsentry.RxCrcErr = uint64(decoder.ReadUint64())
	portstatsentry.Collisions = uint64(decoder.ReadUint64())
	return portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	return &PortStatsEntry{}
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	queueprop.Type = uint16(decoder.ReadUint16())
	queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queueprop.Len), 2+2)

	switch queueprop.Type {
	case 1:
		return decodeQueuePropMinRate(queueprop, decoder)
	case 2:
		return decodeQueuePropMaxRate(queueprop, decoder)
	case 65535:
		return decodeQueuePropExperimenter(queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	return &QueueProp{
		Type: _type,
	}
}

type QueuePropExperimenter struct {
	*QueueProp
	Experimenter uint32
}

type IQueuePropExperimenter interface {
	IQueueProp
	GetExperimenter() uint32
}

func (self *QueuePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueuePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func decodeQueuePropExperimenter(parent *QueueProp, decoder *goloxi.Decoder) (IQueuePropExperimenter, error) {
	queuepropexperimenter := &QueuePropExperimenter{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return queuepropexperimenter, nil
}

func NewQueuePropExperimenter(_experimenter uint32) *QueuePropExperimenter {
	return &QueuePropExperimenter{
		Experimenter: _experimenter,
		QueueProp:    NewQueueProp(65535),
	}
}

type QueuePropMaxRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueuePropMaxRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMaxRate, error) {
	queuepropmaxrate := &QueuePropMaxRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMaxRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return queuepropmaxrate, nil
}

func NewQueuePropMaxRate() *QueuePropMaxRate {
	return &QueuePropMaxRate{
		QueueProp: NewQueueProp(2),
	}
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	return &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
}

type QueueStatsEntry struct {
	PortNo    PortNo
	QueueId   uint32
	TxBytes   uint64
	TxPackets uint64
	TxErrors  uint64
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))

	return nil
}

func decodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 32", decoder.Length())
	}
	queuestatsentry.PortNo.Decode(decoder)
	queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	return queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	return &QueueStatsEntry{}
}

type TableStatsEntry struct {
	TableId        uint8
	Name           string
	Match          MatchBmap
	Wildcards      WcBmap
	WriteActions   uint32
	ApplyActions   uint32
	WriteSetfields uint64
	ApplySetfields uint64
	MetadataMatch  uint64
	MetadataWrite  uint64
	Instructions   uint32
	Config         uint32
	MaxEntries     uint32
	ActiveCount    uint32
	LookupCount    uint64
	MatchedCount   uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 7))
	encoder.Write([]byte(self.Name))
	self.Match.Serialize(encoder)
	self.Wildcards.Serialize(encoder)
	encoder.PutUint32(uint32(self.WriteActions))
	encoder.PutUint32(uint32(self.ApplyActions))
	encoder.PutUint64(uint64(self.WriteSetfields))
	encoder.PutUint64(uint64(self.ApplySetfields))
	encoder.PutUint64(uint64(self.MetadataMatch))
	encoder.PutUint64(uint64(self.MetadataWrite))
	encoder.PutUint32(uint32(self.Instructions))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func decodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 128 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 128", decoder.Length())
	}
	tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(7)
	tablestatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	tablestatsentry.Match.Decode(decoder)
	tablestatsentry.Wildcards.Decode(decoder)
	tablestatsentry.WriteActions = uint32(decoder.ReadUint32())
	tablestatsentry.ApplyActions = uint32(decoder.ReadUint32())
	tablestatsentry.WriteSetfields = uint64(decoder.ReadUint64())
	tablestatsentry.ApplySetfields = uint64(decoder.ReadUint64())
	tablestatsentry.MetadataMatch = uint64(decoder.ReadUint64())
	tablestatsentry.MetadataWrite = uint64(decoder.ReadUint64())
	tablestatsentry.Instructions = uint32(decoder.ReadUint32())
	tablestatsentry.Config = uint32(decoder.ReadUint32())
	tablestatsentry.MaxEntries = uint32(decoder.ReadUint32())
	tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	return &TableStatsEntry{}
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	return &EdPropHeader{
		PropClass: _prop_class,
	}
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func decodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	edpropnsh.Type = uint8(decoder.ReadByte())
	edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(edpropnsh.Len), 1+3)

	switch edpropnsh.Type {
	case 1:
		return decodeEdPropNshMdType(edpropnsh, decoder)
	case 2:
		return decodeEdPropNshTlv(edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	return &EdPropNsh{
		Type:         _type,
		EdPropHeader: NewEdPropHeader(4),
	}
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	return &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	return &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
}
