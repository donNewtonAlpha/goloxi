/*
 * Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
 * Copyright (c) 2011, 2012 Open Networking Foundation
 * Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler.
 * Copyright 2018, Red Hat, Inc.
 */
// Automatically generated by LOXI from template module.go
// Do not modify

package of15

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/skydive-project/goloxi"
)

type AsyncConfigProp struct {
	Type   uint16
	Length uint16
}

type IAsyncConfigProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *AsyncConfigProp) GetType() uint16 {
	return self.Type
}

func (self *AsyncConfigProp) GetLength() uint16 {
	return self.Length
}

func (self *AsyncConfigProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeAsyncConfigProp(decoder *goloxi.Decoder) (IAsyncConfigProp, error) {
	asyncconfigprop := &AsyncConfigProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigProp packet too short: %d < 4", decoder.Length())
	}
	asyncconfigprop.Type = uint16(decoder.ReadUint16())
	asyncconfigprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(asyncconfigprop.Length), 2+2)

	switch asyncconfigprop.Type {
	case 0:
		return decodeAsyncConfigPropPacketInSlave(asyncconfigprop, decoder)
	case 1:
		return decodeAsyncConfigPropPacketInMaster(asyncconfigprop, decoder)
	case 2:
		return decodeAsyncConfigPropPortStatusSlave(asyncconfigprop, decoder)
	case 3:
		return decodeAsyncConfigPropPortStatusMaster(asyncconfigprop, decoder)
	case 4:
		return decodeAsyncConfigPropFlowRemovedSlave(asyncconfigprop, decoder)
	case 5:
		return decodeAsyncConfigPropFlowRemovedMaster(asyncconfigprop, decoder)
	case 6:
		return decodeAsyncConfigPropRoleStatusSlave(asyncconfigprop, decoder)
	case 7:
		return decodeAsyncConfigPropRoleStatusMaster(asyncconfigprop, decoder)
	case 8:
		return decodeAsyncConfigPropTableStatusSlave(asyncconfigprop, decoder)
	case 9:
		return decodeAsyncConfigPropTableStatusMaster(asyncconfigprop, decoder)
	case 10:
		return decodeAsyncConfigPropRequestforwardSlave(asyncconfigprop, decoder)
	case 11:
		return decodeAsyncConfigPropRequestforwardMaster(asyncconfigprop, decoder)
	case 12:
		return decodeAsyncConfigPropFlowStatsSlave(asyncconfigprop, decoder)
	case 13:
		return decodeAsyncConfigPropFlowStatsMaster(asyncconfigprop, decoder)
	case 14:
		return decodeAsyncConfigPropContStatusSlave(asyncconfigprop, decoder)
	case 15:
		return decodeAsyncConfigPropContStatusMaster(asyncconfigprop, decoder)
	case 65534:
		return decodeAsyncConfigPropExperimenterSlave(asyncconfigprop, decoder)
	case 65535:
		return decodeAsyncConfigPropExperimenterMaster(asyncconfigprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'AsyncConfigProp'", asyncconfigprop.Type)
	}
}

func NewAsyncConfigProp(_type uint16) *AsyncConfigProp {
	return &AsyncConfigProp{
		Type: _type,
	}
}

type AsyncConfigPropContStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropContStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropContStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropContStatusMaster, error) {
	asyncconfigpropcontstatusmaster := &AsyncConfigPropContStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropContStatusMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropcontstatusmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropcontstatusmaster, nil
}

func NewAsyncConfigPropContStatusMaster() *AsyncConfigPropContStatusMaster {
	return &AsyncConfigPropContStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(15),
	}
}

type AsyncConfigPropContStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropContStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropContStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropContStatusSlave, error) {
	asyncconfigpropcontstatusslave := &AsyncConfigPropContStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropContStatusSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropcontstatusslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropcontstatusslave, nil
}

func NewAsyncConfigPropContStatusSlave() *AsyncConfigPropContStatusSlave {
	return &AsyncConfigPropContStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(14),
	}
}

type AsyncConfigPropExperimenterMaster struct {
	*AsyncConfigProp
}

func (self *AsyncConfigPropExperimenterMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropExperimenterMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropExperimenterMaster, error) {
	asyncconfigpropexperimentermaster := &AsyncConfigPropExperimenterMaster{AsyncConfigProp: parent}
	return asyncconfigpropexperimentermaster, nil
}

func NewAsyncConfigPropExperimenterMaster() *AsyncConfigPropExperimenterMaster {
	return &AsyncConfigPropExperimenterMaster{
		AsyncConfigProp: NewAsyncConfigProp(65535),
	}
}

type AsyncConfigPropExperimenterSlave struct {
	*AsyncConfigProp
}

func (self *AsyncConfigPropExperimenterSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropExperimenterSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropExperimenterSlave, error) {
	asyncconfigpropexperimenterslave := &AsyncConfigPropExperimenterSlave{AsyncConfigProp: parent}
	return asyncconfigpropexperimenterslave, nil
}

func NewAsyncConfigPropExperimenterSlave() *AsyncConfigPropExperimenterSlave {
	return &AsyncConfigPropExperimenterSlave{
		AsyncConfigProp: NewAsyncConfigProp(65534),
	}
}

type AsyncConfigPropFlowRemovedMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowRemovedMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropFlowRemovedMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowRemovedMaster, error) {
	asyncconfigpropflowremovedmaster := &AsyncConfigPropFlowRemovedMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowRemovedMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropflowremovedmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropflowremovedmaster, nil
}

func NewAsyncConfigPropFlowRemovedMaster() *AsyncConfigPropFlowRemovedMaster {
	return &AsyncConfigPropFlowRemovedMaster{
		AsyncConfigProp: NewAsyncConfigProp(5),
	}
}

type AsyncConfigPropFlowRemovedSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowRemovedSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropFlowRemovedSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowRemovedSlave, error) {
	asyncconfigpropflowremovedslave := &AsyncConfigPropFlowRemovedSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowRemovedSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropflowremovedslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropflowremovedslave, nil
}

func NewAsyncConfigPropFlowRemovedSlave() *AsyncConfigPropFlowRemovedSlave {
	return &AsyncConfigPropFlowRemovedSlave{
		AsyncConfigProp: NewAsyncConfigProp(4),
	}
}

type AsyncConfigPropFlowStatsMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowStatsMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropFlowStatsMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowStatsMaster, error) {
	asyncconfigpropflowstatsmaster := &AsyncConfigPropFlowStatsMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowStatsMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropflowstatsmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropflowstatsmaster, nil
}

func NewAsyncConfigPropFlowStatsMaster() *AsyncConfigPropFlowStatsMaster {
	return &AsyncConfigPropFlowStatsMaster{
		AsyncConfigProp: NewAsyncConfigProp(13),
	}
}

type AsyncConfigPropFlowStatsSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropFlowStatsSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropFlowStatsSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropFlowStatsSlave, error) {
	asyncconfigpropflowstatsslave := &AsyncConfigPropFlowStatsSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropFlowStatsSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropflowstatsslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropflowstatsslave, nil
}

func NewAsyncConfigPropFlowStatsSlave() *AsyncConfigPropFlowStatsSlave {
	return &AsyncConfigPropFlowStatsSlave{
		AsyncConfigProp: NewAsyncConfigProp(12),
	}
}

type AsyncConfigPropPacketInMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPacketInMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropPacketInMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPacketInMaster, error) {
	asyncconfigproppacketinmaster := &AsyncConfigPropPacketInMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPacketInMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproppacketinmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproppacketinmaster, nil
}

func NewAsyncConfigPropPacketInMaster() *AsyncConfigPropPacketInMaster {
	return &AsyncConfigPropPacketInMaster{
		AsyncConfigProp: NewAsyncConfigProp(1),
	}
}

type AsyncConfigPropPacketInSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPacketInSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropPacketInSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPacketInSlave, error) {
	asyncconfigproppacketinslave := &AsyncConfigPropPacketInSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPacketInSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproppacketinslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproppacketinslave, nil
}

func NewAsyncConfigPropPacketInSlave() *AsyncConfigPropPacketInSlave {
	return &AsyncConfigPropPacketInSlave{
		AsyncConfigProp: NewAsyncConfigProp(0),
	}
}

type AsyncConfigPropPortStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPortStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropPortStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPortStatusMaster, error) {
	asyncconfigpropportstatusmaster := &AsyncConfigPropPortStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPortStatusMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropportstatusmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropportstatusmaster, nil
}

func NewAsyncConfigPropPortStatusMaster() *AsyncConfigPropPortStatusMaster {
	return &AsyncConfigPropPortStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(3),
	}
}

type AsyncConfigPropPortStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropPortStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropPortStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropPortStatusSlave, error) {
	asyncconfigpropportstatusslave := &AsyncConfigPropPortStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropPortStatusSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigpropportstatusslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigpropportstatusslave, nil
}

func NewAsyncConfigPropPortStatusSlave() *AsyncConfigPropPortStatusSlave {
	return &AsyncConfigPropPortStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(2),
	}
}

type AsyncConfigPropRequestforwardMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRequestforwardMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropRequestforwardMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRequestforwardMaster, error) {
	asyncconfigproprequestforwardmaster := &AsyncConfigPropRequestforwardMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRequestforwardMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproprequestforwardmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproprequestforwardmaster, nil
}

func NewAsyncConfigPropRequestforwardMaster() *AsyncConfigPropRequestforwardMaster {
	return &AsyncConfigPropRequestforwardMaster{
		AsyncConfigProp: NewAsyncConfigProp(11),
	}
}

type AsyncConfigPropRequestforwardSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRequestforwardSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropRequestforwardSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRequestforwardSlave, error) {
	asyncconfigproprequestforwardslave := &AsyncConfigPropRequestforwardSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRequestforwardSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproprequestforwardslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproprequestforwardslave, nil
}

func NewAsyncConfigPropRequestforwardSlave() *AsyncConfigPropRequestforwardSlave {
	return &AsyncConfigPropRequestforwardSlave{
		AsyncConfigProp: NewAsyncConfigProp(10),
	}
}

type AsyncConfigPropRoleStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRoleStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropRoleStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRoleStatusMaster, error) {
	asyncconfigproprolestatusmaster := &AsyncConfigPropRoleStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRoleStatusMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproprolestatusmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproprolestatusmaster, nil
}

func NewAsyncConfigPropRoleStatusMaster() *AsyncConfigPropRoleStatusMaster {
	return &AsyncConfigPropRoleStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(7),
	}
}

type AsyncConfigPropRoleStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropRoleStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropRoleStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropRoleStatusSlave, error) {
	asyncconfigproprolestatusslave := &AsyncConfigPropRoleStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropRoleStatusSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproprolestatusslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproprolestatusslave, nil
}

func NewAsyncConfigPropRoleStatusSlave() *AsyncConfigPropRoleStatusSlave {
	return &AsyncConfigPropRoleStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(6),
	}
}

type AsyncConfigPropTableStatusMaster struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropTableStatusMaster) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropTableStatusMaster(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropTableStatusMaster, error) {
	asyncconfigproptablestatusmaster := &AsyncConfigPropTableStatusMaster{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropTableStatusMaster packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproptablestatusmaster.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproptablestatusmaster, nil
}

func NewAsyncConfigPropTableStatusMaster() *AsyncConfigPropTableStatusMaster {
	return &AsyncConfigPropTableStatusMaster{
		AsyncConfigProp: NewAsyncConfigProp(9),
	}
}

type AsyncConfigPropTableStatusSlave struct {
	*AsyncConfigProp
	Mask uint32
}

func (self *AsyncConfigPropTableStatusSlave) Serialize(encoder *goloxi.Encoder) error {
	if err := self.AsyncConfigProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Mask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeAsyncConfigPropTableStatusSlave(parent *AsyncConfigProp, decoder *goloxi.Decoder) (*AsyncConfigPropTableStatusSlave, error) {
	asyncconfigproptablestatusslave := &AsyncConfigPropTableStatusSlave{AsyncConfigProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("AsyncConfigPropTableStatusSlave packet too short: %d < 4", decoder.Length())
	}
	asyncconfigproptablestatusslave.Mask = uint32(decoder.ReadUint32())
	return asyncconfigproptablestatusslave, nil
}

func NewAsyncConfigPropTableStatusSlave() *AsyncConfigPropTableStatusSlave {
	return &AsyncConfigPropTableStatusSlave{
		AsyncConfigProp: NewAsyncConfigProp(8),
	}
}

type BsnControllerConnection struct {
	State       BsnControllerConnectionState
	AuxiliaryId uint8
	Role        ControllerRole
	Uri         string
}

func (self *BsnControllerConnection) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.State))
	encoder.PutUint8(uint8(self.AuxiliaryId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Role))
	encoder.Write([]byte(self.Uri))

	return nil
}

func decodeBsnControllerConnection(decoder *goloxi.Decoder) (*BsnControllerConnection, error) {
	bsncontrollerconnection := &BsnControllerConnection{}
	if decoder.Length() < 264 {
		return nil, fmt.Errorf("BsnControllerConnection packet too short: %d < 264", decoder.Length())
	}
	bsncontrollerconnection.State = BsnControllerConnectionState(decoder.ReadByte())
	bsncontrollerconnection.AuxiliaryId = uint8(decoder.ReadByte())
	decoder.Skip(2)
	bsncontrollerconnection.Role = ControllerRole(decoder.ReadUint32())
	bsncontrollerconnection.Uri = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsncontrollerconnection, nil
}

func NewBsnControllerConnection() *BsnControllerConnection {
	return &BsnControllerConnection{}
}

type BsnDebugCounterDescStatsEntry struct {
	CounterId   uint64
	Name        string
	Description string
}

func (self *BsnDebugCounterDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.CounterId))
	encoder.Write([]byte(self.Name))
	encoder.Write([]byte(self.Description))

	return nil
}

func decodeBsnDebugCounterDescStatsEntry(decoder *goloxi.Decoder) (*BsnDebugCounterDescStatsEntry, error) {
	bsndebugcounterdescstatsentry := &BsnDebugCounterDescStatsEntry{}
	if decoder.Length() < 328 {
		return nil, fmt.Errorf("BsnDebugCounterDescStatsEntry packet too short: %d < 328", decoder.Length())
	}
	bsndebugcounterdescstatsentry.CounterId = uint64(decoder.ReadUint64())
	bsndebugcounterdescstatsentry.Name = string(bytes.Trim(decoder.Read(64), "\x00"))
	bsndebugcounterdescstatsentry.Description = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsndebugcounterdescstatsentry, nil
}

func NewBsnDebugCounterDescStatsEntry() *BsnDebugCounterDescStatsEntry {
	return &BsnDebugCounterDescStatsEntry{}
}

type BsnDebugCounterStatsEntry struct {
	CounterId uint64
	Value     uint64
}

func (self *BsnDebugCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.CounterId))
	encoder.PutUint64(uint64(self.Value))

	return nil
}

func decodeBsnDebugCounterStatsEntry(decoder *goloxi.Decoder) (*BsnDebugCounterStatsEntry, error) {
	bsndebugcounterstatsentry := &BsnDebugCounterStatsEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnDebugCounterStatsEntry packet too short: %d < 16", decoder.Length())
	}
	bsndebugcounterstatsentry.CounterId = uint64(decoder.ReadUint64())
	bsndebugcounterstatsentry.Value = uint64(decoder.ReadUint64())
	return bsndebugcounterstatsentry, nil
}

func NewBsnDebugCounterStatsEntry() *BsnDebugCounterStatsEntry {
	return &BsnDebugCounterStatsEntry{}
}

type BsnFlowChecksumBucketStatsEntry struct {
	Checksum uint64
}

func (self *BsnFlowChecksumBucketStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.Checksum))

	return nil
}

func decodeBsnFlowChecksumBucketStatsEntry(decoder *goloxi.Decoder) (*BsnFlowChecksumBucketStatsEntry, error) {
	bsnflowchecksumbucketstatsentry := &BsnFlowChecksumBucketStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnFlowChecksumBucketStatsEntry packet too short: %d < 8", decoder.Length())
	}
	bsnflowchecksumbucketstatsentry.Checksum = uint64(decoder.ReadUint64())
	return bsnflowchecksumbucketstatsentry, nil
}

func NewBsnFlowChecksumBucketStatsEntry() *BsnFlowChecksumBucketStatsEntry {
	return &BsnFlowChecksumBucketStatsEntry{}
}

type BsnGenericStatsEntry struct {
	Length uint16
	Tlvs   []IBsnTlv
}

func (self *BsnGenericStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.Tlvs {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGenericStatsEntry(decoder *goloxi.Decoder) (*BsnGenericStatsEntry, error) {
	bsngenericstatsentry := &BsnGenericStatsEntry{}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnGenericStatsEntry packet too short: %d < 2", decoder.Length())
	}
	bsngenericstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsngenericstatsentry.Length), 2+0)

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngenericstatsentry.Tlvs = append(bsngenericstatsentry.Tlvs, item)
	}
	return bsngenericstatsentry, nil
}

func NewBsnGenericStatsEntry() *BsnGenericStatsEntry {
	return &BsnGenericStatsEntry{}
}

type BsnGentableBucketStatsEntry struct {
	Checksum Checksum128
}

func (self *BsnGentableBucketStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.Checksum.Serialize(encoder)

	return nil
}

func decodeBsnGentableBucketStatsEntry(decoder *goloxi.Decoder) (*BsnGentableBucketStatsEntry, error) {
	bsngentablebucketstatsentry := &BsnGentableBucketStatsEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnGentableBucketStatsEntry packet too short: %d < 16", decoder.Length())
	}
	bsngentablebucketstatsentry.Checksum.Decode(decoder)
	return bsngentablebucketstatsentry, nil
}

func NewBsnGentableBucketStatsEntry() *BsnGentableBucketStatsEntry {
	return &BsnGentableBucketStatsEntry{}
}

type BsnGentableDescStatsEntry struct {
	Length      uint16
	TableId     uint16
	Name        string
	BucketsSize uint32
	MaxEntries  uint32
}

func (self *BsnGentableDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.BucketsSize))
	encoder.PutUint32(uint32(self.MaxEntries))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableDescStatsEntry(decoder *goloxi.Decoder) (*BsnGentableDescStatsEntry, error) {
	bsngentabledescstatsentry := &BsnGentableDescStatsEntry{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("BsnGentableDescStatsEntry packet too short: %d < 48", decoder.Length())
	}
	bsngentabledescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsngentabledescstatsentry.Length), 2+0)
	bsngentabledescstatsentry.TableId = uint16(decoder.ReadUint16())
	bsngentabledescstatsentry.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	bsngentabledescstatsentry.BucketsSize = uint32(decoder.ReadUint32())
	bsngentabledescstatsentry.MaxEntries = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return bsngentabledescstatsentry, nil
}

func NewBsnGentableDescStatsEntry() *BsnGentableDescStatsEntry {
	return &BsnGentableDescStatsEntry{}
}

type BsnGentableEntryDescStatsEntry struct {
	Length    uint16
	KeyLength uint16
	Checksum  Checksum128
	Key       []IBsnTlv
	Value     []IBsnTlv
}

func (self *BsnGentableEntryDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.KeyLength))
	self.Checksum.Serialize(encoder)
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryDescStatsEntry(decoder *goloxi.Decoder) (*BsnGentableEntryDescStatsEntry, error) {
	bsngentableentrydescstatsentry := &BsnGentableEntryDescStatsEntry{}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("BsnGentableEntryDescStatsEntry packet too short: %d < 20", decoder.Length())
	}
	bsngentableentrydescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsngentableentrydescstatsentry.Length), 2+0)
	bsngentableentrydescstatsentry.KeyLength = uint16(decoder.ReadUint16())
	bsngentableentrydescstatsentry.Checksum.Decode(decoder)

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrydescstatsentry.Key = append(bsngentableentrydescstatsentry.Key, item)
	}

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrydescstatsentry.Value = append(bsngentableentrydescstatsentry.Value, item)
	}
	return bsngentableentrydescstatsentry, nil
}

func NewBsnGentableEntryDescStatsEntry() *BsnGentableEntryDescStatsEntry {
	return &BsnGentableEntryDescStatsEntry{}
}

type BsnGentableEntryStatsEntry struct {
	Length    uint16
	KeyLength uint16
	Key       []IBsnTlv
	Stats     []IBsnTlv
}

func (self *BsnGentableEntryStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.KeyLength))
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Stats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnGentableEntryStatsEntry(decoder *goloxi.Decoder) (*BsnGentableEntryStatsEntry, error) {
	bsngentableentrystatsentry := &BsnGentableEntryStatsEntry{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnGentableEntryStatsEntry packet too short: %d < 4", decoder.Length())
	}
	bsngentableentrystatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsngentableentrystatsentry.Length), 2+0)
	bsngentableentrystatsentry.KeyLength = uint16(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrystatsentry.Key = append(bsngentableentrystatsentry.Key, item)
	}

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsngentableentrystatsentry.Stats = append(bsngentableentrystatsentry.Stats, item)
	}
	return bsngentableentrystatsentry, nil
}

func NewBsnGentableEntryStatsEntry() *BsnGentableEntryStatsEntry {
	return &BsnGentableEntryStatsEntry{}
}

type BsnGentableStatsEntry struct {
	TableId    uint16
	EntryCount uint32
	Checksum   Checksum128
}

func (self *BsnGentableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.EntryCount))
	self.Checksum.Serialize(encoder)

	return nil
}

func decodeBsnGentableStatsEntry(decoder *goloxi.Decoder) (*BsnGentableStatsEntry, error) {
	bsngentablestatsentry := &BsnGentableStatsEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("BsnGentableStatsEntry packet too short: %d < 24", decoder.Length())
	}
	bsngentablestatsentry.TableId = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	bsngentablestatsentry.EntryCount = uint32(decoder.ReadUint32())
	bsngentablestatsentry.Checksum.Decode(decoder)
	return bsngentablestatsentry, nil
}

func NewBsnGentableStatsEntry() *BsnGentableStatsEntry {
	return &BsnGentableStatsEntry{}
}

type BsnInterface struct {
	HwAddr      net.HardwareAddr
	Name        string
	Ipv4Addr    net.IP
	Ipv4Netmask net.IP
}

func (self *BsnInterface) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.Write(self.Ipv4Addr.To4())
	encoder.Write(self.Ipv4Netmask.To4())

	return nil
}

func decodeBsnInterface(decoder *goloxi.Decoder) (*BsnInterface, error) {
	bsninterface := &BsnInterface{}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("BsnInterface packet too short: %d < 32", decoder.Length())
	}
	bsninterface.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	bsninterface.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	bsninterface.Ipv4Addr = net.IP(decoder.Read(4))
	bsninterface.Ipv4Netmask = net.IP(decoder.Read(4))
	return bsninterface, nil
}

func NewBsnInterface() *BsnInterface {
	return &BsnInterface{}
}

type BsnLacpStatsEntry struct {
	PortNo              PortNo
	ActorSysPriority    uint16
	ActorSysMac         net.HardwareAddr
	ActorPortPriority   uint16
	ActorPortNum        uint16
	ActorKey            uint16
	ConvergenceStatus   uint8
	PartnerSysPriority  uint16
	PartnerSysMac       net.HardwareAddr
	PartnerPortPriority uint16
	PartnerPortNum      uint16
	PartnerKey          uint16
}

func (self *BsnLacpStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.ActorSysPriority))
	encoder.Write(self.ActorSysMac)
	encoder.PutUint16(uint16(self.ActorPortPriority))
	encoder.PutUint16(uint16(self.ActorPortNum))
	encoder.PutUint16(uint16(self.ActorKey))
	encoder.PutUint8(uint8(self.ConvergenceStatus))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.PartnerSysPriority))
	encoder.Write(self.PartnerSysMac)
	encoder.PutUint16(uint16(self.PartnerPortPriority))
	encoder.PutUint16(uint16(self.PartnerPortNum))
	encoder.PutUint16(uint16(self.PartnerKey))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	return nil
}

func decodeBsnLacpStatsEntry(decoder *goloxi.Decoder) (*BsnLacpStatsEntry, error) {
	bsnlacpstatsentry := &BsnLacpStatsEntry{}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("BsnLacpStatsEntry packet too short: %d < 36", decoder.Length())
	}
	bsnlacpstatsentry.PortNo.Decode(decoder)
	bsnlacpstatsentry.ActorSysPriority = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.ActorSysMac = net.HardwareAddr(decoder.Read(6))
	bsnlacpstatsentry.ActorPortPriority = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.ActorPortNum = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.ActorKey = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.ConvergenceStatus = uint8(decoder.ReadByte())
	decoder.Skip(1)
	bsnlacpstatsentry.PartnerSysPriority = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.PartnerSysMac = net.HardwareAddr(decoder.Read(6))
	bsnlacpstatsentry.PartnerPortPriority = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.PartnerPortNum = uint16(decoder.ReadUint16())
	bsnlacpstatsentry.PartnerKey = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return bsnlacpstatsentry, nil
}

func NewBsnLacpStatsEntry() *BsnLacpStatsEntry {
	return &BsnLacpStatsEntry{}
}

type BsnPortCounterStatsEntry struct {
	Length uint16
	PortNo PortNo
	Values []*Uint64
}

func (self *BsnPortCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.PortNo.Serialize(encoder)
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnPortCounterStatsEntry(decoder *goloxi.Decoder) (*BsnPortCounterStatsEntry, error) {
	bsnportcounterstatsentry := &BsnPortCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnPortCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	bsnportcounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsnportcounterstatsentry.Length), 2+0)
	decoder.Skip(2)
	bsnportcounterstatsentry.PortNo.Decode(decoder)

	for decoder.Length() >= 8 {
		item, err := decodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		bsnportcounterstatsentry.Values = append(bsnportcounterstatsentry.Values, item)
	}
	return bsnportcounterstatsentry, nil
}

func NewBsnPortCounterStatsEntry() *BsnPortCounterStatsEntry {
	return &BsnPortCounterStatsEntry{}
}

type BsnSwitchPipelineStatsEntry struct {
	Pipeline string
}

func (self *BsnSwitchPipelineStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write([]byte(self.Pipeline))

	return nil
}

func decodeBsnSwitchPipelineStatsEntry(decoder *goloxi.Decoder) (*BsnSwitchPipelineStatsEntry, error) {
	bsnswitchpipelinestatsentry := &BsnSwitchPipelineStatsEntry{}
	if decoder.Length() < 256 {
		return nil, fmt.Errorf("BsnSwitchPipelineStatsEntry packet too short: %d < 256", decoder.Length())
	}
	bsnswitchpipelinestatsentry.Pipeline = string(bytes.Trim(decoder.Read(256), "\x00"))
	return bsnswitchpipelinestatsentry, nil
}

func NewBsnSwitchPipelineStatsEntry() *BsnSwitchPipelineStatsEntry {
	return &BsnSwitchPipelineStatsEntry{}
}

type BsnTableChecksumStatsEntry struct {
	TableId  uint8
	Checksum uint64
}

func (self *BsnTableChecksumStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint64(uint64(self.Checksum))

	return nil
}

func decodeBsnTableChecksumStatsEntry(decoder *goloxi.Decoder) (*BsnTableChecksumStatsEntry, error) {
	bsntablechecksumstatsentry := &BsnTableChecksumStatsEntry{}
	if decoder.Length() < 9 {
		return nil, fmt.Errorf("BsnTableChecksumStatsEntry packet too short: %d < 9", decoder.Length())
	}
	bsntablechecksumstatsentry.TableId = uint8(decoder.ReadByte())
	bsntablechecksumstatsentry.Checksum = uint64(decoder.ReadUint64())
	return bsntablechecksumstatsentry, nil
}

func NewBsnTableChecksumStatsEntry() *BsnTableChecksumStatsEntry {
	return &BsnTableChecksumStatsEntry{}
}

type BsnTlv struct {
	Type   uint16
	Length uint16
}

type IBsnTlv interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnTlv) GetType() uint16 {
	return self.Type
}

func (self *BsnTlv) GetLength() uint16 {
	return self.Length
}

func (self *BsnTlv) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeBsnTlv(decoder *goloxi.Decoder) (IBsnTlv, error) {
	bsntlv := &BsnTlv{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlv packet too short: %d < 4", decoder.Length())
	}
	bsntlv.Type = uint16(decoder.ReadUint16())
	bsntlv.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsntlv.Length), 2+2)

	switch bsntlv.Type {
	case 0:
		return decodeBsnTlvPort(bsntlv, decoder)
	case 1:
		return decodeBsnTlvMac(bsntlv, decoder)
	case 2:
		return decodeBsnTlvRxPackets(bsntlv, decoder)
	case 3:
		return decodeBsnTlvTxPackets(bsntlv, decoder)
	case 4:
		return decodeBsnTlvIpv4(bsntlv, decoder)
	case 5:
		return decodeBsnTlvIdleTime(bsntlv, decoder)
	case 6:
		return decodeBsnTlvVlanVid(bsntlv, decoder)
	case 7:
		return decodeBsnTlvIdleNotification(bsntlv, decoder)
	case 8:
		return decodeBsnTlvIdleTimeout(bsntlv, decoder)
	case 9:
		return decodeBsnTlvUnicastQueryTimeout(bsntlv, decoder)
	case 10:
		return decodeBsnTlvBroadcastQueryTimeout(bsntlv, decoder)
	case 11:
		return decodeBsnTlvRequestPackets(bsntlv, decoder)
	case 12:
		return decodeBsnTlvReplyPackets(bsntlv, decoder)
	case 13:
		return decodeBsnTlvMissPackets(bsntlv, decoder)
	case 14:
		return decodeBsnTlvCircuitId(bsntlv, decoder)
	case 15:
		return decodeBsnTlvUdfId(bsntlv, decoder)
	case 16:
		return decodeBsnTlvUdfAnchor(bsntlv, decoder)
	case 17:
		return decodeBsnTlvUdfOffset(bsntlv, decoder)
	case 18:
		return decodeBsnTlvUdfLength(bsntlv, decoder)
	case 19:
		return decodeBsnTlvVrf(bsntlv, decoder)
	case 20:
		return decodeBsnTlvQueueId(bsntlv, decoder)
	case 21:
		return decodeBsnTlvQueueWeight(bsntlv, decoder)
	case 22:
		return decodeBsnTlvCrcEnabled(bsntlv, decoder)
	case 23:
		return decodeBsnTlvExternalIp(bsntlv, decoder)
	case 24:
		return decodeBsnTlvExternalMac(bsntlv, decoder)
	case 25:
		return decodeBsnTlvExternalNetmask(bsntlv, decoder)
	case 26:
		return decodeBsnTlvExternalGatewayIp(bsntlv, decoder)
	case 27:
		return decodeBsnTlvInternalMac(bsntlv, decoder)
	case 28:
		return decodeBsnTlvInternalGatewayMac(bsntlv, decoder)
	case 29:
		return decodeBsnTlvExternalGatewayMac(bsntlv, decoder)
	case 30:
		return decodeBsnTlvSamplingRate(bsntlv, decoder)
	case 31:
		return decodeBsnTlvHeaderSize(bsntlv, decoder)
	case 32:
		return decodeBsnTlvEthSrc(bsntlv, decoder)
	case 33:
		return decodeBsnTlvEthDst(bsntlv, decoder)
	case 34:
		return decodeBsnTlvIpv4Src(bsntlv, decoder)
	case 35:
		return decodeBsnTlvIpv4Dst(bsntlv, decoder)
	case 36:
		return decodeBsnTlvUdpSrc(bsntlv, decoder)
	case 37:
		return decodeBsnTlvUdpDst(bsntlv, decoder)
	case 38:
		return decodeBsnTlvSubAgentId(bsntlv, decoder)
	case 39:
		return decodeBsnTlvTxBytes(bsntlv, decoder)
	case 40:
		return decodeBsnTlvActorSystemPriority(bsntlv, decoder)
	case 41:
		return decodeBsnTlvActorSystemMac(bsntlv, decoder)
	case 42:
		return decodeBsnTlvActorPortPriority(bsntlv, decoder)
	case 43:
		return decodeBsnTlvActorPortNum(bsntlv, decoder)
	case 44:
		return decodeBsnTlvActorKey(bsntlv, decoder)
	case 45:
		return decodeBsnTlvConvergenceStatus(bsntlv, decoder)
	case 47:
		return decodeBsnTlvPartnerSystemPriority(bsntlv, decoder)
	case 48:
		return decodeBsnTlvPartnerSystemMac(bsntlv, decoder)
	case 49:
		return decodeBsnTlvPartnerPortPriority(bsntlv, decoder)
	case 50:
		return decodeBsnTlvPartnerPortNum(bsntlv, decoder)
	case 51:
		return decodeBsnTlvPartnerKey(bsntlv, decoder)
	case 52:
		return decodeBsnTlvName(bsntlv, decoder)
	case 53:
		return decodeBsnTlvActorState(bsntlv, decoder)
	case 54:
		return decodeBsnTlvPartnerState(bsntlv, decoder)
	case 55:
		return decodeBsnTlvData(bsntlv, decoder)
	case 56:
		return decodeBsnTlvMacMask(bsntlv, decoder)
	case 57:
		return decodeBsnTlvPriority(bsntlv, decoder)
	case 58:
		return decodeBsnTlvInterval(bsntlv, decoder)
	case 59:
		return decodeBsnTlvReference(bsntlv, decoder)
	case 60:
		return decodeBsnTlvIpv4Netmask(bsntlv, decoder)
	case 61:
		return decodeBsnTlvMplsLabel(bsntlv, decoder)
	case 62:
		return decodeBsnTlvMplsControlWord(bsntlv, decoder)
	case 63:
		return decodeBsnTlvMplsSequenced(bsntlv, decoder)
	case 64:
		return decodeBsnTlvBucket(bsntlv, decoder)
	case 65:
		return decodeBsnTlvTcpSrc(bsntlv, decoder)
	case 66:
		return decodeBsnTlvTcpDst(bsntlv, decoder)
	case 67:
		return decodeBsnTlvIpProto(bsntlv, decoder)
	case 68:
		return decodeBsnTlvIcmpType(bsntlv, decoder)
	case 69:
		return decodeBsnTlvIcmpCode(bsntlv, decoder)
	case 70:
		return decodeBsnTlvIcmpId(bsntlv, decoder)
	case 71:
		return decodeBsnTlvRxBytes(bsntlv, decoder)
	case 72:
		return decodeBsnTlvVlanPcp(bsntlv, decoder)
	case 73:
		return decodeBsnTlvStripVlanOnEgress(bsntlv, decoder)
	case 74:
		return decodeBsnTlvSetLoopbackMode(bsntlv, decoder)
	case 75:
		return decodeBsnTlvStripMplsL2OnIngress(bsntlv, decoder)
	case 76:
		return decodeBsnTlvStripMplsL3OnIngress(bsntlv, decoder)
	case 77:
		return decodeBsnTlvVlanVidMask(bsntlv, decoder)
	case 78:
		return decodeBsnTlvIgmpSnooping(bsntlv, decoder)
	case 79:
		return decodeBsnTlvL2MulticastLookup(bsntlv, decoder)
	case 80:
		return decodeBsnTlvGenerationId(bsntlv, decoder)
	case 81:
		return decodeBsnTlvAnchor(bsntlv, decoder)
	case 82:
		return decodeBsnTlvOffset(bsntlv, decoder)
	case 83:
		return decodeBsnTlvNegate(bsntlv, decoder)
	case 84:
		return decodeBsnTlvIpv6(bsntlv, decoder)
	case 85:
		return decodeBsnTlvDecap(bsntlv, decoder)
	case 86:
		return decodeBsnTlvVni(bsntlv, decoder)
	case 87:
		return decodeBsnTlvMcgTypeVxlan(bsntlv, decoder)
	case 88:
		return decodeBsnTlvPortVxlanMode(bsntlv, decoder)
	case 89:
		return decodeBsnTlvRateUnit(bsntlv, decoder)
	case 90:
		return decodeBsnTlvBroadcastRate(bsntlv, decoder)
	case 91:
		return decodeBsnTlvKnownMulticastRate(bsntlv, decoder)
	case 92:
		return decodeBsnTlvUnknownMulticastRate(bsntlv, decoder)
	case 93:
		return decodeBsnTlvUnicastRate(bsntlv, decoder)
	case 94:
		return decodeBsnTlvNexthopTypeVxlan(bsntlv, decoder)
	case 95:
		return decodeBsnTlvMulticastInterfaceId(bsntlv, decoder)
	case 96:
		return decodeBsnTlvUsePacketState(bsntlv, decoder)
	case 97:
		return decodeBsnTlvStatus(bsntlv, decoder)
	case 98:
		return decodeBsnTlvVlanMacList(bsntlv, decoder)
	case 99:
		return decodeBsnTlvVfi(bsntlv, decoder)
	case 100:
		return decodeBsnTlvHashSeed(bsntlv, decoder)
	case 101:
		return decodeBsnTlvHashType(bsntlv, decoder)
	case 102:
		return decodeBsnTlvHashPacketType(bsntlv, decoder)
	case 103:
		return decodeBsnTlvHashPacketField(bsntlv, decoder)
	case 104:
		return decodeBsnTlvHashGtpHeaderMatch(bsntlv, decoder)
	case 105:
		return decodeBsnTlvHashGtpPortMatch(bsntlv, decoder)
	case 106:
		return decodeBsnTlvUntagged(bsntlv, decoder)
	case 107:
		return decodeBsnTlvVfpClassId(bsntlv, decoder)
	case 108:
		return decodeBsnTlvQosPriority(bsntlv, decoder)
	case 109:
		return decodeBsnTlvParentPort(bsntlv, decoder)
	case 110:
		return decodeBsnTlvLoopbackPort(bsntlv, decoder)
	case 111:
		return decodeBsnTlvVpnKey(bsntlv, decoder)
	case 112:
		return decodeBsnTlvDscp(bsntlv, decoder)
	case 113:
		return decodeBsnTlvTtl(bsntlv, decoder)
	case 114:
		return decodeBsnTlvNextHopMac(bsntlv, decoder)
	case 115:
		return decodeBsnTlvNextHopIpv4(bsntlv, decoder)
	case 116:
		return decodeBsnTlvRateLimit(bsntlv, decoder)
	case 117:
		return decodeBsnTlvVxlanEgressLag(bsntlv, decoder)
	case 118:
		return decodeBsnTlvCpuLag(bsntlv, decoder)
	case 119:
		return decodeBsnTlvUint64List(bsntlv, decoder)
	case 120:
		return decodeBsnTlvDisableSrcMacCheck(bsntlv, decoder)
	case 121:
		return decodeBsnTlvDrop(bsntlv, decoder)
	case 122:
		return decodeBsnTlvIpv6Prefix(bsntlv, decoder)
	case 123:
		return decodeBsnTlvNdpOffload(bsntlv, decoder)
	case 124:
		return decodeBsnTlvNdpStatic(bsntlv, decoder)
	case 125:
		return decodeBsnTlvIcmpv6Chksum(bsntlv, decoder)
	case 126:
		return decodeBsnTlvIpv6Src(bsntlv, decoder)
	case 127:
		return decodeBsnTlvIpv6Dst(bsntlv, decoder)
	case 128:
		return decodeBsnTlvPushVlanOnIngress(bsntlv, decoder)
	case 129:
		return decodeBsnTlvApplyPackets(bsntlv, decoder)
	case 130:
		return decodeBsnTlvApplyBytes(bsntlv, decoder)
	case 131:
		return decodeBsnTlvEthType(bsntlv, decoder)
	case 132:
		return decodeBsnTlvEcn(bsntlv, decoder)
	case 133:
		return decodeBsnTlvTcpFlags(bsntlv, decoder)
	case 134:
		return decodeBsnTlvL3InterfaceClassId(bsntlv, decoder)
	case 135:
		return decodeBsnTlvL3SrcClassId(bsntlv, decoder)
	case 136:
		return decodeBsnTlvL3DstClassId(bsntlv, decoder)
	case 137:
		return decodeBsnTlvEgressOnly(bsntlv, decoder)
	case 138:
		return decodeBsnTlvIngressPortGroupId(bsntlv, decoder)
	case 139:
		return decodeBsnTlvEgressPortGroupId(bsntlv, decoder)
	case 140:
		return decodeBsnTlvDataMask(bsntlv, decoder)
	case 141:
		return decodeBsnTlvPortUsage(bsntlv, decoder)
	case 142:
		return decodeBsnTlvTunnelCapability(bsntlv, decoder)
	case 143:
		return decodeBsnTlvEnhancedHashCapability(bsntlv, decoder)
	case 144:
		return decodeBsnTlvAutoNegotiation(bsntlv, decoder)
	case 145:
		return decodeBsnTlvHashAlgorithm(bsntlv, decoder)
	case 146:
		return decodeBsnTlvLoopbackMode(bsntlv, decoder)
	case 147:
		return decodeBsnTlvNoArpResponse(bsntlv, decoder)
	case 148:
		return decodeBsnTlvNoNsResponse(bsntlv, decoder)
	case 149:
		return decodeBsnTlvForwardErrorCorrection(bsntlv, decoder)
	case 150:
		return decodeBsnTlvOpticsAlwaysEnabled(bsntlv, decoder)
	case 151:
		return decodeBsnTlvForceLinkUp(bsntlv, decoder)
	case 152:
		return decodeBsnTlvRestServer(bsntlv, decoder)
	case 153:
		return decodeBsnTlvUriScheme(bsntlv, decoder)
	case 154:
		return decodeBsnTlvTimestamp(bsntlv, decoder)
	case 155:
		return decodeBsnTlvRecordPackets(bsntlv, decoder)
	case 156:
		return decodeBsnTlvPortSpeedGbps(bsntlv, decoder)
	case 157:
		return decodeBsnTlvOuterSrcMac(bsntlv, decoder)
	case 158:
		return decodeBsnTlvVirtual(bsntlv, decoder)
	case 159:
		return decodeBsnTlvPduaRxInstance(bsntlv, decoder)
	case 160:
		return decodeBsnTlvLagOptions(bsntlv, decoder)
	case 161:
		return decodeBsnTlvRoutingParam(bsntlv, decoder)
	case 162:
		return decodeBsnTlvPushVlanOnEgress(bsntlv, decoder)
	case 163:
		return decodeBsnTlvFlood(bsntlv, decoder)
	case 164:
		return decodeBsnTlvUpgrade(bsntlv, decoder)
	case 165:
		return decodeBsnTlvFabricPortRole(bsntlv, decoder)
	case 166:
		return decodeBsnTlvUserConfigured(bsntlv, decoder)
	case 167:
		return decodeBsnTlvUint32(bsntlv, decoder)
	case 168:
		return decodeBsnTlvL3(bsntlv, decoder)
	case 169:
		return decodeBsnTlvIpTunnelType(bsntlv, decoder)
	case 170:
		return decodeBsnTlvMulticastPacket(bsntlv, decoder)
	case 171:
		return decodeBsnTlvPimDr(bsntlv, decoder)
	case 172:
		return decodeBsnTlvPassive(bsntlv, decoder)
	case 173:
		return decodeBsnTlvIdentifier(bsntlv, decoder)
	case 174:
		return decodeBsnTlvMultiplier(bsntlv, decoder)
	case 175:
		return decodeBsnTlvEncap(bsntlv, decoder)
	case 176:
		return decodeBsnTlvBfdEndpoint(bsntlv, decoder)
	case 177:
		return decodeBsnTlvBfdState(bsntlv, decoder)
	case 178:
		return decodeBsnTlvLrAllEnabled(bsntlv, decoder)
	case 179:
		return decodeBsnTlvPortMode(bsntlv, decoder)
	case 180:
		return decodeBsnTlvUdfCapability(bsntlv, decoder)
	case 181:
		return decodeBsnTlvPimHelloFlood(bsntlv, decoder)
	case 182:
		return decodeBsnTlvFlowClassify(bsntlv, decoder)
	case 183:
		return decodeBsnTlvFlowIdentifier(bsntlv, decoder)
	case 184:
		return decodeBsnTlvFlowClassifier(bsntlv, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BsnTlv'", bsntlv.Type)
	}
}

func NewBsnTlv(_type uint16) *BsnTlv {
	return &BsnTlv{
		Type: _type,
	}
}

type BsnTlvActorKey struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorKey, error) {
	bsntlvactorkey := &BsnTlvActorKey{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorKey packet too short: %d < 2", decoder.Length())
	}
	bsntlvactorkey.Value = uint16(decoder.ReadUint16())
	return bsntlvactorkey, nil
}

func NewBsnTlvActorKey() *BsnTlvActorKey {
	return &BsnTlvActorKey{
		BsnTlv: NewBsnTlv(44),
	}
}

type BsnTlvActorPortNum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorPortNum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorPortNum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorPortNum, error) {
	bsntlvactorportnum := &BsnTlvActorPortNum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorPortNum packet too short: %d < 2", decoder.Length())
	}
	bsntlvactorportnum.Value = uint16(decoder.ReadUint16())
	return bsntlvactorportnum, nil
}

func NewBsnTlvActorPortNum() *BsnTlvActorPortNum {
	return &BsnTlvActorPortNum{
		BsnTlv: NewBsnTlv(43),
	}
}

type BsnTlvActorPortPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorPortPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorPortPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorPortPriority, error) {
	bsntlvactorportpriority := &BsnTlvActorPortPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorPortPriority packet too short: %d < 2", decoder.Length())
	}
	bsntlvactorportpriority.Value = uint16(decoder.ReadUint16())
	return bsntlvactorportpriority, nil
}

func NewBsnTlvActorPortPriority() *BsnTlvActorPortPriority {
	return &BsnTlvActorPortPriority{
		BsnTlv: NewBsnTlv(42),
	}
}

type BsnTlvActorState struct {
	*BsnTlv
	Value BsnLacpState
}

func (self *BsnTlvActorState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorState, error) {
	bsntlvactorstate := &BsnTlvActorState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvActorState packet too short: %d < 1", decoder.Length())
	}
	bsntlvactorstate.Value = BsnLacpState(decoder.ReadByte())
	return bsntlvactorstate, nil
}

func NewBsnTlvActorState() *BsnTlvActorState {
	return &BsnTlvActorState{
		BsnTlv: NewBsnTlv(53),
	}
}

type BsnTlvActorSystemMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvActorSystemMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorSystemMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorSystemMac, error) {
	bsntlvactorsystemmac := &BsnTlvActorSystemMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvActorSystemMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvactorsystemmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvactorsystemmac, nil
}

func NewBsnTlvActorSystemMac() *BsnTlvActorSystemMac {
	return &BsnTlvActorSystemMac{
		BsnTlv: NewBsnTlv(41),
	}
}

type BsnTlvActorSystemPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvActorSystemPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvActorSystemPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvActorSystemPriority, error) {
	bsntlvactorsystempriority := &BsnTlvActorSystemPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvActorSystemPriority packet too short: %d < 2", decoder.Length())
	}
	bsntlvactorsystempriority.Value = uint16(decoder.ReadUint16())
	return bsntlvactorsystempriority, nil
}

func NewBsnTlvActorSystemPriority() *BsnTlvActorSystemPriority {
	return &BsnTlvActorSystemPriority{
		BsnTlv: NewBsnTlv(40),
	}
}

type BsnTlvAnchor struct {
	*BsnTlv
	Value BsnAnchor
}

func (self *BsnTlvAnchor) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvAnchor(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvAnchor, error) {
	bsntlvanchor := &BsnTlvAnchor{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvAnchor packet too short: %d < 2", decoder.Length())
	}
	bsntlvanchor.Value = BsnAnchor(decoder.ReadUint16())
	return bsntlvanchor, nil
}

func NewBsnTlvAnchor() *BsnTlvAnchor {
	return &BsnTlvAnchor{
		BsnTlv: NewBsnTlv(81),
	}
}

type BsnTlvApplyBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvApplyBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvApplyBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvApplyBytes, error) {
	bsntlvapplybytes := &BsnTlvApplyBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvApplyBytes packet too short: %d < 8", decoder.Length())
	}
	bsntlvapplybytes.Value = uint64(decoder.ReadUint64())
	return bsntlvapplybytes, nil
}

func NewBsnTlvApplyBytes() *BsnTlvApplyBytes {
	return &BsnTlvApplyBytes{
		BsnTlv: NewBsnTlv(130),
	}
}

type BsnTlvApplyPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvApplyPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvApplyPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvApplyPackets, error) {
	bsntlvapplypackets := &BsnTlvApplyPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvApplyPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvapplypackets.Value = uint64(decoder.ReadUint64())
	return bsntlvapplypackets, nil
}

func NewBsnTlvApplyPackets() *BsnTlvApplyPackets {
	return &BsnTlvApplyPackets{
		BsnTlv: NewBsnTlv(129),
	}
}

type BsnTlvAutoNegotiation struct {
	*BsnTlv
	Value BsnAutoNegotiationType
}

func (self *BsnTlvAutoNegotiation) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvAutoNegotiation(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvAutoNegotiation, error) {
	bsntlvautonegotiation := &BsnTlvAutoNegotiation{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvAutoNegotiation packet too short: %d < 1", decoder.Length())
	}
	bsntlvautonegotiation.Value = BsnAutoNegotiationType(decoder.ReadByte())
	return bsntlvautonegotiation, nil
}

func NewBsnTlvAutoNegotiation() *BsnTlvAutoNegotiation {
	return &BsnTlvAutoNegotiation{
		BsnTlv: NewBsnTlv(144),
	}
}

type BsnTlvBfdEndpoint struct {
	*BsnTlv
	Value BsnBfdEndpoint
}

func (self *BsnTlvBfdEndpoint) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvBfdEndpoint(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBfdEndpoint, error) {
	bsntlvbfdendpoint := &BsnTlvBfdEndpoint{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvBfdEndpoint packet too short: %d < 1", decoder.Length())
	}
	bsntlvbfdendpoint.Value = BsnBfdEndpoint(decoder.ReadByte())
	return bsntlvbfdendpoint, nil
}

func NewBsnTlvBfdEndpoint() *BsnTlvBfdEndpoint {
	return &BsnTlvBfdEndpoint{
		BsnTlv: NewBsnTlv(176),
	}
}

type BsnTlvBfdState struct {
	*BsnTlv
	Value BsnBfdEndpointState
}

func (self *BsnTlvBfdState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvBfdState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBfdState, error) {
	bsntlvbfdstate := &BsnTlvBfdState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvBfdState packet too short: %d < 1", decoder.Length())
	}
	bsntlvbfdstate.Value = BsnBfdEndpointState(decoder.ReadByte())
	return bsntlvbfdstate, nil
}

func NewBsnTlvBfdState() *BsnTlvBfdState {
	return &BsnTlvBfdState{
		BsnTlv: NewBsnTlv(177),
	}
}

type BsnTlvBroadcastQueryTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvBroadcastQueryTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvBroadcastQueryTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBroadcastQueryTimeout, error) {
	bsntlvbroadcastquerytimeout := &BsnTlvBroadcastQueryTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvBroadcastQueryTimeout packet too short: %d < 4", decoder.Length())
	}
	bsntlvbroadcastquerytimeout.Value = uint32(decoder.ReadUint32())
	return bsntlvbroadcastquerytimeout, nil
}

func NewBsnTlvBroadcastQueryTimeout() *BsnTlvBroadcastQueryTimeout {
	return &BsnTlvBroadcastQueryTimeout{
		BsnTlv: NewBsnTlv(10),
	}
}

type BsnTlvBroadcastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvBroadcastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvBroadcastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBroadcastRate, error) {
	bsntlvbroadcastrate := &BsnTlvBroadcastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvBroadcastRate packet too short: %d < 4", decoder.Length())
	}
	bsntlvbroadcastrate.Value = uint32(decoder.ReadUint32())
	return bsntlvbroadcastrate, nil
}

func NewBsnTlvBroadcastRate() *BsnTlvBroadcastRate {
	return &BsnTlvBroadcastRate{
		BsnTlv: NewBsnTlv(90),
	}
}

type BsnTlvBucket struct {
	*BsnTlv
	Value []IBsnTlv
}

func (self *BsnTlvBucket) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvBucket(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvBucket, error) {
	bsntlvbucket := &BsnTlvBucket{BsnTlv: parent}

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsntlvbucket.Value = append(bsntlvbucket.Value, item)
	}
	return bsntlvbucket, nil
}

func NewBsnTlvBucket() *BsnTlvBucket {
	return &BsnTlvBucket{
		BsnTlv: NewBsnTlv(64),
	}
}

type BsnTlvCircuitId struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvCircuitId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvCircuitId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCircuitId, error) {
	bsntlvcircuitid := &BsnTlvCircuitId{BsnTlv: parent}
	bsntlvcircuitid.Value = decoder.Read(decoder.Length())
	return bsntlvcircuitid, nil
}

func NewBsnTlvCircuitId() *BsnTlvCircuitId {
	return &BsnTlvCircuitId{
		BsnTlv: NewBsnTlv(14),
	}
}

type BsnTlvConvergenceStatus struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvConvergenceStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvConvergenceStatus(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvConvergenceStatus, error) {
	bsntlvconvergencestatus := &BsnTlvConvergenceStatus{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvConvergenceStatus packet too short: %d < 1", decoder.Length())
	}
	bsntlvconvergencestatus.Value = uint8(decoder.ReadByte())
	return bsntlvconvergencestatus, nil
}

func NewBsnTlvConvergenceStatus() *BsnTlvConvergenceStatus {
	return &BsnTlvConvergenceStatus{
		BsnTlv: NewBsnTlv(45),
	}
}

type BsnTlvCpuLag struct {
	*BsnTlv
}

func (self *BsnTlvCpuLag) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvCpuLag(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCpuLag, error) {
	bsntlvcpulag := &BsnTlvCpuLag{BsnTlv: parent}
	return bsntlvcpulag, nil
}

func NewBsnTlvCpuLag() *BsnTlvCpuLag {
	return &BsnTlvCpuLag{
		BsnTlv: NewBsnTlv(118),
	}
}

type BsnTlvCrcEnabled struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvCrcEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvCrcEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvCrcEnabled, error) {
	bsntlvcrcenabled := &BsnTlvCrcEnabled{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvCrcEnabled packet too short: %d < 1", decoder.Length())
	}
	bsntlvcrcenabled.Value = uint8(decoder.ReadByte())
	return bsntlvcrcenabled, nil
}

func NewBsnTlvCrcEnabled() *BsnTlvCrcEnabled {
	return &BsnTlvCrcEnabled{
		BsnTlv: NewBsnTlv(22),
	}
}

type BsnTlvData struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvData) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvData(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvData, error) {
	bsntlvdata := &BsnTlvData{BsnTlv: parent}
	bsntlvdata.Value = decoder.Read(decoder.Length())
	return bsntlvdata, nil
}

func NewBsnTlvData() *BsnTlvData {
	return &BsnTlvData{
		BsnTlv: NewBsnTlv(55),
	}
}

type BsnTlvDataMask struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvDataMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvDataMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDataMask, error) {
	bsntlvdatamask := &BsnTlvDataMask{BsnTlv: parent}
	bsntlvdatamask.Value = decoder.Read(decoder.Length())
	return bsntlvdatamask, nil
}

func NewBsnTlvDataMask() *BsnTlvDataMask {
	return &BsnTlvDataMask{
		BsnTlv: NewBsnTlv(140),
	}
}

type BsnTlvDecap struct {
	*BsnTlv
	Value BsnDecap
}

func (self *BsnTlvDecap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvDecap(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDecap, error) {
	bsntlvdecap := &BsnTlvDecap{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvDecap packet too short: %d < 2", decoder.Length())
	}
	bsntlvdecap.Value = BsnDecap(decoder.ReadUint16())
	return bsntlvdecap, nil
}

func NewBsnTlvDecap() *BsnTlvDecap {
	return &BsnTlvDecap{
		BsnTlv: NewBsnTlv(85),
	}
}

type BsnTlvDisableSrcMacCheck struct {
	*BsnTlv
}

func (self *BsnTlvDisableSrcMacCheck) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvDisableSrcMacCheck(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDisableSrcMacCheck, error) {
	bsntlvdisablesrcmaccheck := &BsnTlvDisableSrcMacCheck{BsnTlv: parent}
	return bsntlvdisablesrcmaccheck, nil
}

func NewBsnTlvDisableSrcMacCheck() *BsnTlvDisableSrcMacCheck {
	return &BsnTlvDisableSrcMacCheck{
		BsnTlv: NewBsnTlv(120),
	}
}

type BsnTlvDrop struct {
	*BsnTlv
}

func (self *BsnTlvDrop) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvDrop(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDrop, error) {
	bsntlvdrop := &BsnTlvDrop{BsnTlv: parent}
	return bsntlvdrop, nil
}

func NewBsnTlvDrop() *BsnTlvDrop {
	return &BsnTlvDrop{
		BsnTlv: NewBsnTlv(121),
	}
}

type BsnTlvDscp struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvDscp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvDscp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvDscp, error) {
	bsntlvdscp := &BsnTlvDscp{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvDscp packet too short: %d < 2", decoder.Length())
	}
	bsntlvdscp.Value = uint16(decoder.ReadUint16())
	return bsntlvdscp, nil
}

func NewBsnTlvDscp() *BsnTlvDscp {
	return &BsnTlvDscp{
		BsnTlv: NewBsnTlv(112),
	}
}

type BsnTlvEcn struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvEcn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEcn(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEcn, error) {
	bsntlvecn := &BsnTlvEcn{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvEcn packet too short: %d < 1", decoder.Length())
	}
	bsntlvecn.Value = uint8(decoder.ReadByte())
	return bsntlvecn, nil
}

func NewBsnTlvEcn() *BsnTlvEcn {
	return &BsnTlvEcn{
		BsnTlv: NewBsnTlv(132),
	}
}

type BsnTlvEgressOnly struct {
	*BsnTlv
}

func (self *BsnTlvEgressOnly) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEgressOnly(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEgressOnly, error) {
	bsntlvegressonly := &BsnTlvEgressOnly{BsnTlv: parent}
	return bsntlvegressonly, nil
}

func NewBsnTlvEgressOnly() *BsnTlvEgressOnly {
	return &BsnTlvEgressOnly{
		BsnTlv: NewBsnTlv(137),
	}
}

type BsnTlvEgressPortGroupId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvEgressPortGroupId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEgressPortGroupId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEgressPortGroupId, error) {
	bsntlvegressportgroupid := &BsnTlvEgressPortGroupId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvEgressPortGroupId packet too short: %d < 4", decoder.Length())
	}
	bsntlvegressportgroupid.Value = uint32(decoder.ReadUint32())
	return bsntlvegressportgroupid, nil
}

func NewBsnTlvEgressPortGroupId() *BsnTlvEgressPortGroupId {
	return &BsnTlvEgressPortGroupId{
		BsnTlv: NewBsnTlv(139),
	}
}

type BsnTlvEncap struct {
	*BsnTlv
	Value BsnEncap
}

func (self *BsnTlvEncap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEncap(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEncap, error) {
	bsntlvencap := &BsnTlvEncap{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvEncap packet too short: %d < 1", decoder.Length())
	}
	bsntlvencap.Value = BsnEncap(decoder.ReadByte())
	return bsntlvencap, nil
}

func NewBsnTlvEncap() *BsnTlvEncap {
	return &BsnTlvEncap{
		BsnTlv: NewBsnTlv(175),
	}
}

type BsnTlvEnhancedHashCapability struct {
	*BsnTlv
	Value BsnEnhancedHashType
}

func (self *BsnTlvEnhancedHashCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEnhancedHashCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEnhancedHashCapability, error) {
	bsntlvenhancedhashcapability := &BsnTlvEnhancedHashCapability{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvEnhancedHashCapability packet too short: %d < 8", decoder.Length())
	}
	bsntlvenhancedhashcapability.Value = BsnEnhancedHashType(decoder.ReadUint64())
	return bsntlvenhancedhashcapability, nil
}

func NewBsnTlvEnhancedHashCapability() *BsnTlvEnhancedHashCapability {
	return &BsnTlvEnhancedHashCapability{
		BsnTlv: NewBsnTlv(143),
	}
}

type BsnTlvEthDst struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvEthDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEthDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthDst, error) {
	bsntlvethdst := &BsnTlvEthDst{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvEthDst packet too short: %d < 6", decoder.Length())
	}
	bsntlvethdst.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvethdst, nil
}

func NewBsnTlvEthDst() *BsnTlvEthDst {
	return &BsnTlvEthDst{
		BsnTlv: NewBsnTlv(33),
	}
}

type BsnTlvEthSrc struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvEthSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEthSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthSrc, error) {
	bsntlvethsrc := &BsnTlvEthSrc{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvEthSrc packet too short: %d < 6", decoder.Length())
	}
	bsntlvethsrc.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvethsrc, nil
}

func NewBsnTlvEthSrc() *BsnTlvEthSrc {
	return &BsnTlvEthSrc{
		BsnTlv: NewBsnTlv(32),
	}
}

type BsnTlvEthType struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvEthType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvEthType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvEthType, error) {
	bsntlvethtype := &BsnTlvEthType{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvEthType packet too short: %d < 2", decoder.Length())
	}
	bsntlvethtype.Value = uint16(decoder.ReadUint16())
	return bsntlvethtype, nil
}

func NewBsnTlvEthType() *BsnTlvEthType {
	return &BsnTlvEthType{
		BsnTlv: NewBsnTlv(131),
	}
}

type BsnTlvExternalGatewayIp struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalGatewayIp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvExternalGatewayIp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalGatewayIp, error) {
	bsntlvexternalgatewayip := &BsnTlvExternalGatewayIp{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalGatewayIp packet too short: %d < 4", decoder.Length())
	}
	bsntlvexternalgatewayip.Value = net.IP(decoder.Read(4))
	return bsntlvexternalgatewayip, nil
}

func NewBsnTlvExternalGatewayIp() *BsnTlvExternalGatewayIp {
	return &BsnTlvExternalGatewayIp{
		BsnTlv: NewBsnTlv(26),
	}
}

type BsnTlvExternalGatewayMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvExternalGatewayMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvExternalGatewayMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalGatewayMac, error) {
	bsntlvexternalgatewaymac := &BsnTlvExternalGatewayMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvExternalGatewayMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvexternalgatewaymac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvexternalgatewaymac, nil
}

func NewBsnTlvExternalGatewayMac() *BsnTlvExternalGatewayMac {
	return &BsnTlvExternalGatewayMac{
		BsnTlv: NewBsnTlv(29),
	}
}

type BsnTlvExternalIp struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalIp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvExternalIp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalIp, error) {
	bsntlvexternalip := &BsnTlvExternalIp{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalIp packet too short: %d < 4", decoder.Length())
	}
	bsntlvexternalip.Value = net.IP(decoder.Read(4))
	return bsntlvexternalip, nil
}

func NewBsnTlvExternalIp() *BsnTlvExternalIp {
	return &BsnTlvExternalIp{
		BsnTlv: NewBsnTlv(23),
	}
}

type BsnTlvExternalMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvExternalMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvExternalMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalMac, error) {
	bsntlvexternalmac := &BsnTlvExternalMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvExternalMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvexternalmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvexternalmac, nil
}

func NewBsnTlvExternalMac() *BsnTlvExternalMac {
	return &BsnTlvExternalMac{
		BsnTlv: NewBsnTlv(24),
	}
}

type BsnTlvExternalNetmask struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvExternalNetmask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvExternalNetmask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvExternalNetmask, error) {
	bsntlvexternalnetmask := &BsnTlvExternalNetmask{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvExternalNetmask packet too short: %d < 4", decoder.Length())
	}
	bsntlvexternalnetmask.Value = net.IP(decoder.Read(4))
	return bsntlvexternalnetmask, nil
}

func NewBsnTlvExternalNetmask() *BsnTlvExternalNetmask {
	return &BsnTlvExternalNetmask{
		BsnTlv: NewBsnTlv(25),
	}
}

type BsnTlvFabricPortRole struct {
	*BsnTlv
	Value BsnFabricPortRole
}

func (self *BsnTlvFabricPortRole) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvFabricPortRole(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFabricPortRole, error) {
	bsntlvfabricportrole := &BsnTlvFabricPortRole{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvFabricPortRole packet too short: %d < 2", decoder.Length())
	}
	bsntlvfabricportrole.Value = BsnFabricPortRole(decoder.ReadUint16())
	return bsntlvfabricportrole, nil
}

func NewBsnTlvFabricPortRole() *BsnTlvFabricPortRole {
	return &BsnTlvFabricPortRole{
		BsnTlv: NewBsnTlv(165),
	}
}

type BsnTlvFlood struct {
	*BsnTlv
}

func (self *BsnTlvFlood) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvFlood(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlood, error) {
	bsntlvflood := &BsnTlvFlood{BsnTlv: parent}
	return bsntlvflood, nil
}

func NewBsnTlvFlood() *BsnTlvFlood {
	return &BsnTlvFlood{
		BsnTlv: NewBsnTlv(163),
	}
}

type BsnTlvFlowClassifier struct {
	*BsnTlv
	Value BsnFlowClassifier
}

func (self *BsnTlvFlowClassifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvFlowClassifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowClassifier, error) {
	bsntlvflowclassifier := &BsnTlvFlowClassifier{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvFlowClassifier packet too short: %d < 2", decoder.Length())
	}
	bsntlvflowclassifier.Value = BsnFlowClassifier(decoder.ReadUint16())
	return bsntlvflowclassifier, nil
}

func NewBsnTlvFlowClassifier() *BsnTlvFlowClassifier {
	return &BsnTlvFlowClassifier{
		BsnTlv: NewBsnTlv(184),
	}
}

type BsnTlvFlowClassify struct {
	*BsnTlv
}

func (self *BsnTlvFlowClassify) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvFlowClassify(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowClassify, error) {
	bsntlvflowclassify := &BsnTlvFlowClassify{BsnTlv: parent}
	return bsntlvflowclassify, nil
}

func NewBsnTlvFlowClassify() *BsnTlvFlowClassify {
	return &BsnTlvFlowClassify{
		BsnTlv: NewBsnTlv(182),
	}
}

type BsnTlvFlowIdentifier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvFlowIdentifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvFlowIdentifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvFlowIdentifier, error) {
	bsntlvflowidentifier := &BsnTlvFlowIdentifier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvFlowIdentifier packet too short: %d < 4", decoder.Length())
	}
	bsntlvflowidentifier.Value = uint32(decoder.ReadUint32())
	return bsntlvflowidentifier, nil
}

func NewBsnTlvFlowIdentifier() *BsnTlvFlowIdentifier {
	return &BsnTlvFlowIdentifier{
		BsnTlv: NewBsnTlv(183),
	}
}

type BsnTlvForceLinkUp struct {
	*BsnTlv
}

func (self *BsnTlvForceLinkUp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvForceLinkUp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvForceLinkUp, error) {
	bsntlvforcelinkup := &BsnTlvForceLinkUp{BsnTlv: parent}
	return bsntlvforcelinkup, nil
}

func NewBsnTlvForceLinkUp() *BsnTlvForceLinkUp {
	return &BsnTlvForceLinkUp{
		BsnTlv: NewBsnTlv(151),
	}
}

type BsnTlvForwardErrorCorrection struct {
	*BsnTlv
	Value BsnForwardErrorCorrectionType
}

func (self *BsnTlvForwardErrorCorrection) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvForwardErrorCorrection(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvForwardErrorCorrection, error) {
	bsntlvforwarderrorcorrection := &BsnTlvForwardErrorCorrection{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvForwardErrorCorrection packet too short: %d < 1", decoder.Length())
	}
	bsntlvforwarderrorcorrection.Value = BsnForwardErrorCorrectionType(decoder.ReadByte())
	return bsntlvforwarderrorcorrection, nil
}

func NewBsnTlvForwardErrorCorrection() *BsnTlvForwardErrorCorrection {
	return &BsnTlvForwardErrorCorrection{
		BsnTlv: NewBsnTlv(149),
	}
}

type BsnTlvGenerationId struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvGenerationId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvGenerationId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvGenerationId, error) {
	bsntlvgenerationid := &BsnTlvGenerationId{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvGenerationId packet too short: %d < 8", decoder.Length())
	}
	bsntlvgenerationid.Value = uint64(decoder.ReadUint64())
	return bsntlvgenerationid, nil
}

func NewBsnTlvGenerationId() *BsnTlvGenerationId {
	return &BsnTlvGenerationId{
		BsnTlv: NewBsnTlv(80),
	}
}

type BsnTlvHashAlgorithm struct {
	*BsnTlv
	Value BsnHashAlgorithmType
}

func (self *BsnTlvHashAlgorithm) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashAlgorithm(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashAlgorithm, error) {
	bsntlvhashalgorithm := &BsnTlvHashAlgorithm{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvHashAlgorithm packet too short: %d < 2", decoder.Length())
	}
	bsntlvhashalgorithm.Value = BsnHashAlgorithmType(decoder.ReadUint16())
	return bsntlvhashalgorithm, nil
}

func NewBsnTlvHashAlgorithm() *BsnTlvHashAlgorithm {
	return &BsnTlvHashAlgorithm{
		BsnTlv: NewBsnTlv(145),
	}
}

type BsnTlvHashGtpHeaderMatch struct {
	*BsnTlv
	FirstHeaderByte uint8
	FirstHeaderMask uint8
}

func (self *BsnTlvHashGtpHeaderMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.FirstHeaderByte))
	encoder.PutUint8(uint8(self.FirstHeaderMask))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashGtpHeaderMatch(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashGtpHeaderMatch, error) {
	bsntlvhashgtpheadermatch := &BsnTlvHashGtpHeaderMatch{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvHashGtpHeaderMatch packet too short: %d < 2", decoder.Length())
	}
	bsntlvhashgtpheadermatch.FirstHeaderByte = uint8(decoder.ReadByte())
	bsntlvhashgtpheadermatch.FirstHeaderMask = uint8(decoder.ReadByte())
	return bsntlvhashgtpheadermatch, nil
}

func NewBsnTlvHashGtpHeaderMatch() *BsnTlvHashGtpHeaderMatch {
	return &BsnTlvHashGtpHeaderMatch{
		BsnTlv: NewBsnTlv(104),
	}
}

type BsnTlvHashGtpPortMatch struct {
	*BsnTlv
	Match   BsnHashGtpPortMatch
	SrcPort uint16
	DstPort uint16
}

func (self *BsnTlvHashGtpPortMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Match))
	encoder.PutUint16(uint16(self.SrcPort))
	encoder.PutUint16(uint16(self.DstPort))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashGtpPortMatch(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashGtpPortMatch, error) {
	bsntlvhashgtpportmatch := &BsnTlvHashGtpPortMatch{BsnTlv: parent}
	if decoder.Length() < 5 {
		return nil, fmt.Errorf("BsnTlvHashGtpPortMatch packet too short: %d < 5", decoder.Length())
	}
	bsntlvhashgtpportmatch.Match = BsnHashGtpPortMatch(decoder.ReadByte())
	bsntlvhashgtpportmatch.SrcPort = uint16(decoder.ReadUint16())
	bsntlvhashgtpportmatch.DstPort = uint16(decoder.ReadUint16())
	return bsntlvhashgtpportmatch, nil
}

func NewBsnTlvHashGtpPortMatch() *BsnTlvHashGtpPortMatch {
	return &BsnTlvHashGtpPortMatch{
		BsnTlv: NewBsnTlv(105),
	}
}

type BsnTlvHashPacketField struct {
	*BsnTlv
	Value BsnHashPacketField
}

func (self *BsnTlvHashPacketField) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashPacketField(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashPacketField, error) {
	bsntlvhashpacketfield := &BsnTlvHashPacketField{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvHashPacketField packet too short: %d < 8", decoder.Length())
	}
	bsntlvhashpacketfield.Value = BsnHashPacketField(decoder.ReadUint64())
	return bsntlvhashpacketfield, nil
}

func NewBsnTlvHashPacketField() *BsnTlvHashPacketField {
	return &BsnTlvHashPacketField{
		BsnTlv: NewBsnTlv(103),
	}
}

type BsnTlvHashPacketType struct {
	*BsnTlv
	Value BsnHashPacketType
}

func (self *BsnTlvHashPacketType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashPacketType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashPacketType, error) {
	bsntlvhashpackettype := &BsnTlvHashPacketType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvHashPacketType packet too short: %d < 1", decoder.Length())
	}
	bsntlvhashpackettype.Value = BsnHashPacketType(decoder.ReadByte())
	return bsntlvhashpackettype, nil
}

func NewBsnTlvHashPacketType() *BsnTlvHashPacketType {
	return &BsnTlvHashPacketType{
		BsnTlv: NewBsnTlv(102),
	}
}

type BsnTlvHashSeed struct {
	*BsnTlv
	Seed1 uint32
	Seed2 uint32
}

func (self *BsnTlvHashSeed) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Seed1))
	encoder.PutUint32(uint32(self.Seed2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashSeed(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashSeed, error) {
	bsntlvhashseed := &BsnTlvHashSeed{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvHashSeed packet too short: %d < 8", decoder.Length())
	}
	bsntlvhashseed.Seed1 = uint32(decoder.ReadUint32())
	bsntlvhashseed.Seed2 = uint32(decoder.ReadUint32())
	return bsntlvhashseed, nil
}

func NewBsnTlvHashSeed() *BsnTlvHashSeed {
	return &BsnTlvHashSeed{
		BsnTlv: NewBsnTlv(100),
	}
}

type BsnTlvHashType struct {
	*BsnTlv
	Value BsnHashType
}

func (self *BsnTlvHashType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHashType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHashType, error) {
	bsntlvhashtype := &BsnTlvHashType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvHashType packet too short: %d < 1", decoder.Length())
	}
	bsntlvhashtype.Value = BsnHashType(decoder.ReadByte())
	return bsntlvhashtype, nil
}

func NewBsnTlvHashType() *BsnTlvHashType {
	return &BsnTlvHashType{
		BsnTlv: NewBsnTlv(101),
	}
}

type BsnTlvHeaderSize struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvHeaderSize) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvHeaderSize(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvHeaderSize, error) {
	bsntlvheadersize := &BsnTlvHeaderSize{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvHeaderSize packet too short: %d < 4", decoder.Length())
	}
	bsntlvheadersize.Value = uint32(decoder.ReadUint32())
	return bsntlvheadersize, nil
}

func NewBsnTlvHeaderSize() *BsnTlvHeaderSize {
	return &BsnTlvHeaderSize{
		BsnTlv: NewBsnTlv(31),
	}
}

type BsnTlvIcmpCode struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIcmpCode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIcmpCode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpCode, error) {
	bsntlvicmpcode := &BsnTlvIcmpCode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIcmpCode packet too short: %d < 1", decoder.Length())
	}
	bsntlvicmpcode.Value = uint8(decoder.ReadByte())
	return bsntlvicmpcode, nil
}

func NewBsnTlvIcmpCode() *BsnTlvIcmpCode {
	return &BsnTlvIcmpCode{
		BsnTlv: NewBsnTlv(69),
	}
}

type BsnTlvIcmpId struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvIcmpId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIcmpId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpId, error) {
	bsntlvicmpid := &BsnTlvIcmpId{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIcmpId packet too short: %d < 2", decoder.Length())
	}
	bsntlvicmpid.Value = uint16(decoder.ReadUint16())
	return bsntlvicmpid, nil
}

func NewBsnTlvIcmpId() *BsnTlvIcmpId {
	return &BsnTlvIcmpId{
		BsnTlv: NewBsnTlv(70),
	}
}

type BsnTlvIcmpType struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIcmpType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIcmpType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpType, error) {
	bsntlvicmptype := &BsnTlvIcmpType{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIcmpType packet too short: %d < 1", decoder.Length())
	}
	bsntlvicmptype.Value = uint8(decoder.ReadByte())
	return bsntlvicmptype, nil
}

func NewBsnTlvIcmpType() *BsnTlvIcmpType {
	return &BsnTlvIcmpType{
		BsnTlv: NewBsnTlv(68),
	}
}

type BsnTlvIcmpv6Chksum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvIcmpv6Chksum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIcmpv6Chksum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIcmpv6Chksum, error) {
	bsntlvicmpv6chksum := &BsnTlvIcmpv6Chksum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIcmpv6Chksum packet too short: %d < 2", decoder.Length())
	}
	bsntlvicmpv6chksum.Value = uint16(decoder.ReadUint16())
	return bsntlvicmpv6chksum, nil
}

func NewBsnTlvIcmpv6Chksum() *BsnTlvIcmpv6Chksum {
	return &BsnTlvIcmpv6Chksum{
		BsnTlv: NewBsnTlv(125),
	}
}

type BsnTlvIdentifier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIdentifier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIdentifier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdentifier, error) {
	bsntlvidentifier := &BsnTlvIdentifier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIdentifier packet too short: %d < 4", decoder.Length())
	}
	bsntlvidentifier.Value = uint32(decoder.ReadUint32())
	return bsntlvidentifier, nil
}

func NewBsnTlvIdentifier() *BsnTlvIdentifier {
	return &BsnTlvIdentifier{
		BsnTlv: NewBsnTlv(173),
	}
}

type BsnTlvIdleNotification struct {
	*BsnTlv
}

func (self *BsnTlvIdleNotification) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIdleNotification(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleNotification, error) {
	bsntlvidlenotification := &BsnTlvIdleNotification{BsnTlv: parent}
	return bsntlvidlenotification, nil
}

func NewBsnTlvIdleNotification() *BsnTlvIdleNotification {
	return &BsnTlvIdleNotification{
		BsnTlv: NewBsnTlv(7),
	}
}

type BsnTlvIdleTime struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvIdleTime) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIdleTime(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleTime, error) {
	bsntlvidletime := &BsnTlvIdleTime{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvIdleTime packet too short: %d < 8", decoder.Length())
	}
	bsntlvidletime.Value = uint64(decoder.ReadUint64())
	return bsntlvidletime, nil
}

func NewBsnTlvIdleTime() *BsnTlvIdleTime {
	return &BsnTlvIdleTime{
		BsnTlv: NewBsnTlv(5),
	}
}

type BsnTlvIdleTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIdleTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIdleTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIdleTimeout, error) {
	bsntlvidletimeout := &BsnTlvIdleTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIdleTimeout packet too short: %d < 4", decoder.Length())
	}
	bsntlvidletimeout.Value = uint32(decoder.ReadUint32())
	return bsntlvidletimeout, nil
}

func NewBsnTlvIdleTimeout() *BsnTlvIdleTimeout {
	return &BsnTlvIdleTimeout{
		BsnTlv: NewBsnTlv(8),
	}
}

type BsnTlvIgmpSnooping struct {
	*BsnTlv
}

func (self *BsnTlvIgmpSnooping) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIgmpSnooping(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIgmpSnooping, error) {
	bsntlvigmpsnooping := &BsnTlvIgmpSnooping{BsnTlv: parent}
	return bsntlvigmpsnooping, nil
}

func NewBsnTlvIgmpSnooping() *BsnTlvIgmpSnooping {
	return &BsnTlvIgmpSnooping{
		BsnTlv: NewBsnTlv(78),
	}
}

type BsnTlvIngressPortGroupId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvIngressPortGroupId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIngressPortGroupId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIngressPortGroupId, error) {
	bsntlvingressportgroupid := &BsnTlvIngressPortGroupId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIngressPortGroupId packet too short: %d < 4", decoder.Length())
	}
	bsntlvingressportgroupid.Value = uint32(decoder.ReadUint32())
	return bsntlvingressportgroupid, nil
}

func NewBsnTlvIngressPortGroupId() *BsnTlvIngressPortGroupId {
	return &BsnTlvIngressPortGroupId{
		BsnTlv: NewBsnTlv(138),
	}
}

type BsnTlvInternalGatewayMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvInternalGatewayMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvInternalGatewayMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInternalGatewayMac, error) {
	bsntlvinternalgatewaymac := &BsnTlvInternalGatewayMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvInternalGatewayMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvinternalgatewaymac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvinternalgatewaymac, nil
}

func NewBsnTlvInternalGatewayMac() *BsnTlvInternalGatewayMac {
	return &BsnTlvInternalGatewayMac{
		BsnTlv: NewBsnTlv(28),
	}
}

type BsnTlvInternalMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvInternalMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvInternalMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInternalMac, error) {
	bsntlvinternalmac := &BsnTlvInternalMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvInternalMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvinternalmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvinternalmac, nil
}

func NewBsnTlvInternalMac() *BsnTlvInternalMac {
	return &BsnTlvInternalMac{
		BsnTlv: NewBsnTlv(27),
	}
}

type BsnTlvInterval struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvInterval) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvInterval(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvInterval, error) {
	bsntlvinterval := &BsnTlvInterval{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvInterval packet too short: %d < 4", decoder.Length())
	}
	bsntlvinterval.Value = uint32(decoder.ReadUint32())
	return bsntlvinterval, nil
}

func NewBsnTlvInterval() *BsnTlvInterval {
	return &BsnTlvInterval{
		BsnTlv: NewBsnTlv(58),
	}
}

type BsnTlvIpProto struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvIpProto) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpProto(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpProto, error) {
	bsntlvipproto := &BsnTlvIpProto{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvIpProto packet too short: %d < 1", decoder.Length())
	}
	bsntlvipproto.Value = uint8(decoder.ReadByte())
	return bsntlvipproto, nil
}

func NewBsnTlvIpProto() *BsnTlvIpProto {
	return &BsnTlvIpProto{
		BsnTlv: NewBsnTlv(67),
	}
}

type BsnTlvIpTunnelType struct {
	*BsnTlv
	Value BsnIpTunnelType
}

func (self *BsnTlvIpTunnelType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpTunnelType(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpTunnelType, error) {
	bsntlviptunneltype := &BsnTlvIpTunnelType{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvIpTunnelType packet too short: %d < 2", decoder.Length())
	}
	bsntlviptunneltype.Value = BsnIpTunnelType(decoder.ReadUint16())
	return bsntlviptunneltype, nil
}

func NewBsnTlvIpTunnelType() *BsnTlvIpTunnelType {
	return &BsnTlvIpTunnelType{
		BsnTlv: NewBsnTlv(169),
	}
}

type BsnTlvIpv4 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv4(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4, error) {
	bsntlvipv4 := &BsnTlvIpv4{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4 packet too short: %d < 4", decoder.Length())
	}
	bsntlvipv4.Value = net.IP(decoder.Read(4))
	return bsntlvipv4, nil
}

func NewBsnTlvIpv4() *BsnTlvIpv4 {
	return &BsnTlvIpv4{
		BsnTlv: NewBsnTlv(4),
	}
}

type BsnTlvIpv4Dst struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Dst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv4Dst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Dst, error) {
	bsntlvipv4dst := &BsnTlvIpv4Dst{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Dst packet too short: %d < 4", decoder.Length())
	}
	bsntlvipv4dst.Value = net.IP(decoder.Read(4))
	return bsntlvipv4dst, nil
}

func NewBsnTlvIpv4Dst() *BsnTlvIpv4Dst {
	return &BsnTlvIpv4Dst{
		BsnTlv: NewBsnTlv(35),
	}
}

type BsnTlvIpv4Netmask struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Netmask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv4Netmask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Netmask, error) {
	bsntlvipv4netmask := &BsnTlvIpv4Netmask{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Netmask packet too short: %d < 4", decoder.Length())
	}
	bsntlvipv4netmask.Value = net.IP(decoder.Read(4))
	return bsntlvipv4netmask, nil
}

func NewBsnTlvIpv4Netmask() *BsnTlvIpv4Netmask {
	return &BsnTlvIpv4Netmask{
		BsnTlv: NewBsnTlv(60),
	}
}

type BsnTlvIpv4Src struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv4Src) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv4Src(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv4Src, error) {
	bsntlvipv4src := &BsnTlvIpv4Src{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvIpv4Src packet too short: %d < 4", decoder.Length())
	}
	bsntlvipv4src.Value = net.IP(decoder.Read(4))
	return bsntlvipv4src, nil
}

func NewBsnTlvIpv4Src() *BsnTlvIpv4Src {
	return &BsnTlvIpv4Src{
		BsnTlv: NewBsnTlv(34),
	}
}

type BsnTlvIpv6 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv6(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6, error) {
	bsntlvipv6 := &BsnTlvIpv6{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6 packet too short: %d < 16", decoder.Length())
	}
	bsntlvipv6.Value = net.IP(decoder.Read(16))
	return bsntlvipv6, nil
}

func NewBsnTlvIpv6() *BsnTlvIpv6 {
	return &BsnTlvIpv6{
		BsnTlv: NewBsnTlv(84),
	}
}

type BsnTlvIpv6Dst struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6Dst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv6Dst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Dst, error) {
	bsntlvipv6dst := &BsnTlvIpv6Dst{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6Dst packet too short: %d < 16", decoder.Length())
	}
	bsntlvipv6dst.Value = net.IP(decoder.Read(16))
	return bsntlvipv6dst, nil
}

func NewBsnTlvIpv6Dst() *BsnTlvIpv6Dst {
	return &BsnTlvIpv6Dst{
		BsnTlv: NewBsnTlv(127),
	}
}

type BsnTlvIpv6Prefix struct {
	*BsnTlv
	Value        net.IP
	PrefixLength uint8
}

func (self *BsnTlvIpv6Prefix) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())
	encoder.PutUint8(uint8(self.PrefixLength))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv6Prefix(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Prefix, error) {
	bsntlvipv6prefix := &BsnTlvIpv6Prefix{BsnTlv: parent}
	if decoder.Length() < 17 {
		return nil, fmt.Errorf("BsnTlvIpv6Prefix packet too short: %d < 17", decoder.Length())
	}
	bsntlvipv6prefix.Value = net.IP(decoder.Read(16))
	bsntlvipv6prefix.PrefixLength = uint8(decoder.ReadByte())
	return bsntlvipv6prefix, nil
}

func NewBsnTlvIpv6Prefix() *BsnTlvIpv6Prefix {
	return &BsnTlvIpv6Prefix{
		BsnTlv: NewBsnTlv(122),
	}
}

type BsnTlvIpv6Src struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvIpv6Src) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To16())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvIpv6Src(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvIpv6Src, error) {
	bsntlvipv6src := &BsnTlvIpv6Src{BsnTlv: parent}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BsnTlvIpv6Src packet too short: %d < 16", decoder.Length())
	}
	bsntlvipv6src.Value = net.IP(decoder.Read(16))
	return bsntlvipv6src, nil
}

func NewBsnTlvIpv6Src() *BsnTlvIpv6Src {
	return &BsnTlvIpv6Src{
		BsnTlv: NewBsnTlv(126),
	}
}

type BsnTlvKnownMulticastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvKnownMulticastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvKnownMulticastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvKnownMulticastRate, error) {
	bsntlvknownmulticastrate := &BsnTlvKnownMulticastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvKnownMulticastRate packet too short: %d < 4", decoder.Length())
	}
	bsntlvknownmulticastrate.Value = uint32(decoder.ReadUint32())
	return bsntlvknownmulticastrate, nil
}

func NewBsnTlvKnownMulticastRate() *BsnTlvKnownMulticastRate {
	return &BsnTlvKnownMulticastRate{
		BsnTlv: NewBsnTlv(91),
	}
}

type BsnTlvL2MulticastLookup struct {
	*BsnTlv
}

func (self *BsnTlvL2MulticastLookup) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvL2MulticastLookup(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL2MulticastLookup, error) {
	bsntlvl2multicastlookup := &BsnTlvL2MulticastLookup{BsnTlv: parent}
	return bsntlvl2multicastlookup, nil
}

func NewBsnTlvL2MulticastLookup() *BsnTlvL2MulticastLookup {
	return &BsnTlvL2MulticastLookup{
		BsnTlv: NewBsnTlv(79),
	}
}

type BsnTlvL3 struct {
	*BsnTlv
}

func (self *BsnTlvL3) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvL3(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3, error) {
	bsntlvl3 := &BsnTlvL3{BsnTlv: parent}
	return bsntlvl3, nil
}

func NewBsnTlvL3() *BsnTlvL3 {
	return &BsnTlvL3{
		BsnTlv: NewBsnTlv(168),
	}
}

type BsnTlvL3DstClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3DstClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvL3DstClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3DstClassId, error) {
	bsntlvl3dstclassid := &BsnTlvL3DstClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3DstClassId packet too short: %d < 4", decoder.Length())
	}
	bsntlvl3dstclassid.Value = uint32(decoder.ReadUint32())
	return bsntlvl3dstclassid, nil
}

func NewBsnTlvL3DstClassId() *BsnTlvL3DstClassId {
	return &BsnTlvL3DstClassId{
		BsnTlv: NewBsnTlv(136),
	}
}

type BsnTlvL3InterfaceClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3InterfaceClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvL3InterfaceClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3InterfaceClassId, error) {
	bsntlvl3interfaceclassid := &BsnTlvL3InterfaceClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3InterfaceClassId packet too short: %d < 4", decoder.Length())
	}
	bsntlvl3interfaceclassid.Value = uint32(decoder.ReadUint32())
	return bsntlvl3interfaceclassid, nil
}

func NewBsnTlvL3InterfaceClassId() *BsnTlvL3InterfaceClassId {
	return &BsnTlvL3InterfaceClassId{
		BsnTlv: NewBsnTlv(134),
	}
}

type BsnTlvL3SrcClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvL3SrcClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvL3SrcClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvL3SrcClassId, error) {
	bsntlvl3srcclassid := &BsnTlvL3SrcClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvL3SrcClassId packet too short: %d < 4", decoder.Length())
	}
	bsntlvl3srcclassid.Value = uint32(decoder.ReadUint32())
	return bsntlvl3srcclassid, nil
}

func NewBsnTlvL3SrcClassId() *BsnTlvL3SrcClassId {
	return &BsnTlvL3SrcClassId{
		BsnTlv: NewBsnTlv(135),
	}
}

type BsnTlvLagOptions struct {
	*BsnTlv
	Flags BsnLagFlag
}

func (self *BsnTlvLagOptions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvLagOptions(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLagOptions, error) {
	bsntlvlagoptions := &BsnTlvLagOptions{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvLagOptions packet too short: %d < 2", decoder.Length())
	}
	bsntlvlagoptions.Flags = BsnLagFlag(decoder.ReadUint16())
	return bsntlvlagoptions, nil
}

func NewBsnTlvLagOptions() *BsnTlvLagOptions {
	return &BsnTlvLagOptions{
		BsnTlv: NewBsnTlv(160),
	}
}

type BsnTlvLoopbackMode struct {
	*BsnTlv
	Value BsnLoopbackMode
}

func (self *BsnTlvLoopbackMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvLoopbackMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLoopbackMode, error) {
	bsntlvloopbackmode := &BsnTlvLoopbackMode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvLoopbackMode packet too short: %d < 1", decoder.Length())
	}
	bsntlvloopbackmode.Value = BsnLoopbackMode(decoder.ReadByte())
	return bsntlvloopbackmode, nil
}

func NewBsnTlvLoopbackMode() *BsnTlvLoopbackMode {
	return &BsnTlvLoopbackMode{
		BsnTlv: NewBsnTlv(146),
	}
}

type BsnTlvLoopbackPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvLoopbackPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvLoopbackPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLoopbackPort, error) {
	bsntlvloopbackport := &BsnTlvLoopbackPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvLoopbackPort packet too short: %d < 4", decoder.Length())
	}
	bsntlvloopbackport.Value.Decode(decoder)
	return bsntlvloopbackport, nil
}

func NewBsnTlvLoopbackPort() *BsnTlvLoopbackPort {
	return &BsnTlvLoopbackPort{
		BsnTlv: NewBsnTlv(110),
	}
}

type BsnTlvLrAllEnabled struct {
	*BsnTlv
}

func (self *BsnTlvLrAllEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvLrAllEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvLrAllEnabled, error) {
	bsntlvlrallenabled := &BsnTlvLrAllEnabled{BsnTlv: parent}
	return bsntlvlrallenabled, nil
}

func NewBsnTlvLrAllEnabled() *BsnTlvLrAllEnabled {
	return &BsnTlvLrAllEnabled{
		BsnTlv: NewBsnTlv(178),
	}
}

type BsnTlvMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMac, error) {
	bsntlvmac := &BsnTlvMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvmac, nil
}

func NewBsnTlvMac() *BsnTlvMac {
	return &BsnTlvMac{
		BsnTlv: NewBsnTlv(1),
	}
}

type BsnTlvMacMask struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvMacMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMacMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMacMask, error) {
	bsntlvmacmask := &BsnTlvMacMask{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvMacMask packet too short: %d < 6", decoder.Length())
	}
	bsntlvmacmask.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvmacmask, nil
}

func NewBsnTlvMacMask() *BsnTlvMacMask {
	return &BsnTlvMacMask{
		BsnTlv: NewBsnTlv(56),
	}
}

type BsnTlvMcgTypeVxlan struct {
	*BsnTlv
}

func (self *BsnTlvMcgTypeVxlan) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMcgTypeVxlan(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMcgTypeVxlan, error) {
	bsntlvmcgtypevxlan := &BsnTlvMcgTypeVxlan{BsnTlv: parent}
	return bsntlvmcgtypevxlan, nil
}

func NewBsnTlvMcgTypeVxlan() *BsnTlvMcgTypeVxlan {
	return &BsnTlvMcgTypeVxlan{
		BsnTlv: NewBsnTlv(87),
	}
}

type BsnTlvMissPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvMissPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMissPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMissPackets, error) {
	bsntlvmisspackets := &BsnTlvMissPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvMissPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvmisspackets.Value = uint64(decoder.ReadUint64())
	return bsntlvmisspackets, nil
}

func NewBsnTlvMissPackets() *BsnTlvMissPackets {
	return &BsnTlvMissPackets{
		BsnTlv: NewBsnTlv(13),
	}
}

type BsnTlvMplsControlWord struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvMplsControlWord) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMplsControlWord(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsControlWord, error) {
	bsntlvmplscontrolword := &BsnTlvMplsControlWord{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvMplsControlWord packet too short: %d < 1", decoder.Length())
	}
	bsntlvmplscontrolword.Value = uint8(decoder.ReadByte())
	return bsntlvmplscontrolword, nil
}

func NewBsnTlvMplsControlWord() *BsnTlvMplsControlWord {
	return &BsnTlvMplsControlWord{
		BsnTlv: NewBsnTlv(62),
	}
}

type BsnTlvMplsLabel struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMplsLabel) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMplsLabel(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsLabel, error) {
	bsntlvmplslabel := &BsnTlvMplsLabel{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMplsLabel packet too short: %d < 4", decoder.Length())
	}
	bsntlvmplslabel.Value = uint32(decoder.ReadUint32())
	return bsntlvmplslabel, nil
}

func NewBsnTlvMplsLabel() *BsnTlvMplsLabel {
	return &BsnTlvMplsLabel{
		BsnTlv: NewBsnTlv(61),
	}
}

type BsnTlvMplsSequenced struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvMplsSequenced) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMplsSequenced(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMplsSequenced, error) {
	bsntlvmplssequenced := &BsnTlvMplsSequenced{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvMplsSequenced packet too short: %d < 1", decoder.Length())
	}
	bsntlvmplssequenced.Value = uint8(decoder.ReadByte())
	return bsntlvmplssequenced, nil
}

func NewBsnTlvMplsSequenced() *BsnTlvMplsSequenced {
	return &BsnTlvMplsSequenced{
		BsnTlv: NewBsnTlv(63),
	}
}

type BsnTlvMulticastInterfaceId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMulticastInterfaceId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMulticastInterfaceId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMulticastInterfaceId, error) {
	bsntlvmulticastinterfaceid := &BsnTlvMulticastInterfaceId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMulticastInterfaceId packet too short: %d < 4", decoder.Length())
	}
	bsntlvmulticastinterfaceid.Value = uint32(decoder.ReadUint32())
	return bsntlvmulticastinterfaceid, nil
}

func NewBsnTlvMulticastInterfaceId() *BsnTlvMulticastInterfaceId {
	return &BsnTlvMulticastInterfaceId{
		BsnTlv: NewBsnTlv(95),
	}
}

type BsnTlvMulticastPacket struct {
	*BsnTlv
	Value BsnMulticastPacket
}

func (self *BsnTlvMulticastPacket) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMulticastPacket(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMulticastPacket, error) {
	bsntlvmulticastpacket := &BsnTlvMulticastPacket{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvMulticastPacket packet too short: %d < 2", decoder.Length())
	}
	bsntlvmulticastpacket.Value = BsnMulticastPacket(decoder.ReadUint16())
	return bsntlvmulticastpacket, nil
}

func NewBsnTlvMulticastPacket() *BsnTlvMulticastPacket {
	return &BsnTlvMulticastPacket{
		BsnTlv: NewBsnTlv(170),
	}
}

type BsnTlvMultiplier struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvMultiplier) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvMultiplier(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvMultiplier, error) {
	bsntlvmultiplier := &BsnTlvMultiplier{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvMultiplier packet too short: %d < 4", decoder.Length())
	}
	bsntlvmultiplier.Value = uint32(decoder.ReadUint32())
	return bsntlvmultiplier, nil
}

func NewBsnTlvMultiplier() *BsnTlvMultiplier {
	return &BsnTlvMultiplier{
		BsnTlv: NewBsnTlv(174),
	}
}

type BsnTlvName struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvName) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvName(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvName, error) {
	bsntlvname := &BsnTlvName{BsnTlv: parent}
	bsntlvname.Value = decoder.Read(decoder.Length())
	return bsntlvname, nil
}

func NewBsnTlvName() *BsnTlvName {
	return &BsnTlvName{
		BsnTlv: NewBsnTlv(52),
	}
}

type BsnTlvNdpOffload struct {
	*BsnTlv
}

func (self *BsnTlvNdpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNdpOffload(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNdpOffload, error) {
	bsntlvndpoffload := &BsnTlvNdpOffload{BsnTlv: parent}
	return bsntlvndpoffload, nil
}

func NewBsnTlvNdpOffload() *BsnTlvNdpOffload {
	return &BsnTlvNdpOffload{
		BsnTlv: NewBsnTlv(123),
	}
}

type BsnTlvNdpStatic struct {
	*BsnTlv
}

func (self *BsnTlvNdpStatic) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNdpStatic(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNdpStatic, error) {
	bsntlvndpstatic := &BsnTlvNdpStatic{BsnTlv: parent}
	return bsntlvndpstatic, nil
}

func NewBsnTlvNdpStatic() *BsnTlvNdpStatic {
	return &BsnTlvNdpStatic{
		BsnTlv: NewBsnTlv(124),
	}
}

type BsnTlvNegate struct {
	*BsnTlv
}

func (self *BsnTlvNegate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNegate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNegate, error) {
	bsntlvnegate := &BsnTlvNegate{BsnTlv: parent}
	return bsntlvnegate, nil
}

func NewBsnTlvNegate() *BsnTlvNegate {
	return &BsnTlvNegate{
		BsnTlv: NewBsnTlv(83),
	}
}

type BsnTlvNextHopIpv4 struct {
	*BsnTlv
	Value net.IP
}

func (self *BsnTlvNextHopIpv4) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value.To4())

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNextHopIpv4(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNextHopIpv4, error) {
	bsntlvnexthopipv4 := &BsnTlvNextHopIpv4{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvNextHopIpv4 packet too short: %d < 4", decoder.Length())
	}
	bsntlvnexthopipv4.Value = net.IP(decoder.Read(4))
	return bsntlvnexthopipv4, nil
}

func NewBsnTlvNextHopIpv4() *BsnTlvNextHopIpv4 {
	return &BsnTlvNextHopIpv4{
		BsnTlv: NewBsnTlv(115),
	}
}

type BsnTlvNextHopMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvNextHopMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNextHopMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNextHopMac, error) {
	bsntlvnexthopmac := &BsnTlvNextHopMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvNextHopMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvnexthopmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvnexthopmac, nil
}

func NewBsnTlvNextHopMac() *BsnTlvNextHopMac {
	return &BsnTlvNextHopMac{
		BsnTlv: NewBsnTlv(114),
	}
}

type BsnTlvNexthopTypeVxlan struct {
	*BsnTlv
}

func (self *BsnTlvNexthopTypeVxlan) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNexthopTypeVxlan(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNexthopTypeVxlan, error) {
	bsntlvnexthoptypevxlan := &BsnTlvNexthopTypeVxlan{BsnTlv: parent}
	return bsntlvnexthoptypevxlan, nil
}

func NewBsnTlvNexthopTypeVxlan() *BsnTlvNexthopTypeVxlan {
	return &BsnTlvNexthopTypeVxlan{
		BsnTlv: NewBsnTlv(94),
	}
}

type BsnTlvNoArpResponse struct {
	*BsnTlv
}

func (self *BsnTlvNoArpResponse) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNoArpResponse(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNoArpResponse, error) {
	bsntlvnoarpresponse := &BsnTlvNoArpResponse{BsnTlv: parent}
	return bsntlvnoarpresponse, nil
}

func NewBsnTlvNoArpResponse() *BsnTlvNoArpResponse {
	return &BsnTlvNoArpResponse{
		BsnTlv: NewBsnTlv(147),
	}
}

type BsnTlvNoNsResponse struct {
	*BsnTlv
}

func (self *BsnTlvNoNsResponse) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvNoNsResponse(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvNoNsResponse, error) {
	bsntlvnonsresponse := &BsnTlvNoNsResponse{BsnTlv: parent}
	return bsntlvnonsresponse, nil
}

func NewBsnTlvNoNsResponse() *BsnTlvNoNsResponse {
	return &BsnTlvNoNsResponse{
		BsnTlv: NewBsnTlv(148),
	}
}

type BsnTlvOffset struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvOffset) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvOffset(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOffset, error) {
	bsntlvoffset := &BsnTlvOffset{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvOffset packet too short: %d < 2", decoder.Length())
	}
	bsntlvoffset.Value = uint16(decoder.ReadUint16())
	return bsntlvoffset, nil
}

func NewBsnTlvOffset() *BsnTlvOffset {
	return &BsnTlvOffset{
		BsnTlv: NewBsnTlv(82),
	}
}

type BsnTlvOpticsAlwaysEnabled struct {
	*BsnTlv
}

func (self *BsnTlvOpticsAlwaysEnabled) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvOpticsAlwaysEnabled(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOpticsAlwaysEnabled, error) {
	bsntlvopticsalwaysenabled := &BsnTlvOpticsAlwaysEnabled{BsnTlv: parent}
	return bsntlvopticsalwaysenabled, nil
}

func NewBsnTlvOpticsAlwaysEnabled() *BsnTlvOpticsAlwaysEnabled {
	return &BsnTlvOpticsAlwaysEnabled{
		BsnTlv: NewBsnTlv(150),
	}
}

type BsnTlvOuterSrcMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvOuterSrcMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvOuterSrcMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvOuterSrcMac, error) {
	bsntlvoutersrcmac := &BsnTlvOuterSrcMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvOuterSrcMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvoutersrcmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvoutersrcmac, nil
}

func NewBsnTlvOuterSrcMac() *BsnTlvOuterSrcMac {
	return &BsnTlvOuterSrcMac{
		BsnTlv: NewBsnTlv(157),
	}
}

type BsnTlvParentPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvParentPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvParentPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvParentPort, error) {
	bsntlvparentport := &BsnTlvParentPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvParentPort packet too short: %d < 4", decoder.Length())
	}
	bsntlvparentport.Value.Decode(decoder)
	return bsntlvparentport, nil
}

func NewBsnTlvParentPort() *BsnTlvParentPort {
	return &BsnTlvParentPort{
		BsnTlv: NewBsnTlv(109),
	}
}

type BsnTlvPartnerKey struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerKey, error) {
	bsntlvpartnerkey := &BsnTlvPartnerKey{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerKey packet too short: %d < 2", decoder.Length())
	}
	bsntlvpartnerkey.Value = uint16(decoder.ReadUint16())
	return bsntlvpartnerkey, nil
}

func NewBsnTlvPartnerKey() *BsnTlvPartnerKey {
	return &BsnTlvPartnerKey{
		BsnTlv: NewBsnTlv(51),
	}
}

type BsnTlvPartnerPortNum struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerPortNum) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerPortNum(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerPortNum, error) {
	bsntlvpartnerportnum := &BsnTlvPartnerPortNum{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerPortNum packet too short: %d < 2", decoder.Length())
	}
	bsntlvpartnerportnum.Value = uint16(decoder.ReadUint16())
	return bsntlvpartnerportnum, nil
}

func NewBsnTlvPartnerPortNum() *BsnTlvPartnerPortNum {
	return &BsnTlvPartnerPortNum{
		BsnTlv: NewBsnTlv(50),
	}
}

type BsnTlvPartnerPortPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerPortPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerPortPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerPortPriority, error) {
	bsntlvpartnerportpriority := &BsnTlvPartnerPortPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerPortPriority packet too short: %d < 2", decoder.Length())
	}
	bsntlvpartnerportpriority.Value = uint16(decoder.ReadUint16())
	return bsntlvpartnerportpriority, nil
}

func NewBsnTlvPartnerPortPriority() *BsnTlvPartnerPortPriority {
	return &BsnTlvPartnerPortPriority{
		BsnTlv: NewBsnTlv(49),
	}
}

type BsnTlvPartnerState struct {
	*BsnTlv
	Value BsnLacpState
}

func (self *BsnTlvPartnerState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerState, error) {
	bsntlvpartnerstate := &BsnTlvPartnerState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPartnerState packet too short: %d < 1", decoder.Length())
	}
	bsntlvpartnerstate.Value = BsnLacpState(decoder.ReadByte())
	return bsntlvpartnerstate, nil
}

func NewBsnTlvPartnerState() *BsnTlvPartnerState {
	return &BsnTlvPartnerState{
		BsnTlv: NewBsnTlv(54),
	}
}

type BsnTlvPartnerSystemMac struct {
	*BsnTlv
	Value net.HardwareAddr
}

func (self *BsnTlvPartnerSystemMac) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerSystemMac(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerSystemMac, error) {
	bsntlvpartnersystemmac := &BsnTlvPartnerSystemMac{BsnTlv: parent}
	if decoder.Length() < 6 {
		return nil, fmt.Errorf("BsnTlvPartnerSystemMac packet too short: %d < 6", decoder.Length())
	}
	bsntlvpartnersystemmac.Value = net.HardwareAddr(decoder.Read(6))
	return bsntlvpartnersystemmac, nil
}

func NewBsnTlvPartnerSystemMac() *BsnTlvPartnerSystemMac {
	return &BsnTlvPartnerSystemMac{
		BsnTlv: NewBsnTlv(48),
	}
}

type BsnTlvPartnerSystemPriority struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvPartnerSystemPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPartnerSystemPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPartnerSystemPriority, error) {
	bsntlvpartnersystempriority := &BsnTlvPartnerSystemPriority{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPartnerSystemPriority packet too short: %d < 2", decoder.Length())
	}
	bsntlvpartnersystempriority.Value = uint16(decoder.ReadUint16())
	return bsntlvpartnersystempriority, nil
}

func NewBsnTlvPartnerSystemPriority() *BsnTlvPartnerSystemPriority {
	return &BsnTlvPartnerSystemPriority{
		BsnTlv: NewBsnTlv(47),
	}
}

type BsnTlvPassive struct {
	*BsnTlv
}

func (self *BsnTlvPassive) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPassive(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPassive, error) {
	bsntlvpassive := &BsnTlvPassive{BsnTlv: parent}
	return bsntlvpassive, nil
}

func NewBsnTlvPassive() *BsnTlvPassive {
	return &BsnTlvPassive{
		BsnTlv: NewBsnTlv(172),
	}
}

type BsnTlvPduaRxInstance struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvPduaRxInstance) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPduaRxInstance(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPduaRxInstance, error) {
	bsntlvpduarxinstance := &BsnTlvPduaRxInstance{BsnTlv: parent}
	bsntlvpduarxinstance.Value = decoder.Read(decoder.Length())
	return bsntlvpduarxinstance, nil
}

func NewBsnTlvPduaRxInstance() *BsnTlvPduaRxInstance {
	return &BsnTlvPduaRxInstance{
		BsnTlv: NewBsnTlv(159),
	}
}

type BsnTlvPimDr struct {
	*BsnTlv
}

func (self *BsnTlvPimDr) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPimDr(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPimDr, error) {
	bsntlvpimdr := &BsnTlvPimDr{BsnTlv: parent}
	return bsntlvpimdr, nil
}

func NewBsnTlvPimDr() *BsnTlvPimDr {
	return &BsnTlvPimDr{
		BsnTlv: NewBsnTlv(171),
	}
}

type BsnTlvPimHelloFlood struct {
	*BsnTlv
}

func (self *BsnTlvPimHelloFlood) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPimHelloFlood(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPimHelloFlood, error) {
	bsntlvpimhelloflood := &BsnTlvPimHelloFlood{BsnTlv: parent}
	return bsntlvpimhelloflood, nil
}

func NewBsnTlvPimHelloFlood() *BsnTlvPimHelloFlood {
	return &BsnTlvPimHelloFlood{
		BsnTlv: NewBsnTlv(181),
	}
}

type BsnTlvPort struct {
	*BsnTlv
	Value PortNo
}

func (self *BsnTlvPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	self.Value.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPort(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPort, error) {
	bsntlvport := &BsnTlvPort{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPort packet too short: %d < 4", decoder.Length())
	}
	bsntlvport.Value.Decode(decoder)
	return bsntlvport, nil
}

func NewBsnTlvPort() *BsnTlvPort {
	return &BsnTlvPort{
		BsnTlv: NewBsnTlv(0),
	}
}

type BsnTlvPortMode struct {
	*BsnTlv
	Value BsnPortMode
}

func (self *BsnTlvPortMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPortMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortMode, error) {
	bsntlvportmode := &BsnTlvPortMode{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPortMode packet too short: %d < 2", decoder.Length())
	}
	bsntlvportmode.Value = BsnPortMode(decoder.ReadUint16())
	return bsntlvportmode, nil
}

func NewBsnTlvPortMode() *BsnTlvPortMode {
	return &BsnTlvPortMode{
		BsnTlv: NewBsnTlv(179),
	}
}

type BsnTlvPortSpeedGbps struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvPortSpeedGbps) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPortSpeedGbps(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortSpeedGbps, error) {
	bsntlvportspeedgbps := &BsnTlvPortSpeedGbps{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPortSpeedGbps packet too short: %d < 4", decoder.Length())
	}
	bsntlvportspeedgbps.Value = uint32(decoder.ReadUint32())
	return bsntlvportspeedgbps, nil
}

func NewBsnTlvPortSpeedGbps() *BsnTlvPortSpeedGbps {
	return &BsnTlvPortSpeedGbps{
		BsnTlv: NewBsnTlv(156),
	}
}

type BsnTlvPortUsage struct {
	*BsnTlv
	Value BsnPortUsage
}

func (self *BsnTlvPortUsage) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPortUsage(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortUsage, error) {
	bsntlvportusage := &BsnTlvPortUsage{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvPortUsage packet too short: %d < 2", decoder.Length())
	}
	bsntlvportusage.Value = BsnPortUsage(decoder.ReadUint16())
	return bsntlvportusage, nil
}

func NewBsnTlvPortUsage() *BsnTlvPortUsage {
	return &BsnTlvPortUsage{
		BsnTlv: NewBsnTlv(141),
	}
}

type BsnTlvPortVxlanMode struct {
	*BsnTlv
	Value BsnPortVxlanMode
}

func (self *BsnTlvPortVxlanMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPortVxlanMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPortVxlanMode, error) {
	bsntlvportvxlanmode := &BsnTlvPortVxlanMode{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPortVxlanMode packet too short: %d < 1", decoder.Length())
	}
	bsntlvportvxlanmode.Value = BsnPortVxlanMode(decoder.ReadByte())
	return bsntlvportvxlanmode, nil
}

func NewBsnTlvPortVxlanMode() *BsnTlvPortVxlanMode {
	return &BsnTlvPortVxlanMode{
		BsnTlv: NewBsnTlv(88),
	}
}

type BsnTlvPriority struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPriority, error) {
	bsntlvpriority := &BsnTlvPriority{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvPriority packet too short: %d < 4", decoder.Length())
	}
	bsntlvpriority.Value = uint32(decoder.ReadUint32())
	return bsntlvpriority, nil
}

func NewBsnTlvPriority() *BsnTlvPriority {
	return &BsnTlvPriority{
		BsnTlv: NewBsnTlv(57),
	}
}

type BsnTlvPushVlanOnEgress struct {
	*BsnTlv
}

func (self *BsnTlvPushVlanOnEgress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPushVlanOnEgress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPushVlanOnEgress, error) {
	bsntlvpushvlanonegress := &BsnTlvPushVlanOnEgress{BsnTlv: parent}
	return bsntlvpushvlanonegress, nil
}

func NewBsnTlvPushVlanOnEgress() *BsnTlvPushVlanOnEgress {
	return &BsnTlvPushVlanOnEgress{
		BsnTlv: NewBsnTlv(162),
	}
}

type BsnTlvPushVlanOnIngress struct {
	*BsnTlv
	Flags BsnPushVlan
}

func (self *BsnTlvPushVlanOnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvPushVlanOnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvPushVlanOnIngress, error) {
	bsntlvpushvlanoningress := &BsnTlvPushVlanOnIngress{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvPushVlanOnIngress packet too short: %d < 1", decoder.Length())
	}
	bsntlvpushvlanoningress.Flags = BsnPushVlan(decoder.ReadByte())
	return bsntlvpushvlanoningress, nil
}

func NewBsnTlvPushVlanOnIngress() *BsnTlvPushVlanOnIngress {
	return &BsnTlvPushVlanOnIngress{
		BsnTlv: NewBsnTlv(128),
	}
}

type BsnTlvQosPriority struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQosPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvQosPriority(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQosPriority, error) {
	bsntlvqospriority := &BsnTlvQosPriority{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQosPriority packet too short: %d < 4", decoder.Length())
	}
	bsntlvqospriority.Value = uint32(decoder.ReadUint32())
	return bsntlvqospriority, nil
}

func NewBsnTlvQosPriority() *BsnTlvQosPriority {
	return &BsnTlvQosPriority{
		BsnTlv: NewBsnTlv(108),
	}
}

type BsnTlvQueueId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQueueId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvQueueId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQueueId, error) {
	bsntlvqueueid := &BsnTlvQueueId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQueueId packet too short: %d < 4", decoder.Length())
	}
	bsntlvqueueid.Value = uint32(decoder.ReadUint32())
	return bsntlvqueueid, nil
}

func NewBsnTlvQueueId() *BsnTlvQueueId {
	return &BsnTlvQueueId{
		BsnTlv: NewBsnTlv(20),
	}
}

type BsnTlvQueueWeight struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvQueueWeight) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvQueueWeight(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvQueueWeight, error) {
	bsntlvqueueweight := &BsnTlvQueueWeight{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvQueueWeight packet too short: %d < 4", decoder.Length())
	}
	bsntlvqueueweight.Value = uint32(decoder.ReadUint32())
	return bsntlvqueueweight, nil
}

func NewBsnTlvQueueWeight() *BsnTlvQueueWeight {
	return &BsnTlvQueueWeight{
		BsnTlv: NewBsnTlv(21),
	}
}

type BsnTlvRateLimit struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvRateLimit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRateLimit(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRateLimit, error) {
	bsntlvratelimit := &BsnTlvRateLimit{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvRateLimit packet too short: %d < 4", decoder.Length())
	}
	bsntlvratelimit.Value = uint32(decoder.ReadUint32())
	return bsntlvratelimit, nil
}

func NewBsnTlvRateLimit() *BsnTlvRateLimit {
	return &BsnTlvRateLimit{
		BsnTlv: NewBsnTlv(116),
	}
}

type BsnTlvRateUnit struct {
	*BsnTlv
	Value BsnRateUnit
}

func (self *BsnTlvRateUnit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRateUnit(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRateUnit, error) {
	bsntlvrateunit := &BsnTlvRateUnit{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvRateUnit packet too short: %d < 1", decoder.Length())
	}
	bsntlvrateunit.Value = BsnRateUnit(decoder.ReadByte())
	return bsntlvrateunit, nil
}

func NewBsnTlvRateUnit() *BsnTlvRateUnit {
	return &BsnTlvRateUnit{
		BsnTlv: NewBsnTlv(89),
	}
}

type BsnTlvRecordPackets struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvRecordPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRecordPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRecordPackets, error) {
	bsntlvrecordpackets := &BsnTlvRecordPackets{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvRecordPackets packet too short: %d < 4", decoder.Length())
	}
	bsntlvrecordpackets.Value = uint32(decoder.ReadUint32())
	return bsntlvrecordpackets, nil
}

func NewBsnTlvRecordPackets() *BsnTlvRecordPackets {
	return &BsnTlvRecordPackets{
		BsnTlv: NewBsnTlv(155),
	}
}

type BsnTlvReference struct {
	*BsnTlv
	TableId uint16
	Key     []IBsnTlv
}

func (self *BsnTlvReference) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TableId))
	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvReference(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvReference, error) {
	bsntlvreference := &BsnTlvReference{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvReference packet too short: %d < 2", decoder.Length())
	}
	bsntlvreference.TableId = uint16(decoder.ReadUint16())

	for decoder.Length() >= 4 {
		item, err := decodeBsnTlv(decoder)
		if err != nil {
			return nil, err
		}
		bsntlvreference.Key = append(bsntlvreference.Key, item)
	}
	return bsntlvreference, nil
}

func NewBsnTlvReference() *BsnTlvReference {
	return &BsnTlvReference{
		BsnTlv: NewBsnTlv(59),
	}
}

type BsnTlvReplyPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvReplyPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvReplyPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvReplyPackets, error) {
	bsntlvreplypackets := &BsnTlvReplyPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvReplyPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvreplypackets.Value = uint64(decoder.ReadUint64())
	return bsntlvreplypackets, nil
}

func NewBsnTlvReplyPackets() *BsnTlvReplyPackets {
	return &BsnTlvReplyPackets{
		BsnTlv: NewBsnTlv(12),
	}
}

type BsnTlvRequestPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRequestPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRequestPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRequestPackets, error) {
	bsntlvrequestpackets := &BsnTlvRequestPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRequestPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvrequestpackets.Value = uint64(decoder.ReadUint64())
	return bsntlvrequestpackets, nil
}

func NewBsnTlvRequestPackets() *BsnTlvRequestPackets {
	return &BsnTlvRequestPackets{
		BsnTlv: NewBsnTlv(11),
	}
}

type BsnTlvRestServer struct {
	*BsnTlv
}

func (self *BsnTlvRestServer) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRestServer(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRestServer, error) {
	bsntlvrestserver := &BsnTlvRestServer{BsnTlv: parent}
	return bsntlvrestserver, nil
}

func NewBsnTlvRestServer() *BsnTlvRestServer {
	return &BsnTlvRestServer{
		BsnTlv: NewBsnTlv(152),
	}
}

type BsnTlvRoutingParam struct {
	*BsnTlv
	Value BsnRoutingParam
}

func (self *BsnTlvRoutingParam) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRoutingParam(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRoutingParam, error) {
	bsntlvroutingparam := &BsnTlvRoutingParam{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvRoutingParam packet too short: %d < 2", decoder.Length())
	}
	bsntlvroutingparam.Value = BsnRoutingParam(decoder.ReadUint16())
	return bsntlvroutingparam, nil
}

func NewBsnTlvRoutingParam() *BsnTlvRoutingParam {
	return &BsnTlvRoutingParam{
		BsnTlv: NewBsnTlv(161),
	}
}

type BsnTlvRxBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRxBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRxBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRxBytes, error) {
	bsntlvrxbytes := &BsnTlvRxBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRxBytes packet too short: %d < 8", decoder.Length())
	}
	bsntlvrxbytes.Value = uint64(decoder.ReadUint64())
	return bsntlvrxbytes, nil
}

func NewBsnTlvRxBytes() *BsnTlvRxBytes {
	return &BsnTlvRxBytes{
		BsnTlv: NewBsnTlv(71),
	}
}

type BsnTlvRxPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvRxPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvRxPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvRxPackets, error) {
	bsntlvrxpackets := &BsnTlvRxPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvRxPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvrxpackets.Value = uint64(decoder.ReadUint64())
	return bsntlvrxpackets, nil
}

func NewBsnTlvRxPackets() *BsnTlvRxPackets {
	return &BsnTlvRxPackets{
		BsnTlv: NewBsnTlv(2),
	}
}

type BsnTlvSamplingRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvSamplingRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvSamplingRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSamplingRate, error) {
	bsntlvsamplingrate := &BsnTlvSamplingRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvSamplingRate packet too short: %d < 4", decoder.Length())
	}
	bsntlvsamplingrate.Value = uint32(decoder.ReadUint32())
	return bsntlvsamplingrate, nil
}

func NewBsnTlvSamplingRate() *BsnTlvSamplingRate {
	return &BsnTlvSamplingRate{
		BsnTlv: NewBsnTlv(30),
	}
}

type BsnTlvSetLoopbackMode struct {
	*BsnTlv
}

func (self *BsnTlvSetLoopbackMode) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvSetLoopbackMode(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSetLoopbackMode, error) {
	bsntlvsetloopbackmode := &BsnTlvSetLoopbackMode{BsnTlv: parent}
	return bsntlvsetloopbackmode, nil
}

func NewBsnTlvSetLoopbackMode() *BsnTlvSetLoopbackMode {
	return &BsnTlvSetLoopbackMode{
		BsnTlv: NewBsnTlv(74),
	}
}

type BsnTlvStatus struct {
	*BsnTlv
	Value BsnStatus
}

func (self *BsnTlvStatus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvStatus(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStatus, error) {
	bsntlvstatus := &BsnTlvStatus{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvStatus packet too short: %d < 1", decoder.Length())
	}
	bsntlvstatus.Value = BsnStatus(decoder.ReadByte())
	return bsntlvstatus, nil
}

func NewBsnTlvStatus() *BsnTlvStatus {
	return &BsnTlvStatus{
		BsnTlv: NewBsnTlv(97),
	}
}

type BsnTlvStripMplsL2OnIngress struct {
	*BsnTlv
}

func (self *BsnTlvStripMplsL2OnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvStripMplsL2OnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripMplsL2OnIngress, error) {
	bsntlvstripmplsl2oningress := &BsnTlvStripMplsL2OnIngress{BsnTlv: parent}
	return bsntlvstripmplsl2oningress, nil
}

func NewBsnTlvStripMplsL2OnIngress() *BsnTlvStripMplsL2OnIngress {
	return &BsnTlvStripMplsL2OnIngress{
		BsnTlv: NewBsnTlv(75),
	}
}

type BsnTlvStripMplsL3OnIngress struct {
	*BsnTlv
}

func (self *BsnTlvStripMplsL3OnIngress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvStripMplsL3OnIngress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripMplsL3OnIngress, error) {
	bsntlvstripmplsl3oningress := &BsnTlvStripMplsL3OnIngress{BsnTlv: parent}
	return bsntlvstripmplsl3oningress, nil
}

func NewBsnTlvStripMplsL3OnIngress() *BsnTlvStripMplsL3OnIngress {
	return &BsnTlvStripMplsL3OnIngress{
		BsnTlv: NewBsnTlv(76),
	}
}

type BsnTlvStripVlanOnEgress struct {
	*BsnTlv
	Flags BsnStripVlan
}

func (self *BsnTlvStripVlanOnEgress) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvStripVlanOnEgress(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvStripVlanOnEgress, error) {
	bsntlvstripvlanonegress := &BsnTlvStripVlanOnEgress{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvStripVlanOnEgress packet too short: %d < 1", decoder.Length())
	}
	bsntlvstripvlanonegress.Flags = BsnStripVlan(decoder.ReadByte())
	return bsntlvstripvlanonegress, nil
}

func NewBsnTlvStripVlanOnEgress() *BsnTlvStripVlanOnEgress {
	return &BsnTlvStripVlanOnEgress{
		BsnTlv: NewBsnTlv(73),
	}
}

type BsnTlvSubAgentId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvSubAgentId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvSubAgentId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvSubAgentId, error) {
	bsntlvsubagentid := &BsnTlvSubAgentId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvSubAgentId packet too short: %d < 4", decoder.Length())
	}
	bsntlvsubagentid.Value = uint32(decoder.ReadUint32())
	return bsntlvsubagentid, nil
}

func NewBsnTlvSubAgentId() *BsnTlvSubAgentId {
	return &BsnTlvSubAgentId{
		BsnTlv: NewBsnTlv(38),
	}
}

type BsnTlvTcpDst struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTcpDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpDst, error) {
	bsntlvtcpdst := &BsnTlvTcpDst{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpDst packet too short: %d < 2", decoder.Length())
	}
	bsntlvtcpdst.Value = uint16(decoder.ReadUint16())
	return bsntlvtcpdst, nil
}

func NewBsnTlvTcpDst() *BsnTlvTcpDst {
	return &BsnTlvTcpDst{
		BsnTlv: NewBsnTlv(66),
	}
}

type BsnTlvTcpFlags struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpFlags) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTcpFlags(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpFlags, error) {
	bsntlvtcpflags := &BsnTlvTcpFlags{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpFlags packet too short: %d < 2", decoder.Length())
	}
	bsntlvtcpflags.Value = uint16(decoder.ReadUint16())
	return bsntlvtcpflags, nil
}

func NewBsnTlvTcpFlags() *BsnTlvTcpFlags {
	return &BsnTlvTcpFlags{
		BsnTlv: NewBsnTlv(133),
	}
}

type BsnTlvTcpSrc struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTcpSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTcpSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTcpSrc, error) {
	bsntlvtcpsrc := &BsnTlvTcpSrc{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTcpSrc packet too short: %d < 2", decoder.Length())
	}
	bsntlvtcpsrc.Value = uint16(decoder.ReadUint16())
	return bsntlvtcpsrc, nil
}

func NewBsnTlvTcpSrc() *BsnTlvTcpSrc {
	return &BsnTlvTcpSrc{
		BsnTlv: NewBsnTlv(65),
	}
}

type BsnTlvTimestamp struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTimestamp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTimestamp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTimestamp, error) {
	bsntlvtimestamp := &BsnTlvTimestamp{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTimestamp packet too short: %d < 8", decoder.Length())
	}
	bsntlvtimestamp.Value = uint64(decoder.ReadUint64())
	return bsntlvtimestamp, nil
}

func NewBsnTlvTimestamp() *BsnTlvTimestamp {
	return &BsnTlvTimestamp{
		BsnTlv: NewBsnTlv(154),
	}
}

type BsnTlvTtl struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvTtl) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTtl(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTtl, error) {
	bsntlvttl := &BsnTlvTtl{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvTtl packet too short: %d < 2", decoder.Length())
	}
	bsntlvttl.Value = uint16(decoder.ReadUint16())
	return bsntlvttl, nil
}

func NewBsnTlvTtl() *BsnTlvTtl {
	return &BsnTlvTtl{
		BsnTlv: NewBsnTlv(113),
	}
}

type BsnTlvTunnelCapability struct {
	*BsnTlv
	Value BsnTunnelType
}

func (self *BsnTlvTunnelCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTunnelCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTunnelCapability, error) {
	bsntlvtunnelcapability := &BsnTlvTunnelCapability{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTunnelCapability packet too short: %d < 8", decoder.Length())
	}
	bsntlvtunnelcapability.Value = BsnTunnelType(decoder.ReadUint64())
	return bsntlvtunnelcapability, nil
}

func NewBsnTlvTunnelCapability() *BsnTlvTunnelCapability {
	return &BsnTlvTunnelCapability{
		BsnTlv: NewBsnTlv(142),
	}
}

type BsnTlvTxBytes struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTxBytes) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTxBytes(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTxBytes, error) {
	bsntlvtxbytes := &BsnTlvTxBytes{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTxBytes packet too short: %d < 8", decoder.Length())
	}
	bsntlvtxbytes.Value = uint64(decoder.ReadUint64())
	return bsntlvtxbytes, nil
}

func NewBsnTlvTxBytes() *BsnTlvTxBytes {
	return &BsnTlvTxBytes{
		BsnTlv: NewBsnTlv(39),
	}
}

type BsnTlvTxPackets struct {
	*BsnTlv
	Value uint64
}

func (self *BsnTlvTxPackets) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvTxPackets(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvTxPackets, error) {
	bsntlvtxpackets := &BsnTlvTxPackets{BsnTlv: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnTlvTxPackets packet too short: %d < 8", decoder.Length())
	}
	bsntlvtxpackets.Value = uint64(decoder.ReadUint64())
	return bsntlvtxpackets, nil
}

func NewBsnTlvTxPackets() *BsnTlvTxPackets {
	return &BsnTlvTxPackets{
		BsnTlv: NewBsnTlv(3),
	}
}

type BsnTlvUdfAnchor struct {
	*BsnTlv
	Value BsnUdfAnchor
}

func (self *BsnTlvUdfAnchor) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdfAnchor(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfAnchor, error) {
	bsntlvudfanchor := &BsnTlvUdfAnchor{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfAnchor packet too short: %d < 2", decoder.Length())
	}
	bsntlvudfanchor.Value = BsnUdfAnchor(decoder.ReadUint16())
	return bsntlvudfanchor, nil
}

func NewBsnTlvUdfAnchor() *BsnTlvUdfAnchor {
	return &BsnTlvUdfAnchor{
		BsnTlv: NewBsnTlv(16),
	}
}

type BsnTlvUdfCapability struct {
	*BsnTlv
	Value BsnUdfMode
}

func (self *BsnTlvUdfCapability) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdfCapability(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfCapability, error) {
	bsntlvudfcapability := &BsnTlvUdfCapability{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvUdfCapability packet too short: %d < 1", decoder.Length())
	}
	bsntlvudfcapability.Value = BsnUdfMode(decoder.ReadByte())
	return bsntlvudfcapability, nil
}

func NewBsnTlvUdfCapability() *BsnTlvUdfCapability {
	return &BsnTlvUdfCapability{
		BsnTlv: NewBsnTlv(180),
	}
}

type BsnTlvUdfId struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdfId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfId, error) {
	bsntlvudfid := &BsnTlvUdfId{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfId packet too short: %d < 2", decoder.Length())
	}
	bsntlvudfid.Value = uint16(decoder.ReadUint16())
	return bsntlvudfid, nil
}

func NewBsnTlvUdfId() *BsnTlvUdfId {
	return &BsnTlvUdfId{
		BsnTlv: NewBsnTlv(15),
	}
}

type BsnTlvUdfLength struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfLength) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdfLength(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfLength, error) {
	bsntlvudflength := &BsnTlvUdfLength{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfLength packet too short: %d < 2", decoder.Length())
	}
	bsntlvudflength.Value = uint16(decoder.ReadUint16())
	return bsntlvudflength, nil
}

func NewBsnTlvUdfLength() *BsnTlvUdfLength {
	return &BsnTlvUdfLength{
		BsnTlv: NewBsnTlv(18),
	}
}

type BsnTlvUdfOffset struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdfOffset) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdfOffset(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdfOffset, error) {
	bsntlvudfoffset := &BsnTlvUdfOffset{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdfOffset packet too short: %d < 2", decoder.Length())
	}
	bsntlvudfoffset.Value = uint16(decoder.ReadUint16())
	return bsntlvudfoffset, nil
}

func NewBsnTlvUdfOffset() *BsnTlvUdfOffset {
	return &BsnTlvUdfOffset{
		BsnTlv: NewBsnTlv(17),
	}
}

type BsnTlvUdpDst struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdpDst) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdpDst(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdpDst, error) {
	bsntlvudpdst := &BsnTlvUdpDst{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdpDst packet too short: %d < 2", decoder.Length())
	}
	bsntlvudpdst.Value = uint16(decoder.ReadUint16())
	return bsntlvudpdst, nil
}

func NewBsnTlvUdpDst() *BsnTlvUdpDst {
	return &BsnTlvUdpDst{
		BsnTlv: NewBsnTlv(37),
	}
}

type BsnTlvUdpSrc struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvUdpSrc) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUdpSrc(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUdpSrc, error) {
	bsntlvudpsrc := &BsnTlvUdpSrc{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUdpSrc packet too short: %d < 2", decoder.Length())
	}
	bsntlvudpsrc.Value = uint16(decoder.ReadUint16())
	return bsntlvudpsrc, nil
}

func NewBsnTlvUdpSrc() *BsnTlvUdpSrc {
	return &BsnTlvUdpSrc{
		BsnTlv: NewBsnTlv(36),
	}
}

type BsnTlvUint32 struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUint32) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUint32(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUint32, error) {
	bsntlvuint32 := &BsnTlvUint32{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUint32 packet too short: %d < 4", decoder.Length())
	}
	bsntlvuint32.Value = uint32(decoder.ReadUint32())
	return bsntlvuint32, nil
}

func NewBsnTlvUint32() *BsnTlvUint32 {
	return &BsnTlvUint32{
		BsnTlv: NewBsnTlv(167),
	}
}

type BsnTlvUint64List struct {
	*BsnTlv
	Value []*Uint64
}

func (self *BsnTlvUint64List) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Value {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUint64List(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUint64List, error) {
	bsntlvuint64list := &BsnTlvUint64List{BsnTlv: parent}

	for decoder.Length() >= 8 {
		item, err := decodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		bsntlvuint64list.Value = append(bsntlvuint64list.Value, item)
	}
	return bsntlvuint64list, nil
}

func NewBsnTlvUint64List() *BsnTlvUint64List {
	return &BsnTlvUint64List{
		BsnTlv: NewBsnTlv(119),
	}
}

type BsnTlvUnicastQueryTimeout struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnicastQueryTimeout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUnicastQueryTimeout(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnicastQueryTimeout, error) {
	bsntlvunicastquerytimeout := &BsnTlvUnicastQueryTimeout{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnicastQueryTimeout packet too short: %d < 4", decoder.Length())
	}
	bsntlvunicastquerytimeout.Value = uint32(decoder.ReadUint32())
	return bsntlvunicastquerytimeout, nil
}

func NewBsnTlvUnicastQueryTimeout() *BsnTlvUnicastQueryTimeout {
	return &BsnTlvUnicastQueryTimeout{
		BsnTlv: NewBsnTlv(9),
	}
}

type BsnTlvUnicastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnicastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUnicastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnicastRate, error) {
	bsntlvunicastrate := &BsnTlvUnicastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnicastRate packet too short: %d < 4", decoder.Length())
	}
	bsntlvunicastrate.Value = uint32(decoder.ReadUint32())
	return bsntlvunicastrate, nil
}

func NewBsnTlvUnicastRate() *BsnTlvUnicastRate {
	return &BsnTlvUnicastRate{
		BsnTlv: NewBsnTlv(93),
	}
}

type BsnTlvUnknownMulticastRate struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvUnknownMulticastRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUnknownMulticastRate(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUnknownMulticastRate, error) {
	bsntlvunknownmulticastrate := &BsnTlvUnknownMulticastRate{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvUnknownMulticastRate packet too short: %d < 4", decoder.Length())
	}
	bsntlvunknownmulticastrate.Value = uint32(decoder.ReadUint32())
	return bsntlvunknownmulticastrate, nil
}

func NewBsnTlvUnknownMulticastRate() *BsnTlvUnknownMulticastRate {
	return &BsnTlvUnknownMulticastRate{
		BsnTlv: NewBsnTlv(92),
	}
}

type BsnTlvUntagged struct {
	*BsnTlv
}

func (self *BsnTlvUntagged) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUntagged(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUntagged, error) {
	bsntlvuntagged := &BsnTlvUntagged{BsnTlv: parent}
	return bsntlvuntagged, nil
}

func NewBsnTlvUntagged() *BsnTlvUntagged {
	return &BsnTlvUntagged{
		BsnTlv: NewBsnTlv(106),
	}
}

type BsnTlvUpgrade struct {
	*BsnTlv
	Value BsnUpgrade
}

func (self *BsnTlvUpgrade) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUpgrade(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUpgrade, error) {
	bsntlvupgrade := &BsnTlvUpgrade{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvUpgrade packet too short: %d < 2", decoder.Length())
	}
	bsntlvupgrade.Value = BsnUpgrade(decoder.ReadUint16())
	return bsntlvupgrade, nil
}

func NewBsnTlvUpgrade() *BsnTlvUpgrade {
	return &BsnTlvUpgrade{
		BsnTlv: NewBsnTlv(164),
	}
}

type BsnTlvUriScheme struct {
	*BsnTlv
	Value []byte
}

func (self *BsnTlvUriScheme) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Value)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUriScheme(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUriScheme, error) {
	bsntlvurischeme := &BsnTlvUriScheme{BsnTlv: parent}
	bsntlvurischeme.Value = decoder.Read(decoder.Length())
	return bsntlvurischeme, nil
}

func NewBsnTlvUriScheme() *BsnTlvUriScheme {
	return &BsnTlvUriScheme{
		BsnTlv: NewBsnTlv(153),
	}
}

type BsnTlvUsePacketState struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvUsePacketState) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUsePacketState(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUsePacketState, error) {
	bsntlvusepacketstate := &BsnTlvUsePacketState{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvUsePacketState packet too short: %d < 1", decoder.Length())
	}
	bsntlvusepacketstate.Value = uint8(decoder.ReadByte())
	return bsntlvusepacketstate, nil
}

func NewBsnTlvUsePacketState() *BsnTlvUsePacketState {
	return &BsnTlvUsePacketState{
		BsnTlv: NewBsnTlv(96),
	}
}

type BsnTlvUserConfigured struct {
	*BsnTlv
}

func (self *BsnTlvUserConfigured) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvUserConfigured(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvUserConfigured, error) {
	bsntlvuserconfigured := &BsnTlvUserConfigured{BsnTlv: parent}
	return bsntlvuserconfigured, nil
}

func NewBsnTlvUserConfigured() *BsnTlvUserConfigured {
	return &BsnTlvUserConfigured{
		BsnTlv: NewBsnTlv(166),
	}
}

type BsnTlvVfi struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVfi) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVfi(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVfi, error) {
	bsntlvvfi := &BsnTlvVfi{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVfi packet too short: %d < 2", decoder.Length())
	}
	bsntlvvfi.Value = uint16(decoder.ReadUint16())
	return bsntlvvfi, nil
}

func NewBsnTlvVfi() *BsnTlvVfi {
	return &BsnTlvVfi{
		BsnTlv: NewBsnTlv(99),
	}
}

type BsnTlvVfpClassId struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVfpClassId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVfpClassId(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVfpClassId, error) {
	bsntlvvfpclassid := &BsnTlvVfpClassId{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVfpClassId packet too short: %d < 4", decoder.Length())
	}
	bsntlvvfpclassid.Value = uint32(decoder.ReadUint32())
	return bsntlvvfpclassid, nil
}

func NewBsnTlvVfpClassId() *BsnTlvVfpClassId {
	return &BsnTlvVfpClassId{
		BsnTlv: NewBsnTlv(107),
	}
}

type BsnTlvVirtual struct {
	*BsnTlv
}

func (self *BsnTlvVirtual) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVirtual(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVirtual, error) {
	bsntlvvirtual := &BsnTlvVirtual{BsnTlv: parent}
	return bsntlvvirtual, nil
}

func NewBsnTlvVirtual() *BsnTlvVirtual {
	return &BsnTlvVirtual{
		BsnTlv: NewBsnTlv(158),
	}
}

type BsnTlvVlanMacList struct {
	*BsnTlv
	Key []*BsnVlanMac
}

func (self *BsnTlvVlanMacList) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Key {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVlanMacList(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanMacList, error) {
	bsntlvvlanmaclist := &BsnTlvVlanMacList{BsnTlv: parent}

	for decoder.Length() >= 8 {
		item, err := decodeBsnVlanMac(decoder)
		if err != nil {
			return nil, err
		}
		bsntlvvlanmaclist.Key = append(bsntlvvlanmaclist.Key, item)
	}
	return bsntlvvlanmaclist, nil
}

func NewBsnTlvVlanMacList() *BsnTlvVlanMacList {
	return &BsnTlvVlanMacList{
		BsnTlv: NewBsnTlv(98),
	}
}

type BsnTlvVlanPcp struct {
	*BsnTlv
	Value uint8
}

func (self *BsnTlvVlanPcp) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVlanPcp(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanPcp, error) {
	bsntlvvlanpcp := &BsnTlvVlanPcp{BsnTlv: parent}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("BsnTlvVlanPcp packet too short: %d < 1", decoder.Length())
	}
	bsntlvvlanpcp.Value = uint8(decoder.ReadByte())
	return bsntlvvlanpcp, nil
}

func NewBsnTlvVlanPcp() *BsnTlvVlanPcp {
	return &BsnTlvVlanPcp{
		BsnTlv: NewBsnTlv(72),
	}
}

type BsnTlvVlanVid struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVlanVid) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVlanVid(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanVid, error) {
	bsntlvvlanvid := &BsnTlvVlanVid{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVlanVid packet too short: %d < 2", decoder.Length())
	}
	bsntlvvlanvid.Value = uint16(decoder.ReadUint16())
	return bsntlvvlanvid, nil
}

func NewBsnTlvVlanVid() *BsnTlvVlanVid {
	return &BsnTlvVlanVid{
		BsnTlv: NewBsnTlv(6),
	}
}

type BsnTlvVlanVidMask struct {
	*BsnTlv
	Value uint16
}

func (self *BsnTlvVlanVidMask) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVlanVidMask(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVlanVidMask, error) {
	bsntlvvlanvidmask := &BsnTlvVlanVidMask{BsnTlv: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("BsnTlvVlanVidMask packet too short: %d < 2", decoder.Length())
	}
	bsntlvvlanvidmask.Value = uint16(decoder.ReadUint16())
	return bsntlvvlanvidmask, nil
}

func NewBsnTlvVlanVidMask() *BsnTlvVlanVidMask {
	return &BsnTlvVlanVidMask{
		BsnTlv: NewBsnTlv(77),
	}
}

type BsnTlvVni struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVni) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVni(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVni, error) {
	bsntlvvni := &BsnTlvVni{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVni packet too short: %d < 4", decoder.Length())
	}
	bsntlvvni.Value = uint32(decoder.ReadUint32())
	return bsntlvvni, nil
}

func NewBsnTlvVni() *BsnTlvVni {
	return &BsnTlvVni{
		BsnTlv: NewBsnTlv(86),
	}
}

type BsnTlvVpnKey struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVpnKey) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVpnKey(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVpnKey, error) {
	bsntlvvpnkey := &BsnTlvVpnKey{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVpnKey packet too short: %d < 4", decoder.Length())
	}
	bsntlvvpnkey.Value = uint32(decoder.ReadUint32())
	return bsntlvvpnkey, nil
}

func NewBsnTlvVpnKey() *BsnTlvVpnKey {
	return &BsnTlvVpnKey{
		BsnTlv: NewBsnTlv(111),
	}
}

type BsnTlvVrf struct {
	*BsnTlv
	Value uint32
}

func (self *BsnTlvVrf) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Value))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVrf(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVrf, error) {
	bsntlvvrf := &BsnTlvVrf{BsnTlv: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BsnTlvVrf packet too short: %d < 4", decoder.Length())
	}
	bsntlvvrf.Value = uint32(decoder.ReadUint32())
	return bsntlvvrf, nil
}

func NewBsnTlvVrf() *BsnTlvVrf {
	return &BsnTlvVrf{
		BsnTlv: NewBsnTlv(19),
	}
}

type BsnTlvVxlanEgressLag struct {
	*BsnTlv
}

func (self *BsnTlvVxlanEgressLag) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnTlv.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnTlvVxlanEgressLag(parent *BsnTlv, decoder *goloxi.Decoder) (*BsnTlvVxlanEgressLag, error) {
	bsntlvvxlanegresslag := &BsnTlvVxlanEgressLag{BsnTlv: parent}
	return bsntlvvxlanegresslag, nil
}

func NewBsnTlvVxlanEgressLag() *BsnTlvVxlanEgressLag {
	return &BsnTlvVxlanEgressLag{
		BsnTlv: NewBsnTlv(117),
	}
}

type BsnVport struct {
	Type   uint16
	Length uint16
}

type IBsnVport interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BsnVport) GetType() uint16 {
	return self.Type
}

func (self *BsnVport) GetLength() uint16 {
	return self.Length
}

func (self *BsnVport) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}
func (self *BsnVport) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("BsnVport packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	return nil
}

func NewBsnVport(_type uint16) *BsnVport {
	return &BsnVport{
		Type: _type,
	}
}

type BsnVlanCounterStatsEntry struct {
	Length  uint16
	VlanVid uint16
	Values  []*Uint64
}

func (self *BsnVlanCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVlanCounterStatsEntry(decoder *goloxi.Decoder) (*BsnVlanCounterStatsEntry, error) {
	bsnvlancounterstatsentry := &BsnVlanCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVlanCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	bsnvlancounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsnvlancounterstatsentry.Length), 2+0)
	bsnvlancounterstatsentry.VlanVid = uint16(decoder.ReadUint16())
	decoder.Skip(4)

	for decoder.Length() >= 8 {
		item, err := decodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		bsnvlancounterstatsentry.Values = append(bsnvlancounterstatsentry.Values, item)
	}
	return bsnvlancounterstatsentry, nil
}

func NewBsnVlanCounterStatsEntry() *BsnVlanCounterStatsEntry {
	return &BsnVlanCounterStatsEntry{}
}

type BsnVlanMac struct {
	VlanVid uint16
	Mac     net.HardwareAddr
}

func (self *BsnVlanMac) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.VlanVid))
	encoder.Write(self.Mac)

	return nil
}

func decodeBsnVlanMac(decoder *goloxi.Decoder) (*BsnVlanMac, error) {
	bsnvlanmac := &BsnVlanMac{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVlanMac packet too short: %d < 8", decoder.Length())
	}
	bsnvlanmac.VlanVid = uint16(decoder.ReadUint16())
	bsnvlanmac.Mac = net.HardwareAddr(decoder.Read(6))
	return bsnvlanmac, nil
}

func NewBsnVlanMac() *BsnVlanMac {
	return &BsnVlanMac{}
}

type BsnVportL2Gre struct {
	*BsnVport
	Flags          BsnVportL2GreFlags
	PortNo         PortNo
	LoopbackPortNo PortNo
	LocalMac       net.HardwareAddr
	NhMac          net.HardwareAddr
	SrcIp          net.IP
	DstIp          net.IP
	Dscp           uint8
	Ttl            uint8
	Vpn            uint32
	RateLimit      uint32
	IfName         string
}

func (self *BsnVportL2Gre) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))
	self.PortNo.Serialize(encoder)
	self.LoopbackPortNo.Serialize(encoder)
	encoder.Write(self.LocalMac)
	encoder.Write(self.NhMac)
	encoder.Write(self.SrcIp.To4())
	encoder.Write(self.DstIp.To4())
	encoder.PutUint8(uint8(self.Dscp))
	encoder.PutUint8(uint8(self.Ttl))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vpn))
	encoder.PutUint32(uint32(self.RateLimit))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportL2Gre(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportL2Gre, error) {
	bsnvportl2gre := &BsnVportL2Gre{BsnVport: parent}
	if decoder.Length() < 60 {
		return nil, fmt.Errorf("BsnVportL2Gre packet too short: %d < 60", decoder.Length())
	}
	bsnvportl2gre.Flags = BsnVportL2GreFlags(decoder.ReadUint32())
	bsnvportl2gre.PortNo.Decode(decoder)
	bsnvportl2gre.LoopbackPortNo.Decode(decoder)
	bsnvportl2gre.LocalMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.NhMac = net.HardwareAddr(decoder.Read(6))
	bsnvportl2gre.SrcIp = net.IP(decoder.Read(4))
	bsnvportl2gre.DstIp = net.IP(decoder.Read(4))
	bsnvportl2gre.Dscp = uint8(decoder.ReadByte())
	bsnvportl2gre.Ttl = uint8(decoder.ReadByte())
	decoder.Skip(2)
	bsnvportl2gre.Vpn = uint32(decoder.ReadUint32())
	bsnvportl2gre.RateLimit = uint32(decoder.ReadUint32())
	bsnvportl2gre.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportl2gre, nil
}

func NewBsnVportL2Gre() *BsnVportL2Gre {
	return &BsnVportL2Gre{
		BsnVport: NewBsnVport(1),
	}
}

type BsnVportQInQ struct {
	*BsnVport
	PortNo        uint32
	IngressTpid   uint16
	IngressVlanId uint16
	EgressTpid    uint16
	EgressVlanId  uint16
	IfName        string
}

func (self *BsnVportQInQ) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BsnVport.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint16(uint16(self.IngressTpid))
	encoder.PutUint16(uint16(self.IngressVlanId))
	encoder.PutUint16(uint16(self.EgressTpid))
	encoder.PutUint16(uint16(self.EgressVlanId))
	encoder.Write([]byte(self.IfName))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVportQInQ(parent *BsnVport, decoder *goloxi.Decoder) (*BsnVportQInQ, error) {
	bsnvportqinq := &BsnVportQInQ{BsnVport: parent}
	if decoder.Length() < 28 {
		return nil, fmt.Errorf("BsnVportQInQ packet too short: %d < 28", decoder.Length())
	}
	bsnvportqinq.PortNo = uint32(decoder.ReadUint32())
	bsnvportqinq.IngressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.IngressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressTpid = uint16(decoder.ReadUint16())
	bsnvportqinq.EgressVlanId = uint16(decoder.ReadUint16())
	bsnvportqinq.IfName = string(bytes.Trim(decoder.Read(16), "\x00"))
	return bsnvportqinq, nil
}

func NewBsnVportQInQ() *BsnVportQInQ {
	return &BsnVportQInQ{
		BsnVport: NewBsnVport(0),
	}
}

type BsnVrfCounterStatsEntry struct {
	Length uint16
	Vrf    uint32
	Values []*Uint64
}

func (self *BsnVrfCounterStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Vrf))
	for _, obj := range self.Values {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBsnVrfCounterStatsEntry(decoder *goloxi.Decoder) (*BsnVrfCounterStatsEntry, error) {
	bsnvrfcounterstatsentry := &BsnVrfCounterStatsEntry{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BsnVrfCounterStatsEntry packet too short: %d < 8", decoder.Length())
	}
	bsnvrfcounterstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bsnvrfcounterstatsentry.Length), 2+0)
	decoder.Skip(2)
	bsnvrfcounterstatsentry.Vrf = uint32(decoder.ReadUint32())

	for decoder.Length() >= 8 {
		item, err := decodeUint64(decoder)
		if err != nil {
			return nil, err
		}
		bsnvrfcounterstatsentry.Values = append(bsnvrfcounterstatsentry.Values, item)
	}
	return bsnvrfcounterstatsentry, nil
}

func NewBsnVrfCounterStatsEntry() *BsnVrfCounterStatsEntry {
	return &BsnVrfCounterStatsEntry{}
}

type Bucket struct {
	Len            uint16
	ActionArrayLen uint16
	BucketId       GroupBucket
	Actions        []IAction
	Properties     []IGroupBucketProp
}

func (self *Bucket) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Len))
	encoder.PutUint16(uint16(self.ActionArrayLen))
	encoder.PutUint32(uint32(self.BucketId))
	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBucket(decoder *goloxi.Decoder) (*Bucket, error) {
	bucket := &Bucket{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Bucket packet too short: %d < 8", decoder.Length())
	}
	bucket.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bucket.Len), 2+0)
	bucket.ActionArrayLen = uint16(decoder.ReadUint16())
	bucket.BucketId = GroupBucket(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		bucket.Actions = append(bucket.Actions, item)
	}

	for decoder.Length() >= 4 {
		item, err := decodeGroupBucketProp(decoder)
		if err != nil {
			return nil, err
		}
		bucket.Properties = append(bucket.Properties, item)
	}
	return bucket, nil
}

func NewBucket() *Bucket {
	return &Bucket{}
}

type BucketCounter struct {
	PacketCount uint64
	ByteCount   uint64
}

func (self *BucketCounter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))

	return nil
}

func decodeBucketCounter(decoder *goloxi.Decoder) (*BucketCounter, error) {
	bucketcounter := &BucketCounter{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("BucketCounter packet too short: %d < 16", decoder.Length())
	}
	bucketcounter.PacketCount = uint64(decoder.ReadUint64())
	bucketcounter.ByteCount = uint64(decoder.ReadUint64())
	return bucketcounter, nil
}

func NewBucketCounter() *BucketCounter {
	return &BucketCounter{}
}

type BundleFeaturesProp struct {
	Type   uint16
	Length uint16
}

type IBundleFeaturesProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BundleFeaturesProp) GetType() uint16 {
	return self.Type
}

func (self *BundleFeaturesProp) GetLength() uint16 {
	return self.Length
}

func (self *BundleFeaturesProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeBundleFeaturesProp(decoder *goloxi.Decoder) (IBundleFeaturesProp, error) {
	bundlefeaturesprop := &BundleFeaturesProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BundleFeaturesProp packet too short: %d < 4", decoder.Length())
	}
	bundlefeaturesprop.Type = uint16(decoder.ReadUint16())
	bundlefeaturesprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bundlefeaturesprop.Length), 2+2)

	switch bundlefeaturesprop.Type {
	case 1:
		return decodeBundleFeaturesPropTime(bundlefeaturesprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BundleFeaturesProp'", bundlefeaturesprop.Type)
	}
}

func NewBundleFeaturesProp(_type uint16) *BundleFeaturesProp {
	return &BundleFeaturesProp{
		Type: _type,
	}
}

type Time struct {
	Seconds     uint64
	Nanoseconds uint32
}

func (self *Time) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.Seconds))
	encoder.PutUint32(uint32(self.Nanoseconds))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func decodeTime(decoder *goloxi.Decoder) (*Time, error) {
	time := &Time{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("Time packet too short: %d < 16", decoder.Length())
	}
	time.Seconds = uint64(decoder.ReadUint64())
	time.Nanoseconds = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return time, nil
}

func NewTime() *Time {
	return &Time{}
}

type BundleFeaturesPropTime struct {
	*BundleFeaturesProp
	SchedAccuracy  Time
	SchedMaxFuture Time
	SchedMaxPast   Time
	Timestamp      Time
}

func (self *BundleFeaturesPropTime) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BundleFeaturesProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	self.SchedAccuracy.Serialize(encoder)
	self.SchedMaxFuture.Serialize(encoder)
	self.SchedMaxPast.Serialize(encoder)
	self.Timestamp.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBundleFeaturesPropTime(parent *BundleFeaturesProp, decoder *goloxi.Decoder) (*BundleFeaturesPropTime, error) {
	bundlefeaturesproptime := &BundleFeaturesPropTime{BundleFeaturesProp: parent}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("BundleFeaturesPropTime packet too short: %d < 64", decoder.Length())
	}
	decoder.Skip(4)
	bundlefeaturesproptime.SchedAccuracy.Decode(decoder)
	bundlefeaturesproptime.SchedMaxFuture.Decode(decoder)
	bundlefeaturesproptime.SchedMaxPast.Decode(decoder)
	bundlefeaturesproptime.Timestamp.Decode(decoder)
	return bundlefeaturesproptime, nil
}

func NewBundleFeaturesPropTime() *BundleFeaturesPropTime {
	return &BundleFeaturesPropTime{
		BundleFeaturesProp: NewBundleFeaturesProp(1),
	}
}

type BundleProp struct {
	Type   uint16
	Length uint16
}

type IBundleProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *BundleProp) GetType() uint16 {
	return self.Type
}

func (self *BundleProp) GetLength() uint16 {
	return self.Length
}

func (self *BundleProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeBundleProp(decoder *goloxi.Decoder) (IBundleProp, error) {
	bundleprop := &BundleProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("BundleProp packet too short: %d < 4", decoder.Length())
	}
	bundleprop.Type = uint16(decoder.ReadUint16())
	bundleprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(bundleprop.Length), 2+2)

	switch bundleprop.Type {
	case 1:
		return decodeBundlePropTime(bundleprop, decoder)
	case 65535:
		return decodeBundlePropExperimenter(bundleprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'BundleProp'", bundleprop.Type)
	}
}

func NewBundleProp(_type uint16) *BundleProp {
	return &BundleProp{
		Type: _type,
	}
}

type BundlePropExperimenter struct {
	*BundleProp
	Experimenter uint32
	ExpType      uint32
}

type IBundlePropExperimenter interface {
	IBundleProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *BundlePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *BundlePropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *BundlePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BundleProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeBundlePropExperimenter(parent *BundleProp, decoder *goloxi.Decoder) (IBundlePropExperimenter, error) {
	bundlepropexperimenter := &BundlePropExperimenter{BundleProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("BundlePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	bundlepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	bundlepropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return bundlepropexperimenter, nil
}

func NewBundlePropExperimenter(_experimenter uint32) *BundlePropExperimenter {
	return &BundlePropExperimenter{
		Experimenter: _experimenter,
		BundleProp:   NewBundleProp(65535),
	}
}

type BundlePropTime struct {
	*BundleProp
	ScheduledTime []*Time
}

func (self *BundlePropTime) Serialize(encoder *goloxi.Encoder) error {
	if err := self.BundleProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	for _, obj := range self.ScheduledTime {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeBundlePropTime(parent *BundleProp, decoder *goloxi.Decoder) (*BundlePropTime, error) {
	bundleproptime := &BundlePropTime{BundleProp: parent}
	decoder.Skip(4)

	for decoder.Length() >= 16 {
		item, err := decodeTime(decoder)
		if err != nil {
			return nil, err
		}
		bundleproptime.ScheduledTime = append(bundleproptime.ScheduledTime, item)
	}
	return bundleproptime, nil
}

func NewBundlePropTime() *BundlePropTime {
	return &BundlePropTime{
		BundleProp: NewBundleProp(1),
	}
}

type ControllerStatusEntry struct {
	Length        uint16
	ShortId       uint16
	Role          ControllerRole
	Reason        ControllerStatusReason
	ChannelStatus ControlChannelStatus
	Properties    []IControllerStatusProp
}

func (self *ControllerStatusEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.ShortId))
	encoder.PutUint32(uint32(self.Role))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint8(uint8(self.ChannelStatus))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeControllerStatusEntry(decoder *goloxi.Decoder) (*ControllerStatusEntry, error) {
	controllerstatusentry := &ControllerStatusEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("ControllerStatusEntry packet too short: %d < 16", decoder.Length())
	}
	controllerstatusentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(controllerstatusentry.Length), 2+0)
	controllerstatusentry.ShortId = uint16(decoder.ReadUint16())
	controllerstatusentry.Role = ControllerRole(decoder.ReadUint32())
	controllerstatusentry.Reason = ControllerStatusReason(decoder.ReadByte())
	controllerstatusentry.ChannelStatus = ControlChannelStatus(decoder.ReadByte())
	decoder.Skip(6)

	for decoder.Length() >= 4 {
		item, err := decodeControllerStatusProp(decoder)
		if err != nil {
			return nil, err
		}
		controllerstatusentry.Properties = append(controllerstatusentry.Properties, item)
	}
	return controllerstatusentry, nil
}

func NewControllerStatusEntry() *ControllerStatusEntry {
	return &ControllerStatusEntry{}
}

type ControllerStatusProp struct {
	Type   uint16
	Length uint16
}

type IControllerStatusProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *ControllerStatusProp) GetType() uint16 {
	return self.Type
}

func (self *ControllerStatusProp) GetLength() uint16 {
	return self.Length
}

func (self *ControllerStatusProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeControllerStatusProp(decoder *goloxi.Decoder) (IControllerStatusProp, error) {
	controllerstatusprop := &ControllerStatusProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("ControllerStatusProp packet too short: %d < 4", decoder.Length())
	}
	controllerstatusprop.Type = uint16(decoder.ReadUint16())
	controllerstatusprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(controllerstatusprop.Length), 2+2)

	switch controllerstatusprop.Type {
	case 0:
		return decodeControllerStatusPropUri(controllerstatusprop, decoder)
	case 65535:
		return decodeControllerStatusPropExperimenter(controllerstatusprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'ControllerStatusProp'", controllerstatusprop.Type)
	}
}

func NewControllerStatusProp(_type uint16) *ControllerStatusProp {
	return &ControllerStatusProp{
		Type: _type,
	}
}

type FlowLightweightStatsEntry struct {
	Length   uint16
	TableId  uint8
	Reason   FlowStatsReason
	Priority uint16
	Match    Match
	Stats    Stat
}

func (self *FlowLightweightStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Stats.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowLightweightStatsEntry(decoder *goloxi.Decoder) (*FlowLightweightStatsEntry, error) {
	flowlightweightstatsentry := &FlowLightweightStatsEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("FlowLightweightStatsEntry packet too short: %d < 24", decoder.Length())
	}
	flowlightweightstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(flowlightweightstatsentry.Length), 2+0)
	decoder.Skip(2)
	flowlightweightstatsentry.TableId = uint8(decoder.ReadByte())
	flowlightweightstatsentry.Reason = FlowStatsReason(decoder.ReadByte())
	flowlightweightstatsentry.Priority = uint16(decoder.ReadUint16())
	if err := flowlightweightstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	if err := flowlightweightstatsentry.Stats.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return flowlightweightstatsentry, nil
}

func NewFlowLightweightStatsEntry() *FlowLightweightStatsEntry {
	return &FlowLightweightStatsEntry{}
}

type FlowMonitorEntry struct {
	MonitorId uint32
	OutPort   uint32
	OutGroup  uint32
	Flags     FlowMonitorFlags
	TableId   uint8
	Command   FlowMonitorCommand
	Match     Match
}

func (self *FlowMonitorEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MonitorId))
	encoder.PutUint32(uint32(self.OutPort))
	encoder.PutUint32(uint32(self.OutGroup))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Command))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodeFlowMonitorEntry(decoder *goloxi.Decoder) (*FlowMonitorEntry, error) {
	flowmonitorentry := &FlowMonitorEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("FlowMonitorEntry packet too short: %d < 24", decoder.Length())
	}
	flowmonitorentry.MonitorId = uint32(decoder.ReadUint32())
	flowmonitorentry.OutPort = uint32(decoder.ReadUint32())
	flowmonitorentry.OutGroup = uint32(decoder.ReadUint32())
	flowmonitorentry.Flags = FlowMonitorFlags(decoder.ReadUint16())
	flowmonitorentry.TableId = uint8(decoder.ReadByte())
	flowmonitorentry.Command = FlowMonitorCommand(decoder.ReadByte())
	if err := flowmonitorentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	return flowmonitorentry, nil
}

func NewFlowMonitorEntry() *FlowMonitorEntry {
	return &FlowMonitorEntry{}
}

type FlowMonitorReplyEntry struct {
	Length uint16
	Event  FlowUpdateEvent
}

func (self *FlowMonitorReplyEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowMonitorReplyEntry(decoder *goloxi.Decoder) (*FlowMonitorReplyEntry, error) {
	flowmonitorreplyentry := &FlowMonitorReplyEntry{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("FlowMonitorReplyEntry packet too short: %d < 4", decoder.Length())
	}
	flowmonitorreplyentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(flowmonitorreplyentry.Length), 2+0)
	flowmonitorreplyentry.Event = FlowUpdateEvent(decoder.ReadUint16())
	return flowmonitorreplyentry, nil
}

func NewFlowMonitorReplyEntry() *FlowMonitorReplyEntry {
	return &FlowMonitorReplyEntry{}
}

type FlowStatsEntry struct {
	Length       uint16
	TableId      uint8
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	Flags        FlowModFlags
	Importance   uint16
	Cookie       uint64
	Match        Match
	Stats        Stat
	Instructions []IInstruction
}

func (self *FlowStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint16(uint16(self.Importance))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	if err := self.Stats.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Instructions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeFlowStatsEntry(decoder *goloxi.Decoder) (*FlowStatsEntry, error) {
	flowstatsentry := &FlowStatsEntry{}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("FlowStatsEntry packet too short: %d < 40", decoder.Length())
	}
	flowstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(flowstatsentry.Length), 2+0)
	decoder.Skip(2)
	flowstatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	flowstatsentry.Priority = uint16(decoder.ReadUint16())
	flowstatsentry.IdleTimeout = uint16(decoder.ReadUint16())
	flowstatsentry.HardTimeout = uint16(decoder.ReadUint16())
	flowstatsentry.Flags = FlowModFlags(decoder.ReadUint16())
	flowstatsentry.Importance = uint16(decoder.ReadUint16())
	flowstatsentry.Cookie = uint64(decoder.ReadUint64())
	if err := flowstatsentry.Match.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()
	if err := flowstatsentry.Stats.Decode(decoder); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeInstruction(decoder)
		if err != nil {
			return nil, err
		}
		flowstatsentry.Instructions = append(flowstatsentry.Instructions, item)
	}
	return flowstatsentry, nil
}

func NewFlowStatsEntry() *FlowStatsEntry {
	return &FlowStatsEntry{}
}

type GroupBucketProp struct {
	Type   uint16
	Length uint16
}

type IGroupBucketProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *GroupBucketProp) GetType() uint16 {
	return self.Type
}

func (self *GroupBucketProp) GetLength() uint16 {
	return self.Length
}

func (self *GroupBucketProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeGroupBucketProp(decoder *goloxi.Decoder) (IGroupBucketProp, error) {
	groupbucketprop := &GroupBucketProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GroupBucketProp packet too short: %d < 4", decoder.Length())
	}
	groupbucketprop.Type = uint16(decoder.ReadUint16())
	groupbucketprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupbucketprop.Length), 2+2)

	switch groupbucketprop.Type {
	case 0:
		return decodeGroupBucketPropWeight(groupbucketprop, decoder)
	case 1:
		return decodeGroupBucketPropWatchPort(groupbucketprop, decoder)
	case 2:
		return decodeGroupBucketPropWatchGroup(groupbucketprop, decoder)
	case 3:
		return decodeGroupBucketPropExperimenter(groupbucketprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'GroupBucketProp'", groupbucketprop.Type)
	}
}

func NewGroupBucketProp(_type uint16) *GroupBucketProp {
	return &GroupBucketProp{
		Type: _type,
	}
}

type GroupBucketPropExperimenter struct {
	*GroupBucketProp
	Experimenter uint32
	ExpType      uint32
}

type IGroupBucketPropExperimenter interface {
	IGroupBucketProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *GroupBucketPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *GroupBucketPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *GroupBucketPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupBucketProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeGroupBucketPropExperimenter(parent *GroupBucketProp, decoder *goloxi.Decoder) (IGroupBucketPropExperimenter, error) {
	groupbucketpropexperimenter := &GroupBucketPropExperimenter{GroupBucketProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("GroupBucketPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	groupbucketpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	groupbucketpropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return groupbucketpropexperimenter, nil
}

func NewGroupBucketPropExperimenter(_experimenter uint32) *GroupBucketPropExperimenter {
	return &GroupBucketPropExperimenter{
		Experimenter:    _experimenter,
		GroupBucketProp: NewGroupBucketProp(3),
	}
}

type GroupBucketPropWatchGroup struct {
	*GroupBucketProp
	Watch uint32
}

func (self *GroupBucketPropWatchGroup) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupBucketProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Watch))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupBucketPropWatchGroup(parent *GroupBucketProp, decoder *goloxi.Decoder) (*GroupBucketPropWatchGroup, error) {
	groupbucketpropwatchgroup := &GroupBucketPropWatchGroup{GroupBucketProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GroupBucketPropWatchGroup packet too short: %d < 4", decoder.Length())
	}
	groupbucketpropwatchgroup.Watch = uint32(decoder.ReadUint32())
	return groupbucketpropwatchgroup, nil
}

func NewGroupBucketPropWatchGroup() *GroupBucketPropWatchGroup {
	return &GroupBucketPropWatchGroup{
		GroupBucketProp: NewGroupBucketProp(2),
	}
}

type GroupBucketPropWatchPort struct {
	*GroupBucketProp
	Watch uint32
}

func (self *GroupBucketPropWatchPort) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupBucketProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Watch))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupBucketPropWatchPort(parent *GroupBucketProp, decoder *goloxi.Decoder) (*GroupBucketPropWatchPort, error) {
	groupbucketpropwatchport := &GroupBucketPropWatchPort{GroupBucketProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GroupBucketPropWatchPort packet too short: %d < 4", decoder.Length())
	}
	groupbucketpropwatchport.Watch = uint32(decoder.ReadUint32())
	return groupbucketpropwatchport, nil
}

func NewGroupBucketPropWatchPort() *GroupBucketPropWatchPort {
	return &GroupBucketPropWatchPort{
		GroupBucketProp: NewGroupBucketProp(1),
	}
}

type GroupBucketPropWeight struct {
	*GroupBucketProp
	Weight uint16
}

func (self *GroupBucketPropWeight) Serialize(encoder *goloxi.Encoder) error {
	if err := self.GroupBucketProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Weight))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupBucketPropWeight(parent *GroupBucketProp, decoder *goloxi.Decoder) (*GroupBucketPropWeight, error) {
	groupbucketpropweight := &GroupBucketPropWeight{GroupBucketProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GroupBucketPropWeight packet too short: %d < 4", decoder.Length())
	}
	groupbucketpropweight.Weight = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return groupbucketpropweight, nil
}

func NewGroupBucketPropWeight() *GroupBucketPropWeight {
	return &GroupBucketPropWeight{
		GroupBucketProp: NewGroupBucketProp(0),
	}
}

type GroupDescStatsEntry struct {
	Length         uint16
	GroupType      GroupType
	GroupId        uint32
	BucketArrayLen uint16
	Buckets        []*Bucket
	Properties     []IGroupProp
}

func (self *GroupDescStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.GroupType))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.PutUint16(uint16(self.BucketArrayLen))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Buckets {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupDescStatsEntry(decoder *goloxi.Decoder) (*GroupDescStatsEntry, error) {
	groupdescstatsentry := &GroupDescStatsEntry{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("GroupDescStatsEntry packet too short: %d < 16", decoder.Length())
	}
	groupdescstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupdescstatsentry.Length), 2+0)
	groupdescstatsentry.GroupType = GroupType(decoder.ReadByte())
	decoder.Skip(1)
	groupdescstatsentry.GroupId = uint32(decoder.ReadUint32())
	groupdescstatsentry.BucketArrayLen = uint16(decoder.ReadUint16())
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := decodeBucket(decoder)
		if err != nil {
			return nil, err
		}
		groupdescstatsentry.Buckets = append(groupdescstatsentry.Buckets, item)
	}

	for decoder.Length() >= 4 {
		item, err := decodeGroupProp(decoder)
		if err != nil {
			return nil, err
		}
		groupdescstatsentry.Properties = append(groupdescstatsentry.Properties, item)
	}
	return groupdescstatsentry, nil
}

func NewGroupDescStatsEntry() *GroupDescStatsEntry {
	return &GroupDescStatsEntry{}
}

type GroupProp struct {
	Type   uint16
	Length uint16
}

type IGroupProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *GroupProp) GetType() uint16 {
	return self.Type
}

func (self *GroupProp) GetLength() uint16 {
	return self.Length
}

func (self *GroupProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeGroupProp(decoder *goloxi.Decoder) (IGroupProp, error) {
	groupprop := &GroupProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("GroupProp packet too short: %d < 4", decoder.Length())
	}
	groupprop.Type = uint16(decoder.ReadUint16())
	groupprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupprop.Length), 2+2)
	return groupprop, nil
}

func NewGroupProp(_type uint16) *GroupProp {
	return &GroupProp{
		Type: _type,
	}
}

type GroupPropExperimenter struct {
	Type         uint16
	Length       uint16
	Experimenter uint32
	ExpType      uint32
}

type IGroupPropExperimenter interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *GroupPropExperimenter) GetType() uint16 {
	return self.Type
}

func (self *GroupPropExperimenter) GetLength() uint16 {
	return self.Length
}

func (self *GroupPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *GroupPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *GroupPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeGroupPropExperimenter(decoder *goloxi.Decoder) (IGroupPropExperimenter, error) {
	grouppropexperimenter := &GroupPropExperimenter{}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("GroupPropExperimenter packet too short: %d < 12", decoder.Length())
	}
	grouppropexperimenter.Type = uint16(decoder.ReadUint16())
	// if grouppropexperimenter.Type != 65535 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '65535'.", grouppropexperimenter.Type)
	// }
	grouppropexperimenter.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(grouppropexperimenter.Length), 2+2)
	grouppropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	grouppropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return grouppropexperimenter, nil
}

func NewGroupPropExperimenter(_experimenter uint32) *GroupPropExperimenter {
	return &GroupPropExperimenter{
		Experimenter: _experimenter,
	}
}

type GroupStatsEntry struct {
	Length       uint16
	GroupId      uint32
	RefCount     uint32
	PacketCount  uint64
	ByteCount    uint64
	DurationSec  uint32
	DurationNsec uint32
	BucketStats  []*BucketCounter
}

func (self *GroupStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.GroupId))
	encoder.PutUint32(uint32(self.RefCount))
	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.BucketStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeGroupStatsEntry(decoder *goloxi.Decoder) (*GroupStatsEntry, error) {
	groupstatsentry := &GroupStatsEntry{}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("GroupStatsEntry packet too short: %d < 40", decoder.Length())
	}
	groupstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(groupstatsentry.Length), 2+0)
	decoder.Skip(2)
	groupstatsentry.GroupId = uint32(decoder.ReadUint32())
	groupstatsentry.RefCount = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	groupstatsentry.PacketCount = uint64(decoder.ReadUint64())
	groupstatsentry.ByteCount = uint64(decoder.ReadUint64())
	groupstatsentry.DurationSec = uint32(decoder.ReadUint32())
	groupstatsentry.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := decodeBucketCounter(decoder)
		if err != nil {
			return nil, err
		}
		groupstatsentry.BucketStats = append(groupstatsentry.BucketStats, item)
	}
	return groupstatsentry, nil
}

func NewGroupStatsEntry() *GroupStatsEntry {
	return &GroupStatsEntry{}
}

type HeaderType struct {
	Namespace HeaderTypeNamespace
	NsType    uint16
}

type IHeaderType interface {
	goloxi.Serializable
	GetNamespace() HeaderTypeNamespace
	GetNsType() uint16
}

func (self *HeaderType) GetNamespace() HeaderTypeNamespace {
	return self.Namespace
}

func (self *HeaderType) GetNsType() uint16 {
	return self.NsType
}

func (self *HeaderType) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Namespace))
	encoder.PutUint16(uint16(self.NsType))

	return nil
}

func decodeHeaderType(decoder *goloxi.Decoder) (IHeaderType, error) {
	headertype := &HeaderType{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("HeaderType packet too short: %d < 4", decoder.Length())
	}
	headertype.Namespace = HeaderTypeNamespace(decoder.ReadUint16())
	headertype.NsType = uint16(decoder.ReadUint16())
	return headertype, nil
}

func NewHeaderType(_namespace ofp_header_type_namespa) *HeaderType {
	return &HeaderType{
		Namespace: _namespace,
	}
}

type HelloElem struct {
	Type   uint16
	Length uint16
}

type IHelloElem interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *HelloElem) GetType() uint16 {
	return self.Type
}

func (self *HelloElem) GetLength() uint16 {
	return self.Length
}

func (self *HelloElem) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeHelloElem(decoder *goloxi.Decoder) (IHelloElem, error) {
	helloelem := &HelloElem{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("HelloElem packet too short: %d < 4", decoder.Length())
	}
	helloelem.Type = uint16(decoder.ReadUint16())
	helloelem.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(helloelem.Length), 2+2)

	switch helloelem.Type {
	case 1:
		return decodeHelloElemVersionbitmap(helloelem, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'HelloElem'", helloelem.Type)
	}
}

func NewHelloElem(_type uint16) *HelloElem {
	return &HelloElem{
		Type: _type,
	}
}

type HelloElemVersionbitmap struct {
	*HelloElem
	Bitmaps []*Uint32
}

func (self *HelloElemVersionbitmap) Serialize(encoder *goloxi.Encoder) error {
	if err := self.HelloElem.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Bitmaps {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeHelloElemVersionbitmap(parent *HelloElem, decoder *goloxi.Decoder) (*HelloElemVersionbitmap, error) {
	helloelemversionbitmap := &HelloElemVersionbitmap{HelloElem: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		helloelemversionbitmap.Bitmaps = append(helloelemversionbitmap.Bitmaps, item)
	}
	return helloelemversionbitmap, nil
}

func NewHelloElemVersionbitmap() *HelloElemVersionbitmap {
	return &HelloElemVersionbitmap{
		HelloElem: NewHelloElem(1),
	}
}

type InstructionId struct {
	Type uint16
	Len  uint16
}

type IInstructionId interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *InstructionId) GetType() uint16 {
	return self.Type
}

func (self *InstructionId) GetLen() uint16 {
	return self.Len
}

func (self *InstructionId) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeInstructionId(decoder *goloxi.Decoder) (IInstructionId, error) {
	instructionid := &InstructionId{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionId packet too short: %d < 4", decoder.Length())
	}
	instructionid.Type = uint16(decoder.ReadUint16())
	instructionid.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(instructionid.Len), 2+2)

	switch instructionid.Type {
	case 1:
		return decodeInstructionIdGotoTable(instructionid, decoder)
	case 2:
		return decodeInstructionIdWriteMetadata(instructionid, decoder)
	case 3:
		return decodeInstructionIdWriteActions(instructionid, decoder)
	case 4:
		return decodeInstructionIdApplyActions(instructionid, decoder)
	case 5:
		return decodeInstructionIdClearActions(instructionid, decoder)
	case 7:
		return decodeInstructionIdStatTrigger(instructionid, decoder)
	case 65535:
		return decodeInstructionIdExperimenter(instructionid, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionId'", instructionid.Type)
	}
}

func NewInstructionId(_type uint16) *InstructionId {
	return &InstructionId{
		Type: _type,
	}
}

type InstructionIdApplyActions struct {
	*InstructionId
}

func (self *InstructionIdApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdApplyActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdApplyActions, error) {
	instructionidapplyactions := &InstructionIdApplyActions{InstructionId: parent}
	return instructionidapplyactions, nil
}

func NewInstructionIdApplyActions() *InstructionIdApplyActions {
	return &InstructionIdApplyActions{
		InstructionId: NewInstructionId(4),
	}
}

type InstructionIdExperimenter struct {
	*InstructionId
	Experimenter uint32
}

type IInstructionIdExperimenter interface {
	IInstructionId
	GetExperimenter() uint32
}

func (self *InstructionIdExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *InstructionIdExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))

	return nil
}

func decodeInstructionIdExperimenter(parent *InstructionId, decoder *goloxi.Decoder) (IInstructionIdExperimenter, error) {
	instructionidexperimenter := &InstructionIdExperimenter{InstructionId: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionIdExperimenter packet too short: %d < 4", decoder.Length())
	}
	instructionidexperimenter.Experimenter = uint32(decoder.ReadUint32())

	switch instructionidexperimenter.Experimenter {
	case 6035143:
		return decodeInstructionIdBsn(instructionidexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionIdExperimenter'", instructionidexperimenter.Experimenter)
	}
}

func NewInstructionIdExperimenter(_experimenter uint32) *InstructionIdExperimenter {
	return &InstructionIdExperimenter{
		Experimenter:  _experimenter,
		InstructionId: NewInstructionId(65535),
	}
}

type InstructionIdBsn struct {
	*InstructionIdExperimenter
	Subtype uint32
}

type IInstructionIdBsn interface {
	IInstructionIdExperimenter
	GetSubtype() uint32
}

func (self *InstructionIdBsn) GetSubtype() uint32 {
	return self.Subtype
}

func (self *InstructionIdBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeInstructionIdBsn(parent *InstructionIdExperimenter, decoder *goloxi.Decoder) (IInstructionIdBsn, error) {
	instructionidbsn := &InstructionIdBsn{InstructionIdExperimenter: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("InstructionIdBsn packet too short: %d < 4", decoder.Length())
	}
	instructionidbsn.Subtype = uint32(decoder.ReadUint32())

	switch instructionidbsn.Subtype {
	case 0:
		return decodeInstructionIdBsnDisableSrcMacCheck(instructionidbsn, decoder)
	case 1:
		return decodeInstructionIdBsnArpOffload(instructionidbsn, decoder)
	case 2:
		return decodeInstructionIdBsnDhcpOffload(instructionidbsn, decoder)
	case 4:
		return decodeInstructionIdBsnPermit(instructionidbsn, decoder)
	case 5:
		return decodeInstructionIdBsnDeny(instructionidbsn, decoder)
	case 6:
		return decodeInstructionIdBsnPacketOfDeath(instructionidbsn, decoder)
	case 7:
		return decodeInstructionIdBsnPrioritizePdus(instructionidbsn, decoder)
	case 8:
		return decodeInstructionIdBsnRequireVlanXlate(instructionidbsn, decoder)
	case 9:
		return decodeInstructionIdBsnDisableVlanCounters(instructionidbsn, decoder)
	case 10:
		return decodeInstructionIdBsnSpanDestination(instructionidbsn, decoder)
	case 11:
		return decodeInstructionIdBsnAutoNegotiation(instructionidbsn, decoder)
	case 12:
		return decodeInstructionIdBsnInternalPriority(instructionidbsn, decoder)
	case 13:
		return decodeInstructionIdBsnDisableL3(instructionidbsn, decoder)
	case 14:
		return decodeInstructionIdBsnNdpOffload(instructionidbsn, decoder)
	case 15:
		return decodeInstructionIdBsnHashSelect(instructionidbsn, decoder)
	case 16:
		return decodeInstructionIdBsnDirectedBroadcast(instructionidbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'InstructionIdBsn'", instructionidbsn.Subtype)
	}
}

func NewInstructionIdBsn(_subtype uint32) *InstructionIdBsn {
	return &InstructionIdBsn{
		Subtype:                   _subtype,
		InstructionIdExperimenter: NewInstructionIdExperimenter(6035143),
	}
}

type InstructionIdBsnArpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnArpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnArpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnArpOffload, error) {
	instructionidbsnarpoffload := &InstructionIdBsnArpOffload{InstructionIdBsn: parent}
	return instructionidbsnarpoffload, nil
}

func NewInstructionIdBsnArpOffload() *InstructionIdBsnArpOffload {
	return &InstructionIdBsnArpOffload{
		InstructionIdBsn: NewInstructionIdBsn(1),
	}
}

type InstructionIdBsnAutoNegotiation struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnAutoNegotiation) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnAutoNegotiation(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnAutoNegotiation, error) {
	instructionidbsnautonegotiation := &InstructionIdBsnAutoNegotiation{InstructionIdBsn: parent}
	return instructionidbsnautonegotiation, nil
}

func NewInstructionIdBsnAutoNegotiation() *InstructionIdBsnAutoNegotiation {
	return &InstructionIdBsnAutoNegotiation{
		InstructionIdBsn: NewInstructionIdBsn(11),
	}
}

type InstructionIdBsnDeny struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDeny) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDeny(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDeny, error) {
	instructionidbsndeny := &InstructionIdBsnDeny{InstructionIdBsn: parent}
	return instructionidbsndeny, nil
}

func NewInstructionIdBsnDeny() *InstructionIdBsnDeny {
	return &InstructionIdBsnDeny{
		InstructionIdBsn: NewInstructionIdBsn(5),
	}
}

type InstructionIdBsnDhcpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDhcpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDhcpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDhcpOffload, error) {
	instructionidbsndhcpoffload := &InstructionIdBsnDhcpOffload{InstructionIdBsn: parent}
	return instructionidbsndhcpoffload, nil
}

func NewInstructionIdBsnDhcpOffload() *InstructionIdBsnDhcpOffload {
	return &InstructionIdBsnDhcpOffload{
		InstructionIdBsn: NewInstructionIdBsn(2),
	}
}

type InstructionIdBsnDirectedBroadcast struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDirectedBroadcast) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDirectedBroadcast(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDirectedBroadcast, error) {
	instructionidbsndirectedbroadcast := &InstructionIdBsnDirectedBroadcast{InstructionIdBsn: parent}
	return instructionidbsndirectedbroadcast, nil
}

func NewInstructionIdBsnDirectedBroadcast() *InstructionIdBsnDirectedBroadcast {
	return &InstructionIdBsnDirectedBroadcast{
		InstructionIdBsn: NewInstructionIdBsn(16),
	}
}

type InstructionIdBsnDisableL3 struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableL3) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDisableL3(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableL3, error) {
	instructionidbsndisablel3 := &InstructionIdBsnDisableL3{InstructionIdBsn: parent}
	return instructionidbsndisablel3, nil
}

func NewInstructionIdBsnDisableL3() *InstructionIdBsnDisableL3 {
	return &InstructionIdBsnDisableL3{
		InstructionIdBsn: NewInstructionIdBsn(13),
	}
}

type InstructionIdBsnDisableSrcMacCheck struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableSrcMacCheck) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDisableSrcMacCheck(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableSrcMacCheck, error) {
	instructionidbsndisablesrcmaccheck := &InstructionIdBsnDisableSrcMacCheck{InstructionIdBsn: parent}
	return instructionidbsndisablesrcmaccheck, nil
}

func NewInstructionIdBsnDisableSrcMacCheck() *InstructionIdBsnDisableSrcMacCheck {
	return &InstructionIdBsnDisableSrcMacCheck{
		InstructionIdBsn: NewInstructionIdBsn(0),
	}
}

type InstructionIdBsnDisableVlanCounters struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnDisableVlanCounters) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnDisableVlanCounters(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnDisableVlanCounters, error) {
	instructionidbsndisablevlancounters := &InstructionIdBsnDisableVlanCounters{InstructionIdBsn: parent}
	return instructionidbsndisablevlancounters, nil
}

func NewInstructionIdBsnDisableVlanCounters() *InstructionIdBsnDisableVlanCounters {
	return &InstructionIdBsnDisableVlanCounters{
		InstructionIdBsn: NewInstructionIdBsn(9),
	}
}

type InstructionIdBsnHashSelect struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnHashSelect) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnHashSelect(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnHashSelect, error) {
	instructionidbsnhashselect := &InstructionIdBsnHashSelect{InstructionIdBsn: parent}
	return instructionidbsnhashselect, nil
}

func NewInstructionIdBsnHashSelect() *InstructionIdBsnHashSelect {
	return &InstructionIdBsnHashSelect{
		InstructionIdBsn: NewInstructionIdBsn(15),
	}
}

type InstructionIdBsnInternalPriority struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnInternalPriority) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnInternalPriority(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnInternalPriority, error) {
	instructionidbsninternalpriority := &InstructionIdBsnInternalPriority{InstructionIdBsn: parent}
	return instructionidbsninternalpriority, nil
}

func NewInstructionIdBsnInternalPriority() *InstructionIdBsnInternalPriority {
	return &InstructionIdBsnInternalPriority{
		InstructionIdBsn: NewInstructionIdBsn(12),
	}
}

type InstructionIdBsnNdpOffload struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnNdpOffload) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnNdpOffload(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnNdpOffload, error) {
	instructionidbsnndpoffload := &InstructionIdBsnNdpOffload{InstructionIdBsn: parent}
	return instructionidbsnndpoffload, nil
}

func NewInstructionIdBsnNdpOffload() *InstructionIdBsnNdpOffload {
	return &InstructionIdBsnNdpOffload{
		InstructionIdBsn: NewInstructionIdBsn(14),
	}
}

type InstructionIdBsnPacketOfDeath struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPacketOfDeath) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnPacketOfDeath(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPacketOfDeath, error) {
	instructionidbsnpacketofdeath := &InstructionIdBsnPacketOfDeath{InstructionIdBsn: parent}
	return instructionidbsnpacketofdeath, nil
}

func NewInstructionIdBsnPacketOfDeath() *InstructionIdBsnPacketOfDeath {
	return &InstructionIdBsnPacketOfDeath{
		InstructionIdBsn: NewInstructionIdBsn(6),
	}
}

type InstructionIdBsnPermit struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPermit) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnPermit(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPermit, error) {
	instructionidbsnpermit := &InstructionIdBsnPermit{InstructionIdBsn: parent}
	return instructionidbsnpermit, nil
}

func NewInstructionIdBsnPermit() *InstructionIdBsnPermit {
	return &InstructionIdBsnPermit{
		InstructionIdBsn: NewInstructionIdBsn(4),
	}
}

type InstructionIdBsnPrioritizePdus struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnPrioritizePdus) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnPrioritizePdus(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnPrioritizePdus, error) {
	instructionidbsnprioritizepdus := &InstructionIdBsnPrioritizePdus{InstructionIdBsn: parent}
	return instructionidbsnprioritizepdus, nil
}

func NewInstructionIdBsnPrioritizePdus() *InstructionIdBsnPrioritizePdus {
	return &InstructionIdBsnPrioritizePdus{
		InstructionIdBsn: NewInstructionIdBsn(7),
	}
}

type InstructionIdBsnRequireVlanXlate struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnRequireVlanXlate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnRequireVlanXlate(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnRequireVlanXlate, error) {
	instructionidbsnrequirevlanxlate := &InstructionIdBsnRequireVlanXlate{InstructionIdBsn: parent}
	return instructionidbsnrequirevlanxlate, nil
}

func NewInstructionIdBsnRequireVlanXlate() *InstructionIdBsnRequireVlanXlate {
	return &InstructionIdBsnRequireVlanXlate{
		InstructionIdBsn: NewInstructionIdBsn(8),
	}
}

type InstructionIdBsnSpanDestination struct {
	*InstructionIdBsn
}

func (self *InstructionIdBsnSpanDestination) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionIdBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdBsnSpanDestination(parent *InstructionIdBsn, decoder *goloxi.Decoder) (*InstructionIdBsnSpanDestination, error) {
	instructionidbsnspandestination := &InstructionIdBsnSpanDestination{InstructionIdBsn: parent}
	return instructionidbsnspandestination, nil
}

func NewInstructionIdBsnSpanDestination() *InstructionIdBsnSpanDestination {
	return &InstructionIdBsnSpanDestination{
		InstructionIdBsn: NewInstructionIdBsn(10),
	}
}

type InstructionIdClearActions struct {
	*InstructionId
}

func (self *InstructionIdClearActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdClearActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdClearActions, error) {
	instructionidclearactions := &InstructionIdClearActions{InstructionId: parent}
	return instructionidclearactions, nil
}

func NewInstructionIdClearActions() *InstructionIdClearActions {
	return &InstructionIdClearActions{
		InstructionId: NewInstructionId(5),
	}
}

type InstructionIdGotoTable struct {
	*InstructionId
}

func (self *InstructionIdGotoTable) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdGotoTable(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdGotoTable, error) {
	instructionidgototable := &InstructionIdGotoTable{InstructionId: parent}
	return instructionidgototable, nil
}

func NewInstructionIdGotoTable() *InstructionIdGotoTable {
	return &InstructionIdGotoTable{
		InstructionId: NewInstructionId(1),
	}
}

type InstructionIdStatTrigger struct {
	*InstructionId
}

func (self *InstructionIdStatTrigger) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdStatTrigger(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdStatTrigger, error) {
	instructionidstattrigger := &InstructionIdStatTrigger{InstructionId: parent}
	return instructionidstattrigger, nil
}

func NewInstructionIdStatTrigger() *InstructionIdStatTrigger {
	return &InstructionIdStatTrigger{
		InstructionId: NewInstructionId(7),
	}
}

type InstructionIdWriteActions struct {
	*InstructionId
}

func (self *InstructionIdWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdWriteActions(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdWriteActions, error) {
	instructionidwriteactions := &InstructionIdWriteActions{InstructionId: parent}
	return instructionidwriteactions, nil
}

func NewInstructionIdWriteActions() *InstructionIdWriteActions {
	return &InstructionIdWriteActions{
		InstructionId: NewInstructionId(3),
	}
}

type InstructionIdWriteMetadata struct {
	*InstructionId
}

func (self *InstructionIdWriteMetadata) Serialize(encoder *goloxi.Encoder) error {
	if err := self.InstructionId.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeInstructionIdWriteMetadata(parent *InstructionId, decoder *goloxi.Decoder) (*InstructionIdWriteMetadata, error) {
	instructionidwritemetadata := &InstructionIdWriteMetadata{InstructionId: parent}
	return instructionidwritemetadata, nil
}

func NewInstructionIdWriteMetadata() *InstructionIdWriteMetadata {
	return &InstructionIdWriteMetadata{
		InstructionId: NewInstructionId(2),
	}
}

type MatchV3 struct {
	Type    uint16
	Length  uint16
	OxmList []IOxm
}

func (self *MatchV3) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.OxmList {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}
func (self *MatchV3) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("MatchV3 packet too short: %d < 4", decoder.Length())
	}

	self.Type = uint16(decoder.ReadUint16())
	// if self.Type != 1 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '1'.", self.Type)
	// }
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return err
		}
		self.OxmList = append(self.OxmList, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewMatchV3() *MatchV3 {
	return &MatchV3{}
}

type MeterBand struct {
	Type uint16
	Len  uint16
}

type IMeterBand interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *MeterBand) GetType() uint16 {
	return self.Type
}

func (self *MeterBand) GetLen() uint16 {
	return self.Len
}

func (self *MeterBand) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeMeterBand(decoder *goloxi.Decoder) (IMeterBand, error) {
	meterband := &MeterBand{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("MeterBand packet too short: %d < 4", decoder.Length())
	}
	meterband.Type = uint16(decoder.ReadUint16())
	meterband.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(meterband.Len), 2+2)

	switch meterband.Type {
	case 1:
		return decodeMeterBandDrop(meterband, decoder)
	case 2:
		return decodeMeterBandDscpRemark(meterband, decoder)
	case 65535:
		return decodeMeterBandExperimenter(meterband, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'MeterBand'", meterband.Type)
	}
}

func NewMeterBand(_type uint16) *MeterBand {
	return &MeterBand{
		Type: _type,
	}
}

type MeterBandDrop struct {
	*MeterBand
	Rate      uint32
	BurstSize uint32
}

func (self *MeterBandDrop) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterBandDrop(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandDrop, error) {
	meterbanddrop := &MeterBandDrop{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandDrop packet too short: %d < 12", decoder.Length())
	}
	meterbanddrop.Rate = uint32(decoder.ReadUint32())
	meterbanddrop.BurstSize = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return meterbanddrop, nil
}

func NewMeterBandDrop() *MeterBandDrop {
	return &MeterBandDrop{
		MeterBand: NewMeterBand(1),
	}
}

type MeterBandDscpRemark struct {
	*MeterBand
	Rate      uint32
	BurstSize uint32
	PrecLevel uint8
}

func (self *MeterBandDscpRemark) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.PutUint8(uint8(self.PrecLevel))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterBandDscpRemark(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandDscpRemark, error) {
	meterbanddscpremark := &MeterBandDscpRemark{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandDscpRemark packet too short: %d < 12", decoder.Length())
	}
	meterbanddscpremark.Rate = uint32(decoder.ReadUint32())
	meterbanddscpremark.BurstSize = uint32(decoder.ReadUint32())
	meterbanddscpremark.PrecLevel = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return meterbanddscpremark, nil
}

func NewMeterBandDscpRemark() *MeterBandDscpRemark {
	return &MeterBandDscpRemark{
		MeterBand: NewMeterBand(2),
	}
}

type MeterBandExperimenter struct {
	*MeterBand
	Rate         uint32
	BurstSize    uint32
	Experimenter uint32
}

func (self *MeterBandExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.MeterBand.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Rate))
	encoder.PutUint32(uint32(self.BurstSize))
	encoder.PutUint32(uint32(self.Experimenter))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterBandExperimenter(parent *MeterBand, decoder *goloxi.Decoder) (*MeterBandExperimenter, error) {
	meterbandexperimenter := &MeterBandExperimenter{MeterBand: parent}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("MeterBandExperimenter packet too short: %d < 12", decoder.Length())
	}
	meterbandexperimenter.Rate = uint32(decoder.ReadUint32())
	meterbandexperimenter.BurstSize = uint32(decoder.ReadUint32())
	meterbandexperimenter.Experimenter = uint32(decoder.ReadUint32())
	return meterbandexperimenter, nil
}

func NewMeterBandExperimenter() *MeterBandExperimenter {
	return &MeterBandExperimenter{
		MeterBand: NewMeterBand(65535),
	}
}

type MeterBandStats struct {
	PacketBandCount uint64
	ByteBandCount   uint64
}

func (self *MeterBandStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.PacketBandCount))
	encoder.PutUint64(uint64(self.ByteBandCount))

	return nil
}

func decodeMeterBandStats(decoder *goloxi.Decoder) (*MeterBandStats, error) {
	meterbandstats := &MeterBandStats{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("MeterBandStats packet too short: %d < 16", decoder.Length())
	}
	meterbandstats.PacketBandCount = uint64(decoder.ReadUint64())
	meterbandstats.ByteBandCount = uint64(decoder.ReadUint64())
	return meterbandstats, nil
}

func NewMeterBandStats() *MeterBandStats {
	return &MeterBandStats{}
}

type MeterConfig struct {
	Length  uint16
	Flags   MeterFlags
	MeterId uint32
	Entries []IMeterBand
}

func (self *MeterConfig) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Flags))
	encoder.PutUint32(uint32(self.MeterId))
	for _, obj := range self.Entries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterConfig(decoder *goloxi.Decoder) (*MeterConfig, error) {
	meterconfig := &MeterConfig{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("MeterConfig packet too short: %d < 8", decoder.Length())
	}
	meterconfig.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(meterconfig.Length), 2+0)
	meterconfig.Flags = MeterFlags(decoder.ReadUint16())
	meterconfig.MeterId = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeMeterBand(decoder)
		if err != nil {
			return nil, err
		}
		meterconfig.Entries = append(meterconfig.Entries, item)
	}
	return meterconfig, nil
}

func NewMeterConfig() *MeterConfig {
	return &MeterConfig{}
}

type MeterFeatures struct {
	MaxMeter     uint32
	BandTypes    uint32
	Capabilities uint32
	MaxBands     uint8
	MaxColor     uint8
	Features     uint32
}

func (self *MeterFeatures) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MaxMeter))
	encoder.PutUint32(uint32(self.BandTypes))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint8(uint8(self.MaxBands))
	encoder.PutUint8(uint8(self.MaxColor))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint32(uint32(self.Features))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}
func (self *MeterFeatures) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 24 {
		return fmt.Errorf("MeterFeatures packet too short: %d < 24", decoder.Length())
	}

	self.MaxMeter = uint32(decoder.ReadUint32())
	self.BandTypes = uint32(decoder.ReadUint32())
	self.Capabilities = uint32(decoder.ReadUint32())
	self.MaxBands = uint8(decoder.ReadByte())
	self.MaxColor = uint8(decoder.ReadByte())
	decoder.Skip(2)
	self.Features = uint32(decoder.ReadUint32())
	decoder.Skip(4)

	return nil
}

func NewMeterFeatures() *MeterFeatures {
	return &MeterFeatures{}
}

type MeterStats struct {
	MeterId       uint32
	Len           uint16
	RefCount      uint32
	PacketInCount uint64
	ByteInCount   uint64
	DurationSec   uint32
	DurationNsec  uint32
	BandStats     []*MeterBandStats
}

func (self *MeterStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.MeterId))
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	encoder.PutUint32(uint32(self.RefCount))
	encoder.PutUint64(uint64(self.PacketInCount))
	encoder.PutUint64(uint64(self.ByteInCount))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.BandStats {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}

func decodeMeterStats(decoder *goloxi.Decoder) (*MeterStats, error) {
	meterstats := &MeterStats{}
	if decoder.Length() < 40 {
		return nil, fmt.Errorf("MeterStats packet too short: %d < 40", decoder.Length())
	}
	meterstats.MeterId = uint32(decoder.ReadUint32())
	meterstats.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(meterstats.Len), 2+4)
	decoder.Skip(6)
	meterstats.RefCount = uint32(decoder.ReadUint32())
	meterstats.PacketInCount = uint64(decoder.ReadUint64())
	meterstats.ByteInCount = uint64(decoder.ReadUint64())
	meterstats.DurationSec = uint32(decoder.ReadUint32())
	meterstats.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 16 {
		item, err := decodeMeterBandStats(decoder)
		if err != nil {
			return nil, err
		}
		meterstats.BandStats = append(meterstats.BandStats, item)
	}
	return meterstats, nil
}

func NewMeterStats() *MeterStats {
	return &MeterStats{}
}

type NiciraMatch struct {
	NxmEntries []IOxm
}

func (self *NiciraMatch) Serialize(encoder *goloxi.Encoder) error {
	for _, obj := range self.NxmEntries {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	return nil
}
func (self *NiciraMatch) Decode(decoder *goloxi.Decoder) error {

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return err
		}
		self.NxmEntries = append(self.NxmEntries, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewNiciraMatch() *NiciraMatch {
	return &NiciraMatch{}
}

type NiciraFlowStats struct {
	Length       uint16
	TableId      uint8
	DurationSec  uint32
	DurationNsec uint32
	Priority     uint16
	IdleTimeout  uint16
	HardTimeout  uint16
	MatchLen     uint16
	IdleAge      uint16
	HardAge      uint16
	Cookie       uint64
	PacketCount  uint64
	ByteCount    uint64
	Match        NiciraMatch
	Actions      []IAction
}

func (self *NiciraFlowStats) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint16(uint16(self.IdleAge))
	encoder.PutUint16(uint16(self.HardAge))
	encoder.PutUint64(uint64(self.Cookie))
	encoder.PutUint64(uint64(self.PacketCount))
	encoder.PutUint64(uint64(self.ByteCount))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowStats(decoder *goloxi.Decoder) (*NiciraFlowStats, error) {
	niciraflowstats := &NiciraFlowStats{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("NiciraFlowStats packet too short: %d < 48", decoder.Length())
	}
	niciraflowstats.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowstats.Length), 2+0)
	niciraflowstats.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowstats.DurationSec = uint32(decoder.ReadUint32())
	niciraflowstats.DurationNsec = uint32(decoder.ReadUint32())
	niciraflowstats.Priority = uint16(decoder.ReadUint16())
	niciraflowstats.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowstats.MatchLen = uint16(decoder.ReadUint16())
	niciraflowstats.IdleAge = uint16(decoder.ReadUint16())
	niciraflowstats.HardAge = uint16(decoder.ReadUint16())
	niciraflowstats.Cookie = uint64(decoder.ReadUint64())
	niciraflowstats.PacketCount = uint64(decoder.ReadUint64())
	niciraflowstats.ByteCount = uint64(decoder.ReadUint64())
	if err := niciraflowstats.Match.Decode(decoder.SliceDecoder(int(niciraflowstats.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowstats.Actions = append(niciraflowstats.Actions, item)
	}
	return niciraflowstats, nil
}

func NewNiciraFlowStats() *NiciraFlowStats {
	return &NiciraFlowStats{}
}

type NiciraFlowUpdateEvent struct {
	Length uint16
	Event  uint16
}

type INiciraFlowUpdateEvent interface {
	goloxi.Serializable
	GetLength() uint16
	GetEvent() uint16
}

func (self *NiciraFlowUpdateEvent) GetLength() uint16 {
	return self.Length
}

func (self *NiciraFlowUpdateEvent) GetEvent() uint16 {
	return self.Event
}

func (self *NiciraFlowUpdateEvent) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint16(uint16(self.Event))

	return nil
}

func decodeNiciraFlowUpdateEvent(decoder *goloxi.Decoder) (INiciraFlowUpdateEvent, error) {
	niciraflowupdateevent := &NiciraFlowUpdateEvent{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("NiciraFlowUpdateEvent packet too short: %d < 4", decoder.Length())
	}
	niciraflowupdateevent.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(niciraflowupdateevent.Length), 2+0)
	niciraflowupdateevent.Event = uint16(decoder.ReadUint16())

	switch niciraflowupdateevent.Event {
	case 0:
		return decodeNiciraFlowUpdateFullAdd(niciraflowupdateevent, decoder)
	case 1:
		return decodeNiciraFlowUpdateFullDeleted(niciraflowupdateevent, decoder)
	case 2:
		return decodeNiciraFlowUpdateFullModified(niciraflowupdateevent, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'NiciraFlowUpdateEvent'", niciraflowupdateevent.Event)
	}
}

func NewNiciraFlowUpdateEvent(_event uint16) *NiciraFlowUpdateEvent {
	return &NiciraFlowUpdateEvent{
		Event: _event,
	}
}

type NiciraFlowUpdateFullAdd struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullAdd) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullAdd(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullAdd, error) {
	niciraflowupdatefulladd := &NiciraFlowUpdateFullAdd{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullAdd packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulladd.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulladd.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulladd.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulladd.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulladd.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulladd.Actions = append(niciraflowupdatefulladd.Actions, item)
	}
	return niciraflowupdatefulladd, nil
}

func NewNiciraFlowUpdateFullAdd() *NiciraFlowUpdateFullAdd {
	return &NiciraFlowUpdateFullAdd{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(0),
	}
}

type NiciraFlowUpdateFullDeleted struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullDeleted) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullDeleted(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullDeleted, error) {
	niciraflowupdatefulldeleted := &NiciraFlowUpdateFullDeleted{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullDeleted packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefulldeleted.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefulldeleted.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefulldeleted.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefulldeleted.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefulldeleted.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefulldeleted.Actions = append(niciraflowupdatefulldeleted.Actions, item)
	}
	return niciraflowupdatefulldeleted, nil
}

func NewNiciraFlowUpdateFullDeleted() *NiciraFlowUpdateFullDeleted {
	return &NiciraFlowUpdateFullDeleted{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(1),
	}
}

type NiciraFlowUpdateFullModified struct {
	*NiciraFlowUpdateEvent
	Reason      uint16
	Priority    uint16
	IdleTimeout uint16
	HardTimeout uint16
	MatchLen    uint16
	TableId     uint8
	Cookie      uint64
	Match       NiciraMatch
	Actions     []IAction
}

func (self *NiciraFlowUpdateFullModified) Serialize(encoder *goloxi.Encoder) error {
	if err := self.NiciraFlowUpdateEvent.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Reason))
	encoder.PutUint16(uint16(self.Priority))
	encoder.PutUint16(uint16(self.IdleTimeout))
	encoder.PutUint16(uint16(self.HardTimeout))
	encoder.PutUint16(uint16(self.MatchLen))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint64(uint64(self.Cookie))
	if err := self.Match.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.Actions {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeNiciraFlowUpdateFullModified(parent *NiciraFlowUpdateEvent, decoder *goloxi.Decoder) (*NiciraFlowUpdateFullModified, error) {
	niciraflowupdatefullmodified := &NiciraFlowUpdateFullModified{NiciraFlowUpdateEvent: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("NiciraFlowUpdateFullModified packet too short: %d < 20", decoder.Length())
	}
	niciraflowupdatefullmodified.Reason = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.Priority = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.IdleTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.HardTimeout = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.MatchLen = uint16(decoder.ReadUint16())
	niciraflowupdatefullmodified.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	niciraflowupdatefullmodified.Cookie = uint64(decoder.ReadUint64())
	if err := niciraflowupdatefullmodified.Match.Decode(decoder.SliceDecoder(int(niciraflowupdatefullmodified.MatchLen), 0)); err != nil {
		return nil, err
	}

	decoder.SkipAlign()

	for decoder.Length() >= 4 {
		item, err := decodeAction(decoder)
		if err != nil {
			return nil, err
		}
		niciraflowupdatefullmodified.Actions = append(niciraflowupdatefullmodified.Actions, item)
	}
	return niciraflowupdatefullmodified, nil
}

func NewNiciraFlowUpdateFullModified() *NiciraFlowUpdateFullModified {
	return &NiciraFlowUpdateFullModified{
		NiciraFlowUpdateEvent: NewNiciraFlowUpdateEvent(2),
	}
}

type PacketQueue struct {
	QueueId    uint32
	Port       PortNo
	Len        uint16
	Properties []IQueueProp
}

func (self *PacketQueue) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.QueueId))
	self.Port.Serialize(encoder)
	encoder.PutUint16(uint16(self.Len))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func decodePacketQueue(decoder *goloxi.Decoder) (*PacketQueue, error) {
	packetqueue := &PacketQueue{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("PacketQueue packet too short: %d < 16", decoder.Length())
	}
	packetqueue.QueueId = uint32(decoder.ReadUint32())
	packetqueue.Port.Decode(decoder)
	packetqueue.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(packetqueue.Len), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 8 {
		item, err := decodeQueueProp(decoder)
		if err != nil {
			return nil, err
		}
		packetqueue.Properties = append(packetqueue.Properties, item)
	}
	return packetqueue, nil
}

func NewPacketQueue() *PacketQueue {
	return &PacketQueue{}
}

type PortDesc struct {
	PortNo     PortNo
	Length     uint16
	HwAddr     net.HardwareAddr
	Name       string
	Config     PortConfig
	State      PortState
	Properties []IPortDescProp
}

func (self *PortDesc) Serialize(encoder *goloxi.Encoder) error {
	self.PortNo.Serialize(encoder)
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write(self.HwAddr)
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.Write([]byte(self.Name))
	encoder.PutUint32(uint32(self.Config))
	encoder.PutUint32(uint32(self.State))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[4:6], uint16(len(encoder.Bytes())))

	return nil
}
func (self *PortDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 40 {
		return fmt.Errorf("PortDesc packet too short: %d < 40", decoder.Length())
	}

	self.PortNo.Decode(decoder)
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+4)
	decoder.Skip(2)
	self.HwAddr = net.HardwareAddr(decoder.Read(6))
	decoder.Skip(2)
	self.Name = string(bytes.Trim(decoder.Read(16), "\x00"))
	self.Config = PortConfig(decoder.ReadUint32())
	self.State = PortState(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodePortDescProp(decoder)
		if err != nil {
			return err
		}
		self.Properties = append(self.Properties, item)
	}

	return nil
}

func NewPortDesc() *PortDesc {
	return &PortDesc{}
}

type PortDescProp struct {
	Type   uint16
	Length uint16
}

type IPortDescProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortDescProp) GetType() uint16 {
	return self.Type
}

func (self *PortDescProp) GetLength() uint16 {
	return self.Length
}

func (self *PortDescProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodePortDescProp(decoder *goloxi.Decoder) (IPortDescProp, error) {
	portdescprop := &PortDescProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescProp packet too short: %d < 4", decoder.Length())
	}
	portdescprop.Type = uint16(decoder.ReadUint16())
	portdescprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portdescprop.Length), 2+2)

	switch portdescprop.Type {
	case 0:
		return decodePortDescPropEthernet(portdescprop, decoder)
	case 1:
		return decodePortDescPropOptical(portdescprop, decoder)
	case 65535:
		return decodePortDescPropExperimenter(portdescprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescProp'", portdescprop.Type)
	}
}

func NewPortDescProp(_type uint16) *PortDescProp {
	return &PortDescProp{
		Type: _type,
	}
}

type PortDescPropExperimenter struct {
	*PortDescProp
	Experimenter uint32
	ExpType      uint32
}

type IPortDescPropExperimenter interface {
	IPortDescProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortDescPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortDescPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortDescPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodePortDescPropExperimenter(parent *PortDescProp, decoder *goloxi.Decoder) (IPortDescPropExperimenter, error) {
	portdescpropexperimenter := &PortDescPropExperimenter{PortDescProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	portdescpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	portdescpropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch portdescpropexperimenter.Experimenter {
	case 6035143:
		return decodePortDescPropBsn(portdescpropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescPropExperimenter'", portdescpropexperimenter.Experimenter)
	}
}

func NewPortDescPropExperimenter(_experimenter uint32) *PortDescPropExperimenter {
	return &PortDescPropExperimenter{
		Experimenter: _experimenter,
		PortDescProp: NewPortDescProp(65535),
	}
}

type PortDescPropBsn struct {
	*PortDescPropExperimenter
}

type IPortDescPropBsn interface {
	IPortDescPropExperimenter
}

func (self *PortDescPropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodePortDescPropBsn(parent *PortDescPropExperimenter, decoder *goloxi.Decoder) (IPortDescPropBsn, error) {
	portdescpropbsn := &PortDescPropBsn{PortDescPropExperimenter: parent}

	switch portdescpropbsn.ExpType {
	case 0:
		return decodePortDescPropBsnUplink(portdescpropbsn, decoder)
	case 1:
		return decodePortDescPropBsnGenerationId(portdescpropbsn, decoder)
	case 2:
		return decodePortDescPropBsnForwardErrorCorrection(portdescpropbsn, decoder)
	case 3:
		return decodePortDescPropBsnBreakout(portdescpropbsn, decoder)
	case 4:
		return decodePortDescPropBsnSpeedCapabilities(portdescpropbsn, decoder)
	case 5:
		return decodePortDescPropBsnMiscCapabilities(portdescpropbsn, decoder)
	case 6:
		return decodePortDescPropBsnSffJson(portdescpropbsn, decoder)
	case 7:
		return decodePortDescPropBsnDriverInfoJson(portdescpropbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortDescPropBsn'", portdescpropbsn.ExpType)
	}
}

func NewPortDescPropBsn(_exp_type uint32) *PortDescPropBsn {
	return &PortDescPropBsn{
		ExpType:                  _exp_type,
		PortDescPropExperimenter: NewPortDescPropExperimenter(6035143),
	}
}

type PortDescPropBsnBreakout struct {
	*PortDescPropBsn
	SubInterfaceCount     uint16
	SubInterfaceSpeedGbps uint16
}

func (self *PortDescPropBsnBreakout) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.SubInterfaceCount))
	encoder.PutUint16(uint16(self.SubInterfaceSpeedGbps))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnBreakout(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnBreakout, error) {
	portdescpropbsnbreakout := &PortDescPropBsnBreakout{PortDescPropBsn: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescPropBsnBreakout packet too short: %d < 4", decoder.Length())
	}
	portdescpropbsnbreakout.SubInterfaceCount = uint16(decoder.ReadUint16())
	portdescpropbsnbreakout.SubInterfaceSpeedGbps = uint16(decoder.ReadUint16())
	return portdescpropbsnbreakout, nil
}

func NewPortDescPropBsnBreakout() *PortDescPropBsnBreakout {
	return &PortDescPropBsnBreakout{
		PortDescPropBsn: NewPortDescPropBsn(3),
	}
}

type PortDescPropBsnDriverInfoJson struct {
	*PortDescPropBsn
	DriverInfoJson []byte
}

func (self *PortDescPropBsnDriverInfoJson) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.DriverInfoJson)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnDriverInfoJson(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnDriverInfoJson, error) {
	portdescpropbsndriverinfojson := &PortDescPropBsnDriverInfoJson{PortDescPropBsn: parent}
	portdescpropbsndriverinfojson.DriverInfoJson = decoder.Read(decoder.Length())
	return portdescpropbsndriverinfojson, nil
}

func NewPortDescPropBsnDriverInfoJson() *PortDescPropBsnDriverInfoJson {
	return &PortDescPropBsnDriverInfoJson{
		PortDescPropBsn: NewPortDescPropBsn(7),
	}
}

type PortDescPropBsnForwardErrorCorrection struct {
	*PortDescPropBsn
	Configured BsnFecConfigState
	Enabled    uint32
}

func (self *PortDescPropBsnForwardErrorCorrection) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Configured))
	encoder.PutUint32(uint32(self.Enabled))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnForwardErrorCorrection(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnForwardErrorCorrection, error) {
	portdescpropbsnforwarderrorcorrection := &PortDescPropBsnForwardErrorCorrection{PortDescPropBsn: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropBsnForwardErrorCorrection packet too short: %d < 8", decoder.Length())
	}
	portdescpropbsnforwarderrorcorrection.Configured = BsnFecConfigState(decoder.ReadUint32())
	portdescpropbsnforwarderrorcorrection.Enabled = uint32(decoder.ReadUint32())
	return portdescpropbsnforwarderrorcorrection, nil
}

func NewPortDescPropBsnForwardErrorCorrection() *PortDescPropBsnForwardErrorCorrection {
	return &PortDescPropBsnForwardErrorCorrection{
		PortDescPropBsn: NewPortDescPropBsn(2),
	}
}

type PortDescPropBsnGenerationId struct {
	*PortDescPropBsn
	GenerationId uint64
}

func (self *PortDescPropBsnGenerationId) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.GenerationId))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnGenerationId(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnGenerationId, error) {
	portdescpropbsngenerationid := &PortDescPropBsnGenerationId{PortDescPropBsn: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortDescPropBsnGenerationId packet too short: %d < 8", decoder.Length())
	}
	portdescpropbsngenerationid.GenerationId = uint64(decoder.ReadUint64())
	return portdescpropbsngenerationid, nil
}

func NewPortDescPropBsnGenerationId() *PortDescPropBsnGenerationId {
	return &PortDescPropBsnGenerationId{
		PortDescPropBsn: NewPortDescPropBsn(1),
	}
}

type PortDescPropBsnMiscCapabilities struct {
	*PortDescPropBsn
	Current   uint64
	Available uint64
	Supported uint64
}

func (self *PortDescPropBsnMiscCapabilities) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Current))
	encoder.PutUint64(uint64(self.Available))
	encoder.PutUint64(uint64(self.Supported))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnMiscCapabilities(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnMiscCapabilities, error) {
	portdescpropbsnmisccapabilities := &PortDescPropBsnMiscCapabilities{PortDescPropBsn: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropBsnMiscCapabilities packet too short: %d < 24", decoder.Length())
	}
	portdescpropbsnmisccapabilities.Current = uint64(decoder.ReadUint64())
	portdescpropbsnmisccapabilities.Available = uint64(decoder.ReadUint64())
	portdescpropbsnmisccapabilities.Supported = uint64(decoder.ReadUint64())
	return portdescpropbsnmisccapabilities, nil
}

func NewPortDescPropBsnMiscCapabilities() *PortDescPropBsnMiscCapabilities {
	return &PortDescPropBsnMiscCapabilities{
		PortDescPropBsn: NewPortDescPropBsn(5),
	}
}

type PortDescPropBsnSffJson struct {
	*PortDescPropBsn
	DataJson []byte
}

func (self *PortDescPropBsnSffJson) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.DataJson)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnSffJson(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnSffJson, error) {
	portdescpropbsnsffjson := &PortDescPropBsnSffJson{PortDescPropBsn: parent}
	portdescpropbsnsffjson.DataJson = decoder.Read(decoder.Length())
	return portdescpropbsnsffjson, nil
}

func NewPortDescPropBsnSffJson() *PortDescPropBsnSffJson {
	return &PortDescPropBsnSffJson{
		PortDescPropBsn: NewPortDescPropBsn(6),
	}
}

type PortDescPropBsnSpeedCapabilities struct {
	*PortDescPropBsn
	Current   uint64
	Available uint64
	Supported uint64
}

func (self *PortDescPropBsnSpeedCapabilities) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint64(uint64(self.Current))
	encoder.PutUint64(uint64(self.Available))
	encoder.PutUint64(uint64(self.Supported))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnSpeedCapabilities(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnSpeedCapabilities, error) {
	portdescpropbsnspeedcapabilities := &PortDescPropBsnSpeedCapabilities{PortDescPropBsn: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropBsnSpeedCapabilities packet too short: %d < 24", decoder.Length())
	}
	portdescpropbsnspeedcapabilities.Current = uint64(decoder.ReadUint64())
	portdescpropbsnspeedcapabilities.Available = uint64(decoder.ReadUint64())
	portdescpropbsnspeedcapabilities.Supported = uint64(decoder.ReadUint64())
	return portdescpropbsnspeedcapabilities, nil
}

func NewPortDescPropBsnSpeedCapabilities() *PortDescPropBsnSpeedCapabilities {
	return &PortDescPropBsnSpeedCapabilities{
		PortDescPropBsn: NewPortDescPropBsn(4),
	}
}

type PortDescPropBsnUplink struct {
	*PortDescPropBsn
}

func (self *PortDescPropBsnUplink) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropBsnUplink(parent *PortDescPropBsn, decoder *goloxi.Decoder) (*PortDescPropBsnUplink, error) {
	portdescpropbsnuplink := &PortDescPropBsnUplink{PortDescPropBsn: parent}
	return portdescpropbsnuplink, nil
}

func NewPortDescPropBsnUplink() *PortDescPropBsnUplink {
	return &PortDescPropBsnUplink{
		PortDescPropBsn: NewPortDescPropBsn(0),
	}
}

type PortDescPropEgress struct {
	Type   uint16
	Length uint16
	OxmIds []byte
}

func (self *PortDescPropEgress) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(self.OxmIds)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropEgress(decoder *goloxi.Decoder) (*PortDescPropEgress, error) {
	portdescpropegress := &PortDescPropEgress{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescPropEgress packet too short: %d < 4", decoder.Length())
	}
	portdescpropegress.Type = uint16(decoder.ReadUint16())
	// if portdescpropegress.Type != 3 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '3'.", portdescpropegress.Type)
	// }
	portdescpropegress.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portdescpropegress.Length), 2+2)
	portdescpropegress.OxmIds = decoder.Read(decoder.Length())
	return portdescpropegress, nil
}

func NewPortDescPropEgress() *PortDescPropEgress {
	return &PortDescPropEgress{}
}

type PortDescPropEthernet struct {
	*PortDescProp
	Curr       uint32
	Advertised uint32
	Supported  uint32
	Peer       uint32
	CurrSpeed  uint32
	MaxSpeed   uint32
}

func (self *PortDescPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Curr))
	encoder.PutUint32(uint32(self.Advertised))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.Peer))
	encoder.PutUint32(uint32(self.CurrSpeed))
	encoder.PutUint32(uint32(self.MaxSpeed))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropEthernet(parent *PortDescProp, decoder *goloxi.Decoder) (*PortDescPropEthernet, error) {
	portdescpropethernet := &PortDescPropEthernet{PortDescProp: parent}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("PortDescPropEthernet packet too short: %d < 24", decoder.Length())
	}
	decoder.Skip(4)
	portdescpropethernet.Curr = uint32(decoder.ReadUint32())
	portdescpropethernet.Advertised = uint32(decoder.ReadUint32())
	portdescpropethernet.Supported = uint32(decoder.ReadUint32())
	portdescpropethernet.Peer = uint32(decoder.ReadUint32())
	portdescpropethernet.CurrSpeed = uint32(decoder.ReadUint32())
	portdescpropethernet.MaxSpeed = uint32(decoder.ReadUint32())
	return portdescpropethernet, nil
}

func NewPortDescPropEthernet() *PortDescPropEthernet {
	return &PortDescPropEthernet{
		PortDescProp: NewPortDescProp(0),
	}
}

type PortDescPropIngress struct {
	Type   uint16
	Length uint16
	OxmIds []byte
}

func (self *PortDescPropIngress) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(self.OxmIds)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropIngress(decoder *goloxi.Decoder) (*PortDescPropIngress, error) {
	portdescpropingress := &PortDescPropIngress{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescPropIngress packet too short: %d < 4", decoder.Length())
	}
	portdescpropingress.Type = uint16(decoder.ReadUint16())
	// if portdescpropingress.Type != 2 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '2'.", portdescpropingress.Type)
	// }
	portdescpropingress.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portdescpropingress.Length), 2+2)
	portdescpropingress.OxmIds = decoder.Read(decoder.Length())
	return portdescpropingress, nil
}

func NewPortDescPropIngress() *PortDescPropIngress {
	return &PortDescPropIngress{}
}

type PortDescPropOptical struct {
	*PortDescProp
	Supported      uint32
	TxMinFreqLmda  uint32
	TxMaxFreqLmda  uint32
	TxGridFreqLmda uint32
	RxMinFreqLmda  uint32
	RxMaxFreqLmda  uint32
	RxGridFreqLmda uint32
	TxPwrMin       uint32
	TxPwrMax       uint32
}

func (self *PortDescPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Supported))
	encoder.PutUint32(uint32(self.TxMinFreqLmda))
	encoder.PutUint32(uint32(self.TxMaxFreqLmda))
	encoder.PutUint32(uint32(self.TxGridFreqLmda))
	encoder.PutUint32(uint32(self.RxMinFreqLmda))
	encoder.PutUint32(uint32(self.RxMaxFreqLmda))
	encoder.PutUint32(uint32(self.RxGridFreqLmda))
	encoder.PutUint32(uint32(self.TxPwrMin))
	encoder.PutUint32(uint32(self.TxPwrMax))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropOptical(parent *PortDescProp, decoder *goloxi.Decoder) (*PortDescPropOptical, error) {
	portdescpropoptical := &PortDescPropOptical{PortDescProp: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("PortDescPropOptical packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	portdescpropoptical.Supported = uint32(decoder.ReadUint32())
	portdescpropoptical.TxMinFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.TxMaxFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.TxGridFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.RxMinFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.RxMaxFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.RxGridFreqLmda = uint32(decoder.ReadUint32())
	portdescpropoptical.TxPwrMin = uint32(decoder.ReadUint32())
	portdescpropoptical.TxPwrMax = uint32(decoder.ReadUint32())
	return portdescpropoptical, nil
}

func NewPortDescPropOptical() *PortDescPropOptical {
	return &PortDescPropOptical{
		PortDescProp: NewPortDescProp(1),
	}
}

type PortModProp struct {
	Type   uint16
	Length uint16
}

type IPortModProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortModProp) GetType() uint16 {
	return self.Type
}

func (self *PortModProp) GetLength() uint16 {
	return self.Length
}

func (self *PortModProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodePortModProp(decoder *goloxi.Decoder) (IPortModProp, error) {
	portmodprop := &PortModProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortModProp packet too short: %d < 4", decoder.Length())
	}
	portmodprop.Type = uint16(decoder.ReadUint16())
	portmodprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portmodprop.Length), 2+2)

	switch portmodprop.Type {
	case 0:
		return decodePortModPropEthernet(portmodprop, decoder)
	case 1:
		return decodePortModPropOptical(portmodprop, decoder)
	case 65535:
		return decodePortModPropExperimenter(portmodprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortModProp'", portmodprop.Type)
	}
}

func NewPortModProp(_type uint16) *PortModProp {
	return &PortModProp{
		Type: _type,
	}
}

type PortModPropEthernet struct {
	*PortModProp
	Advertise PortFeatures
}

func (self *PortModPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Advertise))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortModPropEthernet(parent *PortModProp, decoder *goloxi.Decoder) (*PortModPropEthernet, error) {
	portmodpropethernet := &PortModPropEthernet{PortModProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortModPropEthernet packet too short: %d < 4", decoder.Length())
	}
	portmodpropethernet.Advertise = PortFeatures(decoder.ReadUint32())
	return portmodpropethernet, nil
}

func NewPortModPropEthernet() *PortModPropEthernet {
	return &PortModPropEthernet{
		PortModProp: NewPortModProp(0),
	}
}

type PortModPropExperimenter struct {
	*PortModProp
	Experimenter uint32
	ExpType      uint32
}

type IPortModPropExperimenter interface {
	IPortModProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortModPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortModPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortModPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodePortModPropExperimenter(parent *PortModProp, decoder *goloxi.Decoder) (IPortModPropExperimenter, error) {
	portmodpropexperimenter := &PortModPropExperimenter{PortModProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortModPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	portmodpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	portmodpropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return portmodpropexperimenter, nil
}

func NewPortModPropExperimenter(_experimenter uint32) *PortModPropExperimenter {
	return &PortModPropExperimenter{
		Experimenter: _experimenter,
		PortModProp:  NewPortModProp(65535),
	}
}

type PortModPropOptical struct {
	*PortModProp
	Configure uint32
	FreqLdma  uint32
	FlOffset  uint32
	GridSpan  uint32
	TxPwr     uint32
}

func (self *PortModPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Configure))
	encoder.PutUint32(uint32(self.FreqLdma))
	encoder.PutUint32(uint32(self.FlOffset))
	encoder.PutUint32(uint32(self.GridSpan))
	encoder.PutUint32(uint32(self.TxPwr))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortModPropOptical(parent *PortModProp, decoder *goloxi.Decoder) (*PortModPropOptical, error) {
	portmodpropoptical := &PortModPropOptical{PortModProp: parent}
	if decoder.Length() < 20 {
		return nil, fmt.Errorf("PortModPropOptical packet too short: %d < 20", decoder.Length())
	}
	portmodpropoptical.Configure = uint32(decoder.ReadUint32())
	portmodpropoptical.FreqLdma = uint32(decoder.ReadUint32())
	portmodpropoptical.FlOffset = uint32(decoder.ReadUint32())
	portmodpropoptical.GridSpan = uint32(decoder.ReadUint32())
	portmodpropoptical.TxPwr = uint32(decoder.ReadUint32())
	return portmodpropoptical, nil
}

func NewPortModPropOptical() *PortModPropOptical {
	return &PortModPropOptical{
		PortModProp: NewPortModProp(1),
	}
}

type PortStatsEntry struct {
	Length       uint16
	PortNo       PortNo
	DurationSec  uint32
	DurationNsec uint32
	RxPackets    uint64
	TxPackets    uint64
	RxBytes      uint64
	TxBytes      uint64
	RxDropped    uint64
	TxDropped    uint64
	RxErrors     uint64
	TxErrors     uint64
	Properties   []IPortStatsProp
}

func (self *PortStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	encoder.PutUint64(uint64(self.RxPackets))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.RxBytes))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.RxDropped))
	encoder.PutUint64(uint64(self.TxDropped))
	encoder.PutUint64(uint64(self.RxErrors))
	encoder.PutUint64(uint64(self.TxErrors))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsEntry(decoder *goloxi.Decoder) (*PortStatsEntry, error) {
	portstatsentry := &PortStatsEntry{}
	if decoder.Length() < 80 {
		return nil, fmt.Errorf("PortStatsEntry packet too short: %d < 80", decoder.Length())
	}
	portstatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portstatsentry.Length), 2+0)
	decoder.Skip(2)
	portstatsentry.PortNo.Decode(decoder)
	portstatsentry.DurationSec = uint32(decoder.ReadUint32())
	portstatsentry.DurationNsec = uint32(decoder.ReadUint32())
	portstatsentry.RxPackets = uint64(decoder.ReadUint64())
	portstatsentry.TxPackets = uint64(decoder.ReadUint64())
	portstatsentry.RxBytes = uint64(decoder.ReadUint64())
	portstatsentry.TxBytes = uint64(decoder.ReadUint64())
	portstatsentry.RxDropped = uint64(decoder.ReadUint64())
	portstatsentry.TxDropped = uint64(decoder.ReadUint64())
	portstatsentry.RxErrors = uint64(decoder.ReadUint64())
	portstatsentry.TxErrors = uint64(decoder.ReadUint64())

	for decoder.Length() >= 4 {
		item, err := decodePortStatsProp(decoder)
		if err != nil {
			return nil, err
		}
		portstatsentry.Properties = append(portstatsentry.Properties, item)
	}
	return portstatsentry, nil
}

func NewPortStatsEntry() *PortStatsEntry {
	return &PortStatsEntry{}
}

type PortStatsProp struct {
	Type   uint16
	Length uint16
}

type IPortStatsProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *PortStatsProp) GetType() uint16 {
	return self.Type
}

func (self *PortStatsProp) GetLength() uint16 {
	return self.Length
}

func (self *PortStatsProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodePortStatsProp(decoder *goloxi.Decoder) (IPortStatsProp, error) {
	portstatsprop := &PortStatsProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortStatsProp packet too short: %d < 4", decoder.Length())
	}
	portstatsprop.Type = uint16(decoder.ReadUint16())
	portstatsprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portstatsprop.Length), 2+2)

	switch portstatsprop.Type {
	case 0:
		return decodePortStatsPropEthernet(portstatsprop, decoder)
	case 1:
		return decodePortStatsPropOptical(portstatsprop, decoder)
	case 65535:
		return decodePortStatsPropExperimenter(portstatsprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortStatsProp'", portstatsprop.Type)
	}
}

func NewPortStatsProp(_type uint16) *PortStatsProp {
	return &PortStatsProp{
		Type: _type,
	}
}

type PortStatsPropEthernet struct {
	*PortStatsProp
	RxFrameErr uint64
	RxOverErr  uint64
	RxCrcErr   uint64
	Collisions uint64
}

func (self *PortStatsPropEthernet) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.RxFrameErr))
	encoder.PutUint64(uint64(self.RxOverErr))
	encoder.PutUint64(uint64(self.RxCrcErr))
	encoder.PutUint64(uint64(self.Collisions))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsPropEthernet(parent *PortStatsProp, decoder *goloxi.Decoder) (*PortStatsPropEthernet, error) {
	portstatspropethernet := &PortStatsPropEthernet{PortStatsProp: parent}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("PortStatsPropEthernet packet too short: %d < 32", decoder.Length())
	}
	decoder.Skip(4)
	portstatspropethernet.RxFrameErr = uint64(decoder.ReadUint64())
	portstatspropethernet.RxOverErr = uint64(decoder.ReadUint64())
	portstatspropethernet.RxCrcErr = uint64(decoder.ReadUint64())
	portstatspropethernet.Collisions = uint64(decoder.ReadUint64())
	return portstatspropethernet, nil
}

func NewPortStatsPropEthernet() *PortStatsPropEthernet {
	return &PortStatsPropEthernet{
		PortStatsProp: NewPortStatsProp(0),
	}
}

type PortStatsPropExperimenter struct {
	*PortStatsProp
	Experimenter uint32
	ExpType      uint32
}

type IPortStatsPropExperimenter interface {
	IPortStatsProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *PortStatsPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *PortStatsPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *PortStatsPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodePortStatsPropExperimenter(parent *PortStatsProp, decoder *goloxi.Decoder) (IPortStatsPropExperimenter, error) {
	portstatspropexperimenter := &PortStatsPropExperimenter{PortStatsProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("PortStatsPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	portstatspropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	portstatspropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch portstatspropexperimenter.Experimenter {
	case 43521:
		return decodePortStatsPropExperimenterIntel(portstatspropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'PortStatsPropExperimenter'", portstatspropexperimenter.Experimenter)
	}
}

func NewPortStatsPropExperimenter(_experimenter uint32) *PortStatsPropExperimenter {
	return &PortStatsPropExperimenter{
		Experimenter:  _experimenter,
		PortStatsProp: NewPortStatsProp(65535),
	}
}

type PortStatsPropExperimenterIntel struct {
	*PortStatsPropExperimenter
	Rx1To64Packets      uint64
	Rx65To127Packets    uint64
	Rx128To255Packets   uint64
	Rx256To511Packets   uint64
	Rx512To1023Packets  uint64
	Rx1024To1522Packets uint64
	Rx1523ToMaxPackets  uint64
	Tx1To64Packets      uint64
	Tx65To127Packets    uint64
	Tx128To255Packets   uint64
	Tx256To511Packets   uint64
	Tx512To1023Packets  uint64
	Tx1024To1522Packets uint64
	Tx1523ToMaxPackets  uint64
	TxMulticastPackets  uint64
	RxBroadcastPackets  uint64
	TxBroadcastPackets  uint64
	RxUndersizedErrors  uint64
	RxOversizeErrors    uint64
	RxFragmentedErrors  uint64
	RxJabberErrors      uint64
}

func (self *PortStatsPropExperimenterIntel) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint64(uint64(self.Rx1To64Packets))
	encoder.PutUint64(uint64(self.Rx65To127Packets))
	encoder.PutUint64(uint64(self.Rx128To255Packets))
	encoder.PutUint64(uint64(self.Rx256To511Packets))
	encoder.PutUint64(uint64(self.Rx512To1023Packets))
	encoder.PutUint64(uint64(self.Rx1024To1522Packets))
	encoder.PutUint64(uint64(self.Rx1523ToMaxPackets))
	encoder.PutUint64(uint64(self.Tx1To64Packets))
	encoder.PutUint64(uint64(self.Tx65To127Packets))
	encoder.PutUint64(uint64(self.Tx128To255Packets))
	encoder.PutUint64(uint64(self.Tx256To511Packets))
	encoder.PutUint64(uint64(self.Tx512To1023Packets))
	encoder.PutUint64(uint64(self.Tx1024To1522Packets))
	encoder.PutUint64(uint64(self.Tx1523ToMaxPackets))
	encoder.PutUint64(uint64(self.TxMulticastPackets))
	encoder.PutUint64(uint64(self.RxBroadcastPackets))
	encoder.PutUint64(uint64(self.TxBroadcastPackets))
	encoder.PutUint64(uint64(self.RxUndersizedErrors))
	encoder.PutUint64(uint64(self.RxOversizeErrors))
	encoder.PutUint64(uint64(self.RxFragmentedErrors))
	encoder.PutUint64(uint64(self.RxJabberErrors))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsPropExperimenterIntel(parent *PortStatsPropExperimenter, decoder *goloxi.Decoder) (*PortStatsPropExperimenterIntel, error) {
	portstatspropexperimenterintel := &PortStatsPropExperimenterIntel{PortStatsPropExperimenter: parent}
	if decoder.Length() < 168 {
		return nil, fmt.Errorf("PortStatsPropExperimenterIntel packet too short: %d < 168", decoder.Length())
	}
	decoder.Skip(4)
	portstatspropexperimenterintel.Rx1To64Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx65To127Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx128To255Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx256To511Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx512To1023Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx1024To1522Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Rx1523ToMaxPackets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx1To64Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx65To127Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx128To255Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx256To511Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx512To1023Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx1024To1522Packets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.Tx1523ToMaxPackets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.TxMulticastPackets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.RxBroadcastPackets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.TxBroadcastPackets = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.RxUndersizedErrors = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.RxOversizeErrors = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.RxFragmentedErrors = uint64(decoder.ReadUint64())
	portstatspropexperimenterintel.RxJabberErrors = uint64(decoder.ReadUint64())
	return portstatspropexperimenterintel, nil
}

func NewPortStatsPropExperimenterIntel() *PortStatsPropExperimenterIntel {
	return &PortStatsPropExperimenterIntel{
		PortStatsPropExperimenter: NewPortStatsPropExperimenter(43521),
	}
}

type PortStatsPropOptical struct {
	*PortStatsProp
	Flags       uint32
	TxFreqLmda  uint32
	TxOffset    uint32
	TxGridSpan  uint32
	RxFreqLmda  uint32
	RxOffset    uint32
	RxGridSpan  uint32
	TxPwr       uint16
	RxPwr       uint16
	BiasCurrent uint16
	Temperature uint16
}

func (self *PortStatsPropOptical) Serialize(encoder *goloxi.Encoder) error {
	if err := self.PortStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Flags))
	encoder.PutUint32(uint32(self.TxFreqLmda))
	encoder.PutUint32(uint32(self.TxOffset))
	encoder.PutUint32(uint32(self.TxGridSpan))
	encoder.PutUint32(uint32(self.RxFreqLmda))
	encoder.PutUint32(uint32(self.RxOffset))
	encoder.PutUint32(uint32(self.RxGridSpan))
	encoder.PutUint16(uint16(self.TxPwr))
	encoder.PutUint16(uint16(self.RxPwr))
	encoder.PutUint16(uint16(self.BiasCurrent))
	encoder.PutUint16(uint16(self.Temperature))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortStatsPropOptical(parent *PortStatsProp, decoder *goloxi.Decoder) (*PortStatsPropOptical, error) {
	portstatspropoptical := &PortStatsPropOptical{PortStatsProp: parent}
	if decoder.Length() < 36 {
		return nil, fmt.Errorf("PortStatsPropOptical packet too short: %d < 36", decoder.Length())
	}
	decoder.Skip(4)
	portstatspropoptical.Flags = uint32(decoder.ReadUint32())
	portstatspropoptical.TxFreqLmda = uint32(decoder.ReadUint32())
	portstatspropoptical.TxOffset = uint32(decoder.ReadUint32())
	portstatspropoptical.TxGridSpan = uint32(decoder.ReadUint32())
	portstatspropoptical.RxFreqLmda = uint32(decoder.ReadUint32())
	portstatspropoptical.RxOffset = uint32(decoder.ReadUint32())
	portstatspropoptical.RxGridSpan = uint32(decoder.ReadUint32())
	portstatspropoptical.TxPwr = uint16(decoder.ReadUint16())
	portstatspropoptical.RxPwr = uint16(decoder.ReadUint16())
	portstatspropoptical.BiasCurrent = uint16(decoder.ReadUint16())
	portstatspropoptical.Temperature = uint16(decoder.ReadUint16())
	return portstatspropoptical, nil
}

func NewPortStatsPropOptical() *PortStatsPropOptical {
	return &PortStatsPropOptical{
		PortStatsProp: NewPortStatsProp(1),
	}
}

type QueueDesc struct {
	PortNo     uint32
	QueueId    uint32
	Length     uint16
	Properties []IQueueDescProp
}

func (self *QueueDesc) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.PortNo))
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[8:10], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDesc(decoder *goloxi.Decoder) (*QueueDesc, error) {
	queuedesc := &QueueDesc{}
	if decoder.Length() < 16 {
		return nil, fmt.Errorf("QueueDesc packet too short: %d < 16", decoder.Length())
	}
	queuedesc.PortNo = uint32(decoder.ReadUint32())
	queuedesc.QueueId = uint32(decoder.ReadUint32())
	queuedesc.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queuedesc.Length), 2+8)
	decoder.Skip(6)

	for decoder.Length() >= 4 {
		item, err := decodeQueueDescProp(decoder)
		if err != nil {
			return nil, err
		}
		queuedesc.Properties = append(queuedesc.Properties, item)
	}
	return queuedesc, nil
}

func NewQueueDesc() *QueueDesc {
	return &QueueDesc{}
}

type QueueDescProp struct {
	Type   uint16
	Length uint16
}

type IQueueDescProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *QueueDescProp) GetType() uint16 {
	return self.Type
}

func (self *QueueDescProp) GetLength() uint16 {
	return self.Length
}

func (self *QueueDescProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeQueueDescProp(decoder *goloxi.Decoder) (IQueueDescProp, error) {
	queuedescprop := &QueueDescProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescProp packet too short: %d < 4", decoder.Length())
	}
	queuedescprop.Type = uint16(decoder.ReadUint16())
	queuedescprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queuedescprop.Length), 2+2)

	switch queuedescprop.Type {
	case 1:
		return decodeQueueDescPropMinRate(queuedescprop, decoder)
	case 2:
		return decodeQueueDescPropMaxRate(queuedescprop, decoder)
	case 65535:
		return decodeQueueDescPropExperimenter(queuedescprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescProp'", queuedescprop.Type)
	}
}

func NewQueueDescProp(_type uint16) *QueueDescProp {
	return &QueueDescProp{
		Type: _type,
	}
}

type QueueDescPropExperimenter struct {
	*QueueDescProp
	Experimenter uint32
	ExpType      uint32
}

type IQueueDescPropExperimenter interface {
	IQueueDescProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *QueueDescPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueueDescPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *QueueDescPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeQueueDescPropExperimenter(parent *QueueDescProp, decoder *goloxi.Decoder) (IQueueDescPropExperimenter, error) {
	queuedescpropexperimenter := &QueueDescPropExperimenter{QueueDescProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueDescPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	queuedescpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	queuedescpropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch queuedescpropexperimenter.Experimenter {
	case 6035143:
		return decodeQueueDescPropBsn(queuedescpropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescPropExperimenter'", queuedescpropexperimenter.Experimenter)
	}
}

func NewQueueDescPropExperimenter(_experimenter uint32) *QueueDescPropExperimenter {
	return &QueueDescPropExperimenter{
		Experimenter:  _experimenter,
		QueueDescProp: NewQueueDescProp(65535),
	}
}

type QueueDescPropBsn struct {
	*QueueDescPropExperimenter
}

type IQueueDescPropBsn interface {
	IQueueDescPropExperimenter
}

func (self *QueueDescPropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	return nil
}

func decodeQueueDescPropBsn(parent *QueueDescPropExperimenter, decoder *goloxi.Decoder) (IQueueDescPropBsn, error) {
	queuedescpropbsn := &QueueDescPropBsn{QueueDescPropExperimenter: parent}

	switch queuedescpropbsn.ExpType {
	case 0:
		return decodeQueueDescPropBsnQueueName(queuedescpropbsn, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueDescPropBsn'", queuedescpropbsn.ExpType)
	}
}

func NewQueueDescPropBsn(_exp_type uint32) *QueueDescPropBsn {
	return &QueueDescPropBsn{
		ExpType:                   _exp_type,
		QueueDescPropExperimenter: NewQueueDescPropExperimenter(6035143),
	}
}

type QueueDescPropBsnQueueName struct {
	*QueueDescPropBsn
	Name []byte
}

func (self *QueueDescPropBsnQueueName) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescPropBsn.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.Name)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDescPropBsnQueueName(parent *QueueDescPropBsn, decoder *goloxi.Decoder) (*QueueDescPropBsnQueueName, error) {
	queuedescpropbsnqueuename := &QueueDescPropBsnQueueName{QueueDescPropBsn: parent}
	queuedescpropbsnqueuename.Name = decoder.Read(decoder.Length())
	return queuedescpropbsnqueuename, nil
}

func NewQueueDescPropBsnQueueName() *QueueDescPropBsnQueueName {
	return &QueueDescPropBsnQueueName{
		QueueDescPropBsn: NewQueueDescPropBsn(0),
	}
}

type QueueDescPropMaxRate struct {
	*QueueDescProp
	Rate uint16
}

func (self *QueueDescPropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDescPropMaxRate(parent *QueueDescProp, decoder *goloxi.Decoder) (*QueueDescPropMaxRate, error) {
	queuedescpropmaxrate := &QueueDescPropMaxRate{QueueDescProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescPropMaxRate packet too short: %d < 4", decoder.Length())
	}
	queuedescpropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return queuedescpropmaxrate, nil
}

func NewQueueDescPropMaxRate() *QueueDescPropMaxRate {
	return &QueueDescPropMaxRate{
		QueueDescProp: NewQueueDescProp(2),
	}
}

type QueueDescPropMinRate struct {
	*QueueDescProp
	Rate uint16
}

func (self *QueueDescPropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueDescProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 2))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueDescPropMinRate(parent *QueueDescProp, decoder *goloxi.Decoder) (*QueueDescPropMinRate, error) {
	queuedescpropminrate := &QueueDescPropMinRate{QueueDescProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueDescPropMinRate packet too short: %d < 4", decoder.Length())
	}
	queuedescpropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(2)
	return queuedescpropminrate, nil
}

func NewQueueDescPropMinRate() *QueueDescPropMinRate {
	return &QueueDescPropMinRate{
		QueueDescProp: NewQueueDescProp(1),
	}
}

type QueueProp struct {
	Type uint16
	Len  uint16
}

type IQueueProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLen() uint16
}

func (self *QueueProp) GetType() uint16 {
	return self.Type
}

func (self *QueueProp) GetLen() uint16 {
	return self.Len
}

func (self *QueueProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))

	return nil
}

func decodeQueueProp(decoder *goloxi.Decoder) (IQueueProp, error) {
	queueprop := &QueueProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueProp packet too short: %d < 4", decoder.Length())
	}
	queueprop.Type = uint16(decoder.ReadUint16())
	queueprop.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queueprop.Len), 2+2)

	switch queueprop.Type {
	case 1:
		return decodeQueuePropMinRate(queueprop, decoder)
	case 2:
		return decodeQueuePropMaxRate(queueprop, decoder)
	case 65535:
		return decodeQueuePropExperimenter(queueprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueProp'", queueprop.Type)
	}
}

func NewQueueProp(_type uint16) *QueueProp {
	return &QueueProp{
		Type: _type,
	}
}

type QueuePropExperimenter struct {
	*QueueProp
	Experimenter uint32
}

type IQueuePropExperimenter interface {
	IQueueProp
	GetExperimenter() uint32
}

func (self *QueuePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueuePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint32(uint32(self.Experimenter))
	encoder.Write(bytes.Repeat([]byte{0}, 4))

	return nil
}

func decodeQueuePropExperimenter(parent *QueueProp, decoder *goloxi.Decoder) (IQueuePropExperimenter, error) {
	queuepropexperimenter := &QueuePropExperimenter{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	decoder.Skip(4)
	return queuepropexperimenter, nil
}

func NewQueuePropExperimenter(_experimenter uint32) *QueuePropExperimenter {
	return &QueuePropExperimenter{
		Experimenter: _experimenter,
		QueueProp:    NewQueueProp(65535),
	}
}

type QueuePropMaxRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMaxRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueuePropMaxRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMaxRate, error) {
	queuepropmaxrate := &QueuePropMaxRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMaxRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropmaxrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return queuepropmaxrate, nil
}

func NewQueuePropMaxRate() *QueuePropMaxRate {
	return &QueuePropMaxRate{
		QueueProp: NewQueueProp(2),
	}
}

type QueuePropMinRate struct {
	*QueueProp
	Rate uint16
}

func (self *QueuePropMinRate) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(bytes.Repeat([]byte{0}, 4))
	encoder.PutUint16(uint16(self.Rate))
	encoder.Write(bytes.Repeat([]byte{0}, 6))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueuePropMinRate(parent *QueueProp, decoder *goloxi.Decoder) (*QueuePropMinRate, error) {
	queuepropminrate := &QueuePropMinRate{QueueProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueuePropMinRate packet too short: %d < 8", decoder.Length())
	}
	decoder.Skip(4)
	queuepropminrate.Rate = uint16(decoder.ReadUint16())
	decoder.Skip(6)
	return queuepropminrate, nil
}

func NewQueuePropMinRate() *QueuePropMinRate {
	return &QueuePropMinRate{
		QueueProp: NewQueueProp(1),
	}
}

type QueueStatsEntry struct {
	Length       uint16
	PortNo       PortNo
	QueueId      uint32
	TxBytes      uint64
	TxPackets    uint64
	TxErrors     uint64
	DurationSec  uint32
	DurationNsec uint32
	Properties   []IQueueStatsProp
}

func (self *QueueStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(bytes.Repeat([]byte{0}, 6))
	self.PortNo.Serialize(encoder)
	encoder.PutUint32(uint32(self.QueueId))
	encoder.PutUint64(uint64(self.TxBytes))
	encoder.PutUint64(uint64(self.TxPackets))
	encoder.PutUint64(uint64(self.TxErrors))
	encoder.PutUint32(uint32(self.DurationSec))
	encoder.PutUint32(uint32(self.DurationNsec))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsEntry(decoder *goloxi.Decoder) (*QueueStatsEntry, error) {
	queuestatsentry := &QueueStatsEntry{}
	if decoder.Length() < 48 {
		return nil, fmt.Errorf("QueueStatsEntry packet too short: %d < 48", decoder.Length())
	}
	queuestatsentry.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queuestatsentry.Length), 2+0)
	decoder.Skip(6)
	queuestatsentry.PortNo.Decode(decoder)
	queuestatsentry.QueueId = uint32(decoder.ReadUint32())
	queuestatsentry.TxBytes = uint64(decoder.ReadUint64())
	queuestatsentry.TxPackets = uint64(decoder.ReadUint64())
	queuestatsentry.TxErrors = uint64(decoder.ReadUint64())
	queuestatsentry.DurationSec = uint32(decoder.ReadUint32())
	queuestatsentry.DurationNsec = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeQueueStatsProp(decoder)
		if err != nil {
			return nil, err
		}
		queuestatsentry.Properties = append(queuestatsentry.Properties, item)
	}
	return queuestatsentry, nil
}

func NewQueueStatsEntry() *QueueStatsEntry {
	return &QueueStatsEntry{}
}

type QueueStatsProp struct {
	Type   uint16
	Length uint16
}

type IQueueStatsProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *QueueStatsProp) GetType() uint16 {
	return self.Type
}

func (self *QueueStatsProp) GetLength() uint16 {
	return self.Length
}

func (self *QueueStatsProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeQueueStatsProp(decoder *goloxi.Decoder) (IQueueStatsProp, error) {
	queuestatsprop := &QueueStatsProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("QueueStatsProp packet too short: %d < 4", decoder.Length())
	}
	queuestatsprop.Type = uint16(decoder.ReadUint16())
	queuestatsprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(queuestatsprop.Length), 2+2)

	switch queuestatsprop.Type {
	case 65535:
		return decodeQueueStatsPropExperimenter(queuestatsprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueStatsProp'", queuestatsprop.Type)
	}
}

func NewQueueStatsProp(_type uint16) *QueueStatsProp {
	return &QueueStatsProp{
		Type: _type,
	}
}

type QueueStatsPropExperimenter struct {
	*QueueStatsProp
	Experimenter uint32
	ExpType      uint32
}

type IQueueStatsPropExperimenter interface {
	IQueueStatsProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *QueueStatsPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *QueueStatsPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *QueueStatsPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueStatsProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeQueueStatsPropExperimenter(parent *QueueStatsProp, decoder *goloxi.Decoder) (IQueueStatsPropExperimenter, error) {
	queuestatspropexperimenter := &QueueStatsPropExperimenter{QueueStatsProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("QueueStatsPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	queuestatspropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	queuestatspropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch queuestatspropexperimenter.Experimenter {
	case 6035143:
		return decodeQueueStatsPropBsn(queuestatspropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'QueueStatsPropExperimenter'", queuestatspropexperimenter.Experimenter)
	}
}

func NewQueueStatsPropExperimenter(_experimenter uint32) *QueueStatsPropExperimenter {
	return &QueueStatsPropExperimenter{
		Experimenter:   _experimenter,
		QueueStatsProp: NewQueueStatsProp(65535),
	}
}

type QueueStatsPropBsn struct {
	*QueueStatsPropExperimenter
	ExperimenterData []byte
}

func (self *QueueStatsPropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.QueueStatsPropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.ExperimenterData)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeQueueStatsPropBsn(parent *QueueStatsPropExperimenter, decoder *goloxi.Decoder) (*QueueStatsPropBsn, error) {
	queuestatspropbsn := &QueueStatsPropBsn{QueueStatsPropExperimenter: parent}
	queuestatspropbsn.ExperimenterData = decoder.Read(decoder.Length())
	return queuestatspropbsn, nil
}

func NewQueueStatsPropBsn() *QueueStatsPropBsn {
	return &QueueStatsPropBsn{
		QueueStatsPropExperimenter: NewQueueStatsPropExperimenter(6035143),
	}
}

type RoleProp struct {
	Type   uint16
	Length uint16
}

type IRoleProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *RoleProp) GetType() uint16 {
	return self.Type
}

func (self *RoleProp) GetLength() uint16 {
	return self.Length
}

func (self *RoleProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeRoleProp(decoder *goloxi.Decoder) (IRoleProp, error) {
	roleprop := &RoleProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("RoleProp packet too short: %d < 4", decoder.Length())
	}
	roleprop.Type = uint16(decoder.ReadUint16())
	roleprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(roleprop.Length), 2+2)

	switch roleprop.Type {
	case 65535:
		return decodeRolePropExperimenter(roleprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'RoleProp'", roleprop.Type)
	}
}

func NewRoleProp(_type uint16) *RoleProp {
	return &RoleProp{
		Type: _type,
	}
}

type RolePropExperimenter struct {
	*RoleProp
	Experimenter uint32
	ExpType      uint32
}

type IRolePropExperimenter interface {
	IRoleProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *RolePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *RolePropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *RolePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.RoleProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeRolePropExperimenter(parent *RoleProp, decoder *goloxi.Decoder) (IRolePropExperimenter, error) {
	rolepropexperimenter := &RolePropExperimenter{RoleProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("RolePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	rolepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	rolepropexperimenter.ExpType = uint32(decoder.ReadUint32())

	switch rolepropexperimenter.Experimenter {
	case 6035143:
		return decodeRolePropBsn(rolepropexperimenter, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'RolePropExperimenter'", rolepropexperimenter.Experimenter)
	}
}

func NewRolePropExperimenter(_experimenter uint32) *RolePropExperimenter {
	return &RolePropExperimenter{
		Experimenter: _experimenter,
		RoleProp:     NewRoleProp(65535),
	}
}

type RolePropBsn struct {
	*RolePropExperimenter
	ExperimenterData []byte
}

func (self *RolePropBsn) Serialize(encoder *goloxi.Encoder) error {
	if err := self.RolePropExperimenter.Serialize(encoder); err != nil {
		return err
	}

	encoder.Write(self.ExperimenterData)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeRolePropBsn(parent *RolePropExperimenter, decoder *goloxi.Decoder) (*RolePropBsn, error) {
	rolepropbsn := &RolePropBsn{RolePropExperimenter: parent}
	rolepropbsn.ExperimenterData = decoder.Read(decoder.Length())
	return rolepropbsn, nil
}

func NewRolePropBsn() *RolePropBsn {
	return &RolePropBsn{
		RolePropExperimenter: NewRolePropExperimenter(6035143),
	}
}

type StatV6 struct {
	Length    uint16
	OxsFields []IOxs
}

func (self *StatV6) Serialize(encoder *goloxi.Encoder) error {
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	encoder.PutUint16(uint16(self.Length))
	for _, obj := range self.OxsFields {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}
func (self *StatV6) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 4 {
		return fmt.Errorf("StatV6 packet too short: %d < 4", decoder.Length())
	}

	decoder.Skip(2)
	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+2)

	for decoder.Length() >= 4 {
		item, err := decodeOxs(decoder)
		if err != nil {
			return err
		}
		self.OxsFields = append(self.OxsFields, item)
	}

	decoder.SkipAlign()

	return nil
}

func NewStatV6() *StatV6 {
	return &StatV6{}
}

type TableDesc struct {
	Length     uint16
	TableId    uint8
	Config     TableConfig
	Properties []ITableModProp
}

func (self *TableDesc) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 1))
	encoder.PutUint32(uint32(self.Config))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}
func (self *TableDesc) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 8 {
		return fmt.Errorf("TableDesc packet too short: %d < 8", decoder.Length())
	}

	self.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(self.Length), 2+0)
	self.TableId = uint8(decoder.ReadByte())
	decoder.Skip(1)
	self.Config = TableConfig(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeTableModProp(decoder)
		if err != nil {
			return err
		}
		self.Properties = append(self.Properties, item)
	}

	return nil
}

func NewTableDesc() *TableDesc {
	return &TableDesc{}
}

type TableFeatureProp struct {
	Type   uint16
	Length uint16
}

type ITableFeatureProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *TableFeatureProp) GetType() uint16 {
	return self.Type
}

func (self *TableFeatureProp) GetLength() uint16 {
	return self.Length
}

func (self *TableFeatureProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeTableFeatureProp(decoder *goloxi.Decoder) (ITableFeatureProp, error) {
	tablefeatureprop := &TableFeatureProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableFeatureProp packet too short: %d < 4", decoder.Length())
	}
	tablefeatureprop.Type = uint16(decoder.ReadUint16())
	tablefeatureprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(tablefeatureprop.Length), 2+2)

	switch tablefeatureprop.Type {
	case 0:
		return decodeTableFeaturePropInstructions(tablefeatureprop, decoder)
	case 1:
		return decodeTableFeaturePropInstructionsMiss(tablefeatureprop, decoder)
	case 2:
		return decodeTableFeaturePropNextTables(tablefeatureprop, decoder)
	case 3:
		return decodeTableFeaturePropNextTablesMiss(tablefeatureprop, decoder)
	case 4:
		return decodeTableFeaturePropWriteActions(tablefeatureprop, decoder)
	case 5:
		return decodeTableFeaturePropWriteActionsMiss(tablefeatureprop, decoder)
	case 6:
		return decodeTableFeaturePropApplyActions(tablefeatureprop, decoder)
	case 7:
		return decodeTableFeaturePropApplyActionsMiss(tablefeatureprop, decoder)
	case 8:
		return decodeTableFeaturePropMatch(tablefeatureprop, decoder)
	case 10:
		return decodeTableFeaturePropWildcards(tablefeatureprop, decoder)
	case 12:
		return decodeTableFeaturePropWriteSetfield(tablefeatureprop, decoder)
	case 13:
		return decodeTableFeaturePropWriteSetfieldMiss(tablefeatureprop, decoder)
	case 14:
		return decodeTableFeaturePropApplySetfield(tablefeatureprop, decoder)
	case 15:
		return decodeTableFeaturePropApplySetfieldMiss(tablefeatureprop, decoder)
	case 16:
		return decodeTableFeaturePropTableSyncFrom(tablefeatureprop, decoder)
	case 18:
		return decodeTableFeaturePropWriteCopyfield(tablefeatureprop, decoder)
	case 19:
		return decodeTableFeaturePropWriteCopyfieldMiss(tablefeatureprop, decoder)
	case 20:
		return decodeTableFeaturePropApplyCopyfield(tablefeatureprop, decoder)
	case 21:
		return decodeTableFeaturePropApplyCopyfieldMiss(tablefeatureprop, decoder)
	case 65534:
		return decodeTableFeaturePropExperimenter(tablefeatureprop, decoder)
	case 65535:
		return decodeTableFeaturePropExperimenterMiss(tablefeatureprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'TableFeatureProp'", tablefeatureprop.Type)
	}
}

func NewTableFeatureProp(_type uint16) *TableFeatureProp {
	return &TableFeatureProp{
		Type: _type,
	}
}

type TableFeaturePropApplyActions struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropApplyActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplyActions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyActions, error) {
	tablefeaturepropapplyactions := &TableFeaturePropApplyActions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplyactions.ActionIds = append(tablefeaturepropapplyactions.ActionIds, item)
	}
	return tablefeaturepropapplyactions, nil
}

func NewTableFeaturePropApplyActions() *TableFeaturePropApplyActions {
	return &TableFeaturePropApplyActions{
		TableFeatureProp: NewTableFeatureProp(6),
	}
}

type TableFeaturePropApplyActionsMiss struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropApplyActionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplyActionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyActionsMiss, error) {
	tablefeaturepropapplyactionsmiss := &TableFeaturePropApplyActionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplyactionsmiss.ActionIds = append(tablefeaturepropapplyactionsmiss.ActionIds, item)
	}
	return tablefeaturepropapplyactionsmiss, nil
}

func NewTableFeaturePropApplyActionsMiss() *TableFeaturePropApplyActionsMiss {
	return &TableFeaturePropApplyActionsMiss{
		TableFeatureProp: NewTableFeatureProp(7),
	}
}

type TableFeaturePropApplyCopyfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplyCopyfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplyCopyfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyCopyfield, error) {
	tablefeaturepropapplycopyfield := &TableFeaturePropApplyCopyfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplycopyfield.OxmIds = append(tablefeaturepropapplycopyfield.OxmIds, item)
	}
	return tablefeaturepropapplycopyfield, nil
}

func NewTableFeaturePropApplyCopyfield() *TableFeaturePropApplyCopyfield {
	return &TableFeaturePropApplyCopyfield{
		TableFeatureProp: NewTableFeatureProp(20),
	}
}

type TableFeaturePropApplyCopyfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplyCopyfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplyCopyfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplyCopyfieldMiss, error) {
	tablefeaturepropapplycopyfieldmiss := &TableFeaturePropApplyCopyfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplycopyfieldmiss.OxmIds = append(tablefeaturepropapplycopyfieldmiss.OxmIds, item)
	}
	return tablefeaturepropapplycopyfieldmiss, nil
}

func NewTableFeaturePropApplyCopyfieldMiss() *TableFeaturePropApplyCopyfieldMiss {
	return &TableFeaturePropApplyCopyfieldMiss{
		TableFeatureProp: NewTableFeatureProp(21),
	}
}

type TableFeaturePropApplySetfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplySetfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplySetfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplySetfield, error) {
	tablefeaturepropapplysetfield := &TableFeaturePropApplySetfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplysetfield.OxmIds = append(tablefeaturepropapplysetfield.OxmIds, item)
	}
	return tablefeaturepropapplysetfield, nil
}

func NewTableFeaturePropApplySetfield() *TableFeaturePropApplySetfield {
	return &TableFeaturePropApplySetfield{
		TableFeatureProp: NewTableFeatureProp(14),
	}
}

type TableFeaturePropApplySetfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropApplySetfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropApplySetfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropApplySetfieldMiss, error) {
	tablefeaturepropapplysetfieldmiss := &TableFeaturePropApplySetfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropapplysetfieldmiss.OxmIds = append(tablefeaturepropapplysetfieldmiss.OxmIds, item)
	}
	return tablefeaturepropapplysetfieldmiss, nil
}

func NewTableFeaturePropApplySetfieldMiss() *TableFeaturePropApplySetfieldMiss {
	return &TableFeaturePropApplySetfieldMiss{
		TableFeatureProp: NewTableFeatureProp(15),
	}
}

type TableFeaturePropExperimenter struct {
	*TableFeatureProp
	Experimenter uint32
	Subtype      uint32
}

type ITableFeaturePropExperimenter interface {
	ITableFeatureProp
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *TableFeaturePropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableFeaturePropExperimenter) GetSubtype() uint32 {
	return self.Subtype
}

func (self *TableFeaturePropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeTableFeaturePropExperimenter(parent *TableFeatureProp, decoder *goloxi.Decoder) (ITableFeaturePropExperimenter, error) {
	tablefeaturepropexperimenter := &TableFeaturePropExperimenter{TableFeatureProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableFeaturePropExperimenter packet too short: %d < 8", decoder.Length())
	}
	tablefeaturepropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	tablefeaturepropexperimenter.Subtype = uint32(decoder.ReadUint32())
	return tablefeaturepropexperimenter, nil
}

func NewTableFeaturePropExperimenter(_experimenter uint32) *TableFeaturePropExperimenter {
	return &TableFeaturePropExperimenter{
		Experimenter:     _experimenter,
		TableFeatureProp: NewTableFeatureProp(65534),
	}
}

type TableFeaturePropExperimenterMiss struct {
	*TableFeatureProp
	Experimenter uint32
	Subtype      uint32
}

type ITableFeaturePropExperimenterMiss interface {
	ITableFeatureProp
	GetExperimenter() uint32
	GetSubtype() uint32
}

func (self *TableFeaturePropExperimenterMiss) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableFeaturePropExperimenterMiss) GetSubtype() uint32 {
	return self.Subtype
}

func (self *TableFeaturePropExperimenterMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.Subtype))

	return nil
}

func decodeTableFeaturePropExperimenterMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (ITableFeaturePropExperimenterMiss, error) {
	tablefeaturepropexperimentermiss := &TableFeaturePropExperimenterMiss{TableFeatureProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableFeaturePropExperimenterMiss packet too short: %d < 8", decoder.Length())
	}
	tablefeaturepropexperimentermiss.Experimenter = uint32(decoder.ReadUint32())
	tablefeaturepropexperimentermiss.Subtype = uint32(decoder.ReadUint32())
	return tablefeaturepropexperimentermiss, nil
}

func NewTableFeaturePropExperimenterMiss(_experimenter uint32) *TableFeaturePropExperimenterMiss {
	return &TableFeaturePropExperimenterMiss{
		Experimenter:     _experimenter,
		TableFeatureProp: NewTableFeatureProp(65535),
	}
}

type TableFeaturePropInstructions struct {
	*TableFeatureProp
	InstructionIds []IInstructionId
}

func (self *TableFeaturePropInstructions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.InstructionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropInstructions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropInstructions, error) {
	tablefeaturepropinstructions := &TableFeaturePropInstructions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeInstructionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropinstructions.InstructionIds = append(tablefeaturepropinstructions.InstructionIds, item)
	}
	return tablefeaturepropinstructions, nil
}

func NewTableFeaturePropInstructions() *TableFeaturePropInstructions {
	return &TableFeaturePropInstructions{
		TableFeatureProp: NewTableFeatureProp(0),
	}
}

type TableFeaturePropInstructionsMiss struct {
	*TableFeatureProp
	InstructionIds []IInstructionId
}

func (self *TableFeaturePropInstructionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.InstructionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropInstructionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropInstructionsMiss, error) {
	tablefeaturepropinstructionsmiss := &TableFeaturePropInstructionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeInstructionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropinstructionsmiss.InstructionIds = append(tablefeaturepropinstructionsmiss.InstructionIds, item)
	}
	return tablefeaturepropinstructionsmiss, nil
}

func NewTableFeaturePropInstructionsMiss() *TableFeaturePropInstructionsMiss {
	return &TableFeaturePropInstructionsMiss{
		TableFeatureProp: NewTableFeatureProp(1),
	}
}

type TableFeaturePropMatch struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropMatch) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropMatch(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropMatch, error) {
	tablefeaturepropmatch := &TableFeaturePropMatch{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropmatch.OxmIds = append(tablefeaturepropmatch.OxmIds, item)
	}
	return tablefeaturepropmatch, nil
}

func NewTableFeaturePropMatch() *TableFeaturePropMatch {
	return &TableFeaturePropMatch{
		TableFeatureProp: NewTableFeatureProp(8),
	}
}

type TableFeaturePropNextTables struct {
	*TableFeatureProp
	NextTableIds []*Uint8
}

func (self *TableFeaturePropNextTables) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.NextTableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropNextTables(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropNextTables, error) {
	tablefeaturepropnexttables := &TableFeaturePropNextTables{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := decodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropnexttables.NextTableIds = append(tablefeaturepropnexttables.NextTableIds, item)
	}
	return tablefeaturepropnexttables, nil
}

func NewTableFeaturePropNextTables() *TableFeaturePropNextTables {
	return &TableFeaturePropNextTables{
		TableFeatureProp: NewTableFeatureProp(2),
	}
}

type TableFeaturePropNextTablesMiss struct {
	*TableFeatureProp
	NextTableIds []*Uint8
}

func (self *TableFeaturePropNextTablesMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.NextTableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropNextTablesMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropNextTablesMiss, error) {
	tablefeaturepropnexttablesmiss := &TableFeaturePropNextTablesMiss{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := decodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropnexttablesmiss.NextTableIds = append(tablefeaturepropnexttablesmiss.NextTableIds, item)
	}
	return tablefeaturepropnexttablesmiss, nil
}

func NewTableFeaturePropNextTablesMiss() *TableFeaturePropNextTablesMiss {
	return &TableFeaturePropNextTablesMiss{
		TableFeatureProp: NewTableFeatureProp(3),
	}
}

type TableFeaturePropOxmValues struct {
	Type      uint16
	Length    uint16
	OxmValues []byte
}

func (self *TableFeaturePropOxmValues) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(self.OxmValues)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropOxmValues(decoder *goloxi.Decoder) (*TableFeaturePropOxmValues, error) {
	tablefeaturepropoxmvalues := &TableFeaturePropOxmValues{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableFeaturePropOxmValues packet too short: %d < 4", decoder.Length())
	}
	tablefeaturepropoxmvalues.Type = uint16(decoder.ReadUint16())
	// if tablefeaturepropoxmvalues.Type != 22 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '22'.", tablefeaturepropoxmvalues.Type)
	// }
	tablefeaturepropoxmvalues.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(tablefeaturepropoxmvalues.Length), 2+2)
	tablefeaturepropoxmvalues.OxmValues = decoder.Read(decoder.Length())
	return tablefeaturepropoxmvalues, nil
}

func NewTableFeaturePropOxmValues() *TableFeaturePropOxmValues {
	return &TableFeaturePropOxmValues{}
}

type TableFeaturePropTableSyncFrom struct {
	*TableFeatureProp
	TableIds []*Uint8
}

func (self *TableFeaturePropTableSyncFrom) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.TableIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropTableSyncFrom(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropTableSyncFrom, error) {
	tablefeatureproptablesyncfrom := &TableFeaturePropTableSyncFrom{TableFeatureProp: parent}

	for decoder.Length() >= 1 {
		item, err := decodeUint8(decoder)
		if err != nil {
			return nil, err
		}
		tablefeatureproptablesyncfrom.TableIds = append(tablefeatureproptablesyncfrom.TableIds, item)
	}
	return tablefeatureproptablesyncfrom, nil
}

func NewTableFeaturePropTableSyncFrom() *TableFeaturePropTableSyncFrom {
	return &TableFeaturePropTableSyncFrom{
		TableFeatureProp: NewTableFeatureProp(16),
	}
}

type TableFeaturePropWildcards struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWildcards) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWildcards(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWildcards, error) {
	tablefeaturepropwildcards := &TableFeaturePropWildcards{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwildcards.OxmIds = append(tablefeaturepropwildcards.OxmIds, item)
	}
	return tablefeaturepropwildcards, nil
}

func NewTableFeaturePropWildcards() *TableFeaturePropWildcards {
	return &TableFeaturePropWildcards{
		TableFeatureProp: NewTableFeatureProp(10),
	}
}

type TableFeaturePropWriteActions struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropWriteActions) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteActions(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteActions, error) {
	tablefeaturepropwriteactions := &TableFeaturePropWriteActions{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwriteactions.ActionIds = append(tablefeaturepropwriteactions.ActionIds, item)
	}
	return tablefeaturepropwriteactions, nil
}

func NewTableFeaturePropWriteActions() *TableFeaturePropWriteActions {
	return &TableFeaturePropWriteActions{
		TableFeatureProp: NewTableFeatureProp(4),
	}
}

type TableFeaturePropWriteActionsMiss struct {
	*TableFeatureProp
	ActionIds []IActionId
}

func (self *TableFeaturePropWriteActionsMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.ActionIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteActionsMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteActionsMiss, error) {
	tablefeaturepropwriteactionsmiss := &TableFeaturePropWriteActionsMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeActionId(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwriteactionsmiss.ActionIds = append(tablefeaturepropwriteactionsmiss.ActionIds, item)
	}
	return tablefeaturepropwriteactionsmiss, nil
}

func NewTableFeaturePropWriteActionsMiss() *TableFeaturePropWriteActionsMiss {
	return &TableFeaturePropWriteActionsMiss{
		TableFeatureProp: NewTableFeatureProp(5),
	}
}

type TableFeaturePropWriteCopyfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteCopyfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteCopyfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteCopyfield, error) {
	tablefeaturepropwritecopyfield := &TableFeaturePropWriteCopyfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwritecopyfield.OxmIds = append(tablefeaturepropwritecopyfield.OxmIds, item)
	}
	return tablefeaturepropwritecopyfield, nil
}

func NewTableFeaturePropWriteCopyfield() *TableFeaturePropWriteCopyfield {
	return &TableFeaturePropWriteCopyfield{
		TableFeatureProp: NewTableFeatureProp(18),
	}
}

type TableFeaturePropWriteCopyfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteCopyfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteCopyfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteCopyfieldMiss, error) {
	tablefeaturepropwritecopyfieldmiss := &TableFeaturePropWriteCopyfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwritecopyfieldmiss.OxmIds = append(tablefeaturepropwritecopyfieldmiss.OxmIds, item)
	}
	return tablefeaturepropwritecopyfieldmiss, nil
}

func NewTableFeaturePropWriteCopyfieldMiss() *TableFeaturePropWriteCopyfieldMiss {
	return &TableFeaturePropWriteCopyfieldMiss{
		TableFeatureProp: NewTableFeatureProp(19),
	}
}

type TableFeaturePropWriteSetfield struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteSetfield) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteSetfield(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteSetfield, error) {
	tablefeaturepropwritesetfield := &TableFeaturePropWriteSetfield{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwritesetfield.OxmIds = append(tablefeaturepropwritesetfield.OxmIds, item)
	}
	return tablefeaturepropwritesetfield, nil
}

func NewTableFeaturePropWriteSetfield() *TableFeaturePropWriteSetfield {
	return &TableFeaturePropWriteSetfield{
		TableFeatureProp: NewTableFeatureProp(12),
	}
}

type TableFeaturePropWriteSetfieldMiss struct {
	*TableFeatureProp
	OxmIds []*Uint32
}

func (self *TableFeaturePropWriteSetfieldMiss) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableFeatureProp.Serialize(encoder); err != nil {
		return err
	}

	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeaturePropWriteSetfieldMiss(parent *TableFeatureProp, decoder *goloxi.Decoder) (*TableFeaturePropWriteSetfieldMiss, error) {
	tablefeaturepropwritesetfieldmiss := &TableFeaturePropWriteSetfieldMiss{TableFeatureProp: parent}

	for decoder.Length() >= 4 {
		item, err := decodeUint32(decoder)
		if err != nil {
			return nil, err
		}
		tablefeaturepropwritesetfieldmiss.OxmIds = append(tablefeaturepropwritesetfieldmiss.OxmIds, item)
	}
	return tablefeaturepropwritesetfieldmiss, nil
}

func NewTableFeaturePropWriteSetfieldMiss() *TableFeaturePropWriteSetfieldMiss {
	return &TableFeaturePropWriteSetfieldMiss{
		TableFeatureProp: NewTableFeatureProp(13),
	}
}

type TableFeatures struct {
	Length        uint16
	TableId       uint8
	Command       TableFeaturesCommand
	Features      TableFeatureFlag
	Name          string
	MetadataMatch uint64
	MetadataWrite uint64
	Capabilities  TableConfig
	MaxEntries    uint32
	Properties    []ITableFeatureProp
}

func (self *TableFeatures) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Length))
	encoder.PutUint8(uint8(self.TableId))
	encoder.PutUint8(uint8(self.Command))
	encoder.PutUint32(uint32(self.Features))
	encoder.Write([]byte(self.Name))
	encoder.PutUint64(uint64(self.MetadataMatch))
	encoder.PutUint64(uint64(self.MetadataWrite))
	encoder.PutUint32(uint32(self.Capabilities))
	encoder.PutUint32(uint32(self.MaxEntries))
	for _, obj := range self.Properties {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[0:2], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableFeatures(decoder *goloxi.Decoder) (*TableFeatures, error) {
	tablefeatures := &TableFeatures{}
	if decoder.Length() < 64 {
		return nil, fmt.Errorf("TableFeatures packet too short: %d < 64", decoder.Length())
	}
	tablefeatures.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(tablefeatures.Length), 2+0)
	tablefeatures.TableId = uint8(decoder.ReadByte())
	tablefeatures.Command = TableFeaturesCommand(decoder.ReadByte())
	tablefeatures.Features = TableFeatureFlag(decoder.ReadUint32())
	tablefeatures.Name = string(bytes.Trim(decoder.Read(32), "\x00"))
	tablefeatures.MetadataMatch = uint64(decoder.ReadUint64())
	tablefeatures.MetadataWrite = uint64(decoder.ReadUint64())
	tablefeatures.Capabilities = TableConfig(decoder.ReadUint32())
	tablefeatures.MaxEntries = uint32(decoder.ReadUint32())

	for decoder.Length() >= 4 {
		item, err := decodeTableFeatureProp(decoder)
		if err != nil {
			return nil, err
		}
		tablefeatures.Properties = append(tablefeatures.Properties, item)
	}
	return tablefeatures, nil
}

func NewTableFeatures() *TableFeatures {
	return &TableFeatures{}
}

type TableModProp struct {
	Type   uint16
	Length uint16
}

type ITableModProp interface {
	goloxi.Serializable
	GetType() uint16
	GetLength() uint16
}

func (self *TableModProp) GetType() uint16 {
	return self.Type
}

func (self *TableModProp) GetLength() uint16 {
	return self.Length
}

func (self *TableModProp) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))

	return nil
}

func decodeTableModProp(decoder *goloxi.Decoder) (ITableModProp, error) {
	tablemodprop := &TableModProp{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableModProp packet too short: %d < 4", decoder.Length())
	}
	tablemodprop.Type = uint16(decoder.ReadUint16())
	tablemodprop.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(tablemodprop.Length), 2+2)

	switch tablemodprop.Type {
	case 2:
		return decodeTableModPropEviction(tablemodprop, decoder)
	case 3:
		return decodeTableModPropVacancy(tablemodprop, decoder)
	case 65535:
		return decodeTableModPropExperimenter(tablemodprop, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'TableModProp'", tablemodprop.Type)
	}
}

func NewTableModProp(_type uint16) *TableModProp {
	return &TableModProp{
		Type: _type,
	}
}

type TableModPropEviction struct {
	*TableModProp
	Flags TableModPropEvictionFlag
}

func (self *TableModPropEviction) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Flags))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableModPropEviction(parent *TableModProp, decoder *goloxi.Decoder) (*TableModPropEviction, error) {
	tablemodpropeviction := &TableModPropEviction{TableModProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableModPropEviction packet too short: %d < 4", decoder.Length())
	}
	tablemodpropeviction.Flags = TableModPropEvictionFlag(decoder.ReadUint32())
	return tablemodpropeviction, nil
}

func NewTableModPropEviction() *TableModPropEviction {
	return &TableModPropEviction{
		TableModProp: NewTableModProp(2),
	}
}

type TableModPropExperimenter struct {
	*TableModProp
	Experimenter uint32
	ExpType      uint32
}

type ITableModPropExperimenter interface {
	ITableModProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *TableModPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *TableModPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *TableModPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeTableModPropExperimenter(parent *TableModProp, decoder *goloxi.Decoder) (ITableModPropExperimenter, error) {
	tablemodpropexperimenter := &TableModPropExperimenter{TableModProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("TableModPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	tablemodpropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	tablemodpropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return tablemodpropexperimenter, nil
}

func NewTableModPropExperimenter(_experimenter uint32) *TableModPropExperimenter {
	return &TableModPropExperimenter{
		Experimenter: _experimenter,
		TableModProp: NewTableModProp(65535),
	}
}

type TableModPropVacancy struct {
	*TableModProp
	VacancyDown uint8
	VacancyUp   uint8
	Vacancy     uint8
}

func (self *TableModPropVacancy) Serialize(encoder *goloxi.Encoder) error {
	if err := self.TableModProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.VacancyDown))
	encoder.PutUint8(uint8(self.VacancyUp))
	encoder.PutUint8(uint8(self.Vacancy))
	encoder.Write(bytes.Repeat([]byte{0}, 1))

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeTableModPropVacancy(parent *TableModProp, decoder *goloxi.Decoder) (*TableModPropVacancy, error) {
	tablemodpropvacancy := &TableModPropVacancy{TableModProp: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("TableModPropVacancy packet too short: %d < 4", decoder.Length())
	}
	tablemodpropvacancy.VacancyDown = uint8(decoder.ReadByte())
	tablemodpropvacancy.VacancyUp = uint8(decoder.ReadByte())
	tablemodpropvacancy.Vacancy = uint8(decoder.ReadByte())
	decoder.Skip(1)
	return tablemodpropvacancy, nil
}

func NewTableModPropVacancy() *TableModPropVacancy {
	return &TableModPropVacancy{
		TableModProp: NewTableModProp(3),
	}
}

type TableStatsEntry struct {
	TableId      uint8
	ActiveCount  uint32
	LookupCount  uint64
	MatchedCount uint64
}

func (self *TableStatsEntry) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.TableId))
	encoder.Write(bytes.Repeat([]byte{0}, 3))
	encoder.PutUint32(uint32(self.ActiveCount))
	encoder.PutUint64(uint64(self.LookupCount))
	encoder.PutUint64(uint64(self.MatchedCount))

	return nil
}

func decodeTableStatsEntry(decoder *goloxi.Decoder) (*TableStatsEntry, error) {
	tablestatsentry := &TableStatsEntry{}
	if decoder.Length() < 24 {
		return nil, fmt.Errorf("TableStatsEntry packet too short: %d < 24", decoder.Length())
	}
	tablestatsentry.TableId = uint8(decoder.ReadByte())
	decoder.Skip(3)
	tablestatsentry.ActiveCount = uint32(decoder.ReadUint32())
	tablestatsentry.LookupCount = uint64(decoder.ReadUint64())
	tablestatsentry.MatchedCount = uint64(decoder.ReadUint64())
	return tablestatsentry, nil
}

func NewTableStatsEntry() *TableStatsEntry {
	return &TableStatsEntry{}
}

type Uint32 struct {
	Value uint32
}

func (self *Uint32) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint32(uint32(self.Value))

	return nil
}

func decodeUint32(decoder *goloxi.Decoder) (*Uint32, error) {
	uint32 := &Uint32{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("Uint32 packet too short: %d < 4", decoder.Length())
	}
	uint32.Value = uint32(decoder.ReadUint32())
	return uint32, nil
}

func NewUint32() *Uint32 {
	return &Uint32{}
}

type Uint64 struct {
	Value uint64
}

func (self *Uint64) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint64(uint64(self.Value))

	return nil
}

func decodeUint64(decoder *goloxi.Decoder) (*Uint64, error) {
	uint64 := &Uint64{}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("Uint64 packet too short: %d < 8", decoder.Length())
	}
	uint64.Value = uint64(decoder.ReadUint64())
	return uint64, nil
}

func NewUint64() *Uint64 {
	return &Uint64{}
}

type Uint8 struct {
	Value uint8
}

func (self *Uint8) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint8(uint8(self.Value))

	return nil
}

func decodeUint8(decoder *goloxi.Decoder) (*Uint8, error) {
	uint8 := &Uint8{}
	if decoder.Length() < 1 {
		return nil, fmt.Errorf("Uint8 packet too short: %d < 1", decoder.Length())
	}
	uint8.Value = uint8(decoder.ReadByte())
	return uint8, nil
}

func NewUint8() *Uint8 {
	return &Uint8{}
}

type ActionCopyField struct {
	Type      uint16
	Len       uint16
	NBits     uint16
	SrcOffset uint16
	DstOffset uint16
	OxmIds    []IOxm
}

func (self *ActionCopyField) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Len))
	encoder.PutUint16(uint16(self.NBits))
	encoder.PutUint16(uint16(self.SrcOffset))
	encoder.PutUint16(uint16(self.DstOffset))
	encoder.Write(bytes.Repeat([]byte{0}, 2))
	for _, obj := range self.OxmIds {
		if err := obj.Serialize(encoder); err != nil {
			return err
		}
	}

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeActionCopyField(decoder *goloxi.Decoder) (*ActionCopyField, error) {
	actioncopyfield := &ActionCopyField{}
	if decoder.Length() < 12 {
		return nil, fmt.Errorf("ActionCopyField packet too short: %d < 12", decoder.Length())
	}
	actioncopyfield.Type = uint16(decoder.ReadUint16())
	// if actioncopyfield.Type != 28 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '28'.", actioncopyfield.Type)
	// }
	actioncopyfield.Len = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(actioncopyfield.Len), 2+2)
	actioncopyfield.NBits = uint16(decoder.ReadUint16())
	actioncopyfield.SrcOffset = uint16(decoder.ReadUint16())
	actioncopyfield.DstOffset = uint16(decoder.ReadUint16())
	decoder.Skip(2)

	for decoder.Length() >= 4 {
		item, err := decodeOxm(decoder)
		if err != nil {
			return nil, err
		}
		actioncopyfield.OxmIds = append(actioncopyfield.OxmIds, item)
	}
	return actioncopyfield, nil
}

func NewActionCopyField() *ActionCopyField {
	return &ActionCopyField{}
}

type ControllerStatusPropExperimenter struct {
	*ControllerStatusProp
	Experimenter uint32
	ExpType      uint32
}

type IControllerStatusPropExperimenter interface {
	IControllerStatusProp
	GetExperimenter() uint32
	GetExpType() uint32
}

func (self *ControllerStatusPropExperimenter) GetExperimenter() uint32 {
	return self.Experimenter
}

func (self *ControllerStatusPropExperimenter) GetExpType() uint32 {
	return self.ExpType
}

func (self *ControllerStatusPropExperimenter) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ControllerStatusProp.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint32(uint32(self.Experimenter))
	encoder.PutUint32(uint32(self.ExpType))

	return nil
}

func decodeControllerStatusPropExperimenter(parent *ControllerStatusProp, decoder *goloxi.Decoder) (IControllerStatusPropExperimenter, error) {
	controllerstatuspropexperimenter := &ControllerStatusPropExperimenter{ControllerStatusProp: parent}
	if decoder.Length() < 8 {
		return nil, fmt.Errorf("ControllerStatusPropExperimenter packet too short: %d < 8", decoder.Length())
	}
	controllerstatuspropexperimenter.Experimenter = uint32(decoder.ReadUint32())
	controllerstatuspropexperimenter.ExpType = uint32(decoder.ReadUint32())
	return controllerstatuspropexperimenter, nil
}

func NewControllerStatusPropExperimenter(_experimenter uint32) *ControllerStatusPropExperimenter {
	return &ControllerStatusPropExperimenter{
		Experimenter:         _experimenter,
		ControllerStatusProp: NewControllerStatusProp(65535),
	}
}

type ControllerStatusPropUri struct {
	*ControllerStatusProp
	Uri ControllerURI
}

func (self *ControllerStatusPropUri) Serialize(encoder *goloxi.Encoder) error {
	if err := self.ControllerStatusProp.Serialize(encoder); err != nil {
		return err
	}

	self.Uri.Serialize(encoder)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodeControllerStatusPropUri(parent *ControllerStatusProp, decoder *goloxi.Decoder) (*ControllerStatusPropUri, error) {
	controllerstatuspropuri := &ControllerStatusPropUri{ControllerStatusProp: parent}
	if decoder.Length() < 32 {
		return nil, fmt.Errorf("ControllerStatusPropUri packet too short: %d < 32", decoder.Length())
	}
	controllerstatuspropuri.Uri.Decode(decoder)
	return controllerstatuspropuri, nil
}

func NewControllerStatusPropUri() *ControllerStatusPropUri {
	return &ControllerStatusPropUri{
		ControllerStatusProp: NewControllerStatusProp(0),
	}
}

type EdPropHeader struct {
	PropClass uint16
}

type IEdPropHeader interface {
	goloxi.Serializable
	GetPropClass() uint16
}

func (self *EdPropHeader) GetPropClass() uint16 {
	return self.PropClass
}

func (self *EdPropHeader) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.PropClass))

	return nil
}
func (self *EdPropHeader) Decode(decoder *goloxi.Decoder) error {
	if decoder.Length() < 2 {
		return fmt.Errorf("EdPropHeader packet too short: %d < 2", decoder.Length())
	}

	self.PropClass = uint16(decoder.ReadUint16())

	return nil
}

func NewEdPropHeader(_prop_class uint16) *EdPropHeader {
	return &EdPropHeader{
		PropClass: _prop_class,
	}
}

type EdPropNsh struct {
	*EdPropHeader
	Type uint8
	Len  uint8
}

type IEdPropNsh interface {
	IEdPropHeader
	GetType() uint8
	GetLen() uint8
}

func (self *EdPropNsh) GetType() uint8 {
	return self.Type
}

func (self *EdPropNsh) GetLen() uint8 {
	return self.Len
}

func (self *EdPropNsh) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropHeader.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.Type))
	encoder.PutUint8(uint8(self.Len))

	return nil
}

func decodeEdPropNsh(parent *EdPropHeader, decoder *goloxi.Decoder) (IEdPropNsh, error) {
	edpropnsh := &EdPropNsh{EdPropHeader: parent}
	if decoder.Length() < 2 {
		return nil, fmt.Errorf("EdPropNsh packet too short: %d < 2", decoder.Length())
	}
	edpropnsh.Type = uint8(decoder.ReadByte())
	edpropnsh.Len = uint8(decoder.ReadByte())
	decoder = decoder.SliceDecoder(int(edpropnsh.Len), 1+3)

	switch edpropnsh.Type {
	case 1:
		return decodeEdPropNshMdType(edpropnsh, decoder)
	case 2:
		return decodeEdPropNshTlv(edpropnsh, decoder)
	default:
		return nil, fmt.Errorf("Invalid type '%d' for 'EdPropNsh'", edpropnsh.Type)
	}
}

func NewEdPropNsh(_type uint8) *EdPropNsh {
	return &EdPropNsh{
		Type:         _type,
		EdPropHeader: NewEdPropHeader(4),
	}
}

type EdPropNshMdType struct {
	*EdPropNsh
	MdType uint8
}

func (self *EdPropNshMdType) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint8(uint8(self.MdType))
	encoder.Write(bytes.Repeat([]byte{0}, 3))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshMdType(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshMdType, error) {
	edpropnshmdtype := &EdPropNshMdType{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshMdType packet too short: %d < 4", decoder.Length())
	}
	edpropnshmdtype.MdType = uint8(decoder.ReadByte())
	decoder.Skip(3)
	return edpropnshmdtype, nil
}

func NewEdPropNshMdType() *EdPropNshMdType {
	return &EdPropNshMdType{
		EdPropNsh: NewEdPropNsh(1),
	}
}

type EdPropNshTlv struct {
	*EdPropNsh
	TlvClass uint16
	TlvType  uint8
	TlvLen   uint8
}

func (self *EdPropNshTlv) Serialize(encoder *goloxi.Encoder) error {
	if err := self.EdPropNsh.Serialize(encoder); err != nil {
		return err
	}

	encoder.PutUint16(uint16(self.TlvClass))
	encoder.PutUint8(uint8(self.TlvType))
	encoder.PutUint8(uint8(self.TlvLen))

	// Overwrite length
	encoder.Bytes()[3] = uint8(len(encoder.Bytes()))

	return nil
}

func decodeEdPropNshTlv(parent *EdPropNsh, decoder *goloxi.Decoder) (*EdPropNshTlv, error) {
	edpropnshtlv := &EdPropNshTlv{EdPropNsh: parent}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("EdPropNshTlv packet too short: %d < 4", decoder.Length())
	}
	edpropnshtlv.TlvClass = uint16(decoder.ReadUint16())
	edpropnshtlv.TlvType = uint8(decoder.ReadByte())
	edpropnshtlv.TlvLen = uint8(decoder.ReadByte())
	return edpropnshtlv, nil
}

func NewEdPropNshTlv() *EdPropNshTlv {
	return &EdPropNshTlv{
		EdPropNsh: NewEdPropNsh(2),
	}
}

type PortDescPropRecirculate struct {
	Type    uint16
	Length  uint16
	PortNos []byte
}

func (self *PortDescPropRecirculate) Serialize(encoder *goloxi.Encoder) error {
	encoder.PutUint16(uint16(self.Type))
	encoder.PutUint16(uint16(self.Length))
	encoder.Write(self.PortNos)

	// Overwrite length
	binary.BigEndian.PutUint16(encoder.Bytes()[2:4], uint16(len(encoder.Bytes())))

	return nil
}

func decodePortDescPropRecirculate(decoder *goloxi.Decoder) (*PortDescPropRecirculate, error) {
	portdescproprecirculate := &PortDescPropRecirculate{}
	if decoder.Length() < 4 {
		return nil, fmt.Errorf("PortDescPropRecirculate packet too short: %d < 4", decoder.Length())
	}
	portdescproprecirculate.Type = uint16(decoder.ReadUint16())
	// if portdescproprecirculate.Type != 4 {
	// 	return fmt.Errorf("Wrong value '%d' for type, expected '4'.", portdescproprecirculate.Type)
	// }
	portdescproprecirculate.Length = uint16(decoder.ReadUint16())
	decoder = decoder.SliceDecoder(int(portdescproprecirculate.Length), 2+2)
	portdescproprecirculate.PortNos = decoder.Read(decoder.Length())
	return portdescproprecirculate, nil
}

func NewPortDescPropRecirculate() *PortDescPropRecirculate {
	return &PortDescPropRecirculate{}
}
